This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: hooks/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
hooks/
  expense-form/
    formSchema.ts
    useMerchantData.ts
    usePaymentMethodLogic.ts
    useRewardPoints.ts
    useRewardPointsStandalone.ts
  queries/
    usePaymentMethodsQuery.ts
    useTransactionsQuery.ts
  transaction-list/
    types.ts
    useTransactionData.ts
    useTransactionFilters.ts
  use-debounce.ts
  use-mobile.tsx
  use-toast.ts
  useCardAnalytics.ts
  useChartData.ts
  useCurrencyFormatter.ts
  useDashboard.ts
  useDashboardMetrics.ts
  useExpenseForm.ts
  useFilteredTransactions.ts
  useMediaQuery.ts
  usePaymentMethods.ts
  useSupabaseConnectionCheck.ts
  useTransactionActions.ts
  useTransactionList.ts
  useTransactionSubmit.ts

================================================================
Files
================================================================

================
File: hooks/expense-form/formSchema.ts
================
import { z } from 'zod';
import { MerchantCategoryCode } from '@/types';

// Form schema definition
export const formSchema = z.object({
  merchantName: z.string().min(1, 'Merchant name is required'),
  merchantAddress: z.string().optional(),
  isOnline: z.boolean().default(false),
  isContactless: z.boolean().default(false),
  amount: z.string().min(1, 'Amount is required').refine(value => !isNaN(Number(value)) && Number(value) > 0, {
    message: 'Amount must be a positive number',
  }),
  currency: z.string().min(1, 'Currency is required'),
  paymentMethodId: z.string().min(1, 'Payment method is required'),
  paymentAmount: z.string().refine(value => !isNaN(Number(value)) && Number(value) >= 0, {
    message: 'Payment amount must be a non-negative number',
  }).optional(),
  reimbursementAmount: z.string().refine(value => value === '' || (!isNaN(Number(value)) && Number(value) >= 0), {
    message: 'Reimbursement amount must be a non-negative number',
  }).default('0'),
  date: z.date({
    required_error: 'Date is required',
  }),
  notes: z.string().optional(),
  mcc: z.any().optional(),
});

export type FormValues = z.infer<typeof formSchema>;

================
File: hooks/expense-form/useMerchantData.ts
================
import { useCallback, useEffect, useState } from 'react';
import { MerchantCategoryCode } from '@/types';
import { UseFormReturn } from 'react-hook-form';
import { FormValues } from './formSchema';
import { getMerchantByName } from '@/utils/storageUtils';
import { getSuggestedMerchantCategory, hasMerchantCategorySuggestions } from '@/utils/storage/merchantTracking';

export const useMerchantData = (
  form: UseFormReturn<FormValues>,
  merchantName: string
) => {
  const [selectedMCC, setSelectedMCC] = useState<MerchantCategoryCode | undefined>();
  const [suggestionChecked, setSuggestionChecked] = useState(false);

  // Memoize merchant fetch to prevent excessive rerenders
  const fetchMerchant = useCallback(async (name: string) => {
    if (name && name.trim().length >= 3) {
      try {
        // First check if we have a merchant in database
        const existingMerchant = await getMerchantByName(name);
        if (existingMerchant?.mcc) {
          setSelectedMCC(existingMerchant.mcc);
          form.setValue('mcc', existingMerchant.mcc);
          return; // Exit if we found merchant with MCC
        }
        
        // If no merchant with MCC is found, check our mappings
        if (!suggestionChecked) {
          setSuggestionChecked(true);
          
          // Check if this merchant name has suggestions enabled and is not deleted
          const hasSuggestions = await hasMerchantCategorySuggestions(name);
          if (hasSuggestions) {
            const suggestedMCC = await getSuggestedMerchantCategory(name);
            if (suggestedMCC && (!selectedMCC || suggestedMCC.code !== selectedMCC.code)) {
              setSelectedMCC(suggestedMCC);
              form.setValue('mcc', suggestedMCC);
              return true; // Return true to indicate we found a suggestion
            }
          }
        }
        
        return false; // Return false to indicate no suggestion found
      } catch (error) {
        console.error('Error fetching merchant:', error);
        return false;
      }
    }
    return false;
  }, [form, selectedMCC, suggestionChecked]);

  // Debounce merchant fetch to avoid excessive API calls
  useEffect(() => {
    if (merchantName.trim().length < 3) {
      setSuggestionChecked(false); // Reset when merchant name changes significantly
      return;
    }
    
    const timer = setTimeout(() => {
      fetchMerchant(merchantName);
    }, 300); // 300ms debounce
    
    return () => clearTimeout(timer);
  }, [merchantName, fetchMerchant]);

  return { 
    selectedMCC, 
    setSelectedMCC,
    hasSuggestion: suggestionChecked
  };
};

================
File: hooks/expense-form/usePaymentMethodLogic.ts
================
import { useCallback, useEffect, useState } from 'react';
import { UseFormReturn } from 'react-hook-form';
import { PaymentMethod, Currency } from '@/types';
import { FormValues } from './formSchema';
import { findCashPaymentMethodForCurrency } from '@/utils/defaults/paymentMethods';
import { rewardCalculatorService } from '@/services/rewards/RewardCalculatorService';

// Initialize the reward calculator service
rewardCalculatorService.initialize().catch(error => {
  console.error('Failed to initialize reward calculator service:', error);
});

export const usePaymentMethodLogic = (
  form: UseFormReturn<FormValues>,
  paymentMethods: PaymentMethod[],
  currency: Currency,
  amount: number,
  isOnline: boolean
) => {
  const [selectedPaymentMethod, setSelectedPaymentMethod] = useState<PaymentMethod | undefined>();
  const [shouldOverridePayment, setShouldOverridePayment] = useState(false);
  
  const paymentMethodId = form.watch('paymentMethodId');

  // Initialize selected payment method based on stored payment methods
  useEffect(() => {
    if (paymentMethods.length > 0 && !paymentMethodId) {
      // Find default cash payment method for the selected currency
      const cashMethod = findCashPaymentMethodForCurrency(currency);
      if (cashMethod) {
        form.setValue('paymentMethodId', cashMethod.id);
        form.trigger('paymentMethodId');
      } else {
        // Use the first payment method as fallback
        form.setValue('paymentMethodId', paymentMethods[0].id);
        form.trigger('paymentMethodId');
      }
    }
  }, [paymentMethods, form, paymentMethodId, currency]);

  // Update payment method when currency changes
  useEffect(() => {
    if (currency && !paymentMethodId) {
      const cashMethod = findCashPaymentMethodForCurrency(currency);
      if (cashMethod) {
        form.setValue('paymentMethodId', cashMethod.id);
        form.trigger('paymentMethodId');
      }
    }
  }, [currency, form, paymentMethodId]);

  // Handle payment method selection changes - memoized to prevent excessive rerenders
  const updateSelectedPaymentMethod = useCallback(() => {
    if (paymentMethodId) {
      const method = paymentMethods.find(pm => pm.id === paymentMethodId);
      
      if (method) {
        setSelectedPaymentMethod(method);
        
        // Check if we need to handle currency conversion
        if (currency !== method.currency) {
          setShouldOverridePayment(true);
          
          // Set initial payment amount only if amount has changed
          if (amount > 0) {
            const conversionRates: Record<string, Record<string, number>> = {
              USD: { SGD: 1.35, EUR: 0.92, GBP: 0.78 },
              SGD: { USD: 0.74, EUR: 0.68, GBP: 0.58 },
              EUR: { USD: 1.09, SGD: 1.47, GBP: 0.85 },
              GBP: { USD: 1.28, SGD: 1.73, EUR: 1.17 }
            };
            
            const rate = conversionRates[currency]?.[method.currency] || 1;
            const convertedAmount = (amount * rate).toFixed(2);
            form.setValue('paymentAmount', convertedAmount);
          }
        } else {
          setShouldOverridePayment(false);
          form.setValue('paymentAmount', form.watch('amount'));
        }
        
        // Set contactless for credit cards when not online
        if (!isOnline && method.type === 'credit_card') {
          form.setValue('isContactless', true);
        }
      } else {
        setSelectedPaymentMethod(undefined);
        setShouldOverridePayment(false);
      }
    } else {
      setSelectedPaymentMethod(undefined);
      setShouldOverridePayment(false);
    }
  }, [currency, paymentMethodId, form, paymentMethods, amount, isOnline]);

  // Call the memoized update function when dependencies change
  useEffect(() => {
    updateSelectedPaymentMethod();
  }, [updateSelectedPaymentMethod]);

  return {
    selectedPaymentMethod,
    shouldOverridePayment,
  };
};

================
File: hooks/expense-form/useRewardPoints.ts
================
// hooks/expense-form/useRewardPoints.ts
import { useState } from 'react';
import { PaymentMethod } from '@/types';
import { simulateRewardPoints } from '@/services/rewards/rewardCalculationAdapter';

// Define return type for clearer API
export interface PointsSimulationResult {
  totalPoints: number;
  basePoints?: number;
  bonusPoints?: number;
  remainingMonthlyBonusPoints?: number;
  messageText?: string;
  pointsCurrency?: string;
  isLoading?: boolean;
  error?: string;
}

export const useRewardPoints = () => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | undefined>(undefined);

  /**
   * Simulate points for a transaction based on the given parameters
   */
  const simulatePoints = async (
    amount: number,
    currency: string,
    paymentMethod: PaymentMethod,
    mcc?: string,
    merchantName?: string,
    isOnline?: boolean,
    isContactless?: boolean
  ): Promise<PointsSimulationResult> => {
    // Reset state
    setIsLoading(true);
    setError(undefined);
    
    try {
      // Use the shared adapter function
      const result = await simulateRewardPoints(
        amount,
        currency,
        paymentMethod,
        mcc,
        merchantName,
        isOnline,
        isContactless
      );
      
      return {
        ...result,
        isLoading: false
      };
    } catch (err) {
      // Handle any unexpected errors
      const errorMessage = err instanceof Error ? err.message : 'Error calculating reward points';
      setError(errorMessage);
      console.error('Error in simulatePoints hook:', err);
      
      // Return fallback result with error
      return {
        totalPoints: Math.round(amount),
        basePoints: Math.round(amount),
        bonusPoints: 0,
        error: errorMessage,
        isLoading: false,
        pointsCurrency: 'Points'
      };
    } finally {
      setIsLoading(false);
    }
  };

  return { 
    simulatePoints,
    isLoading,
    error
  };
};

================
File: hooks/expense-form/useRewardPointsStandalone.ts
================
// hooks/expense-form/useRewardPointsStandalone.ts
import { useState, useEffect } from 'react';
import { PaymentMethod } from '@/types';
import { simulateRewardPoints } from '@/services/rewards/rewardCalculationAdapter';

// Define the result interface to include all possible fields
interface PointsResult {
  totalPoints: number;
  basePoints?: number;
  bonusPoints?: number;
  remainingMonthlyBonusPoints?: number;
  pointsCurrency?: string;
  messageText?: string;
}

/**
 * Hook for calculating reward points outside of the Dashboard context
 */
export function useRewardPointsStandalone(
  amount: number | null,
  paymentMethodId: string | null,
  paymentMethods: PaymentMethod[] | undefined,
  mcc?: string,
  merchantName?: string,
  isOnline?: boolean,
  isContactless?: boolean
) {
  // State for estimated points
  const [estimatedPoints, setEstimatedPoints] = useState<PointsResult>({
    totalPoints: 0,
    basePoints: 0,
    bonusPoints: 0
  });
  
  // Find selected payment method, with null check for paymentMethods
  const selectedPaymentMethod = paymentMethods && paymentMethodId ? 
    paymentMethods.find(pm => pm.id === paymentMethodId) || null : null;
  
  // Calculate estimated points when inputs change
  useEffect(() => {
    // Reset points if no amount or payment method
    if (!amount || amount <= 0 || !selectedPaymentMethod) {
      setEstimatedPoints({
        totalPoints: 0,
        basePoints: 0,
        bonusPoints: 0
      });
      return;
    }
    
    // Skip for cash payment methods
    if (selectedPaymentMethod.type === 'cash') {
      setEstimatedPoints({
        totalPoints: 0,
        basePoints: 0,
        bonusPoints: 0
      });
      return;
    }
    
    // Define an async function to get the points
    const calculatePoints = async () => {
      const currency = selectedPaymentMethod.currency || 'SGD';
      
      try {
        console.log('useRewardPointsStandalone: Calculating points with parameters:', {
          amount,
          currency, 
          selectedPaymentMethod: selectedPaymentMethod.name,
          mcc,
          merchantName,
          isOnline,
          isContactless
        });
        
        // Use the shared adapter function
        const result = await simulateRewardPoints(
          amount,
          currency,
          selectedPaymentMethod,
          mcc,
          merchantName,
          isOnline,
          isContactless
        );
        
        setEstimatedPoints(result);
      } catch (error) {
        console.error('Error calculating reward points:', error);
        // Provide fallback calculation
        const fallbackPoints = Math.round(amount);
        setEstimatedPoints({
          totalPoints: fallbackPoints,
          basePoints: fallbackPoints,
          bonusPoints: 0,
          messageText: 'Error calculating points'
        });
      }
    };
    
    // Call the async function
    calculatePoints();
  }, [amount, paymentMethodId, selectedPaymentMethod, mcc, merchantName, isOnline, isContactless, paymentMethods]);
  
  return {
    estimatedPoints,
    selectedPaymentMethod
  };
}

================
File: hooks/queries/usePaymentMethodsQuery.ts
================
import { useQuery } from "@tanstack/react-query";
import { PaymentMethod } from "@/types";
import { getPaymentMethods } from "@/utils/storageUtils";
import { toast } from "sonner";

/**
 * Custom hook to fetch payment methods using React Query
 */
export function usePaymentMethodsQuery() {
  return useQuery({
    queryKey: ["paymentMethods"],
    queryFn: async () => {
      try {
        return await getPaymentMethods();
      } catch (error) {
        console.error("Error fetching payment methods:", error);
        toast.error("Failed to load payment methods");
        return [] as PaymentMethod[];
      }
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}

================
File: hooks/queries/useTransactionsQuery.ts
================
import { useQuery } from "@tanstack/react-query";
import { Transaction } from "@/types";
import { getTransactions } from "@/utils/storage/transactions";
import { toast } from "sonner";

/**
 * Custom hook to fetch transactions using React Query
 */
export function useTransactionsQuery() {
  return useQuery({
    queryKey: ["transactions"],
    queryFn: async () => {
      try {
        const transactions = await getTransactions();
        return transactions.filter(tx => !tx.is_deleted);
      } catch (error) {
        console.error("Error fetching transactions:", error);
        toast.error("Failed to load transactions");
        return [] as Transaction[];
      }
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}

================
File: hooks/transaction-list/types.ts
================
import { Transaction, PaymentMethod } from '@/types';

export type FilterOptions = {
  merchantName: string;
  paymentMethodId: string;
  currency: string;
  startDate: string;
  endDate: string;
};

export type SortOption = 'date-desc' | 'date-asc' | 'amount-desc' | 'amount-asc';

================
File: hooks/transaction-list/useTransactionData.ts
================
import { useState, useEffect, useCallback } from 'react';
import { Transaction, PaymentMethod } from '@/types';
import { getTransactions, getPaymentMethods } from '@/utils/storageUtils';
import { useToast } from '@/hooks/use-toast';
import { supabase, USE_LOCAL_STORAGE_DEFAULT } from '@/integrations/supabase/client';

export const useTransactionData = () => {
  const { toast } = useToast();
  const [transactions, setTransactions] = useState<Transaction[]>([]);
  const [paymentMethods, setPaymentMethods] = useState<PaymentMethod[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  // Function to load transactions
  const loadTransactions = useCallback(async () => {
    try {
      setIsLoading(true);
      console.log('Loading transactions with forceLocalStorage:', USE_LOCAL_STORAGE_DEFAULT);
      
      // Use the global setting for storage preference
      const loadedTransactions = await getTransactions(USE_LOCAL_STORAGE_DEFAULT);
      const loadedPaymentMethods = await getPaymentMethods();
      
      console.log('Loaded transactions:', loadedTransactions.length);
      setTransactions(loadedTransactions);
      setPaymentMethods(loadedPaymentMethods);
    } catch (error) {
      console.error('Error loading data:', error);
      toast({
        title: 'Error',
        description: 'Failed to load transaction data',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  }, [toast]);
  
  // Set up Supabase listener only once on mount
  useEffect(() => {
    // Initial load
    loadTransactions();
    
    // Only set up the Supabase channel if we're not defaulting to local storage
    const channel = !USE_LOCAL_STORAGE_DEFAULT ? supabase
      .channel('public:transactions')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'transactions'
      }, () => {
        // When any transaction changes, reload the transactions
        loadTransactions();
      })
      .subscribe() : null;
    
    return () => {
      if (channel) supabase.removeChannel(channel);
    };
  }, [loadTransactions]);

  return {
    transactions,
    setTransactions,
    paymentMethods,
    isLoading,
    refreshTransactions: loadTransactions
  };
};

================
File: hooks/transaction-list/useTransactionFilters.ts
================
import { useState, useEffect, useMemo } from 'react';
import { Transaction, Currency } from '@/types';
import { SortOption } from '@/components/transaction/TransactionSortAndView';
import { FilterOptions } from '@/components/transaction/TransactionFilters';
import { getStatementPeriod } from '@/utils/dateUtils';

const initialFilterOptions: FilterOptions = {
  merchantName: '',
  paymentMethodId: 'all', // Changed from empty string to 'all'
  currency: 'all', // Changed from empty string to 'all'
  startDate: '',
  endDate: '',
};

export const useTransactionFilters = (transactions: Transaction[], isLoading: boolean) => {
  const [sortOption, setSortOption] = useState<SortOption>('date-desc');
  const [searchQuery, setSearchQuery] = useState('');
  const [filterOptions, setFilterOptions] = useState<FilterOptions>(initialFilterOptions);
  const [useStatementMonth, setUseStatementMonth] = useState(false);
  const [statementCycleDay, setStatementCycleDay] = useState(15); // Default to 15th

  // Reset filters when transactions load
  useEffect(() => {
    if (!isLoading && transactions.length > 0) {
      setFilterOptions(initialFilterOptions);
    }
  }, [isLoading, transactions.length]);

  const handleFilterChange = (key: keyof FilterOptions, value: string) => {
    setFilterOptions(prev => ({ ...prev, [key]: value }));
  };

  const resetFilters = () => {
    setFilterOptions(initialFilterOptions);
    setSearchQuery('');
    setUseStatementMonth(false);
  };

  // Get active filters for displaying in UI
  const activeFilters = useMemo(() => {
    const filters: string[] = [];

    if (searchQuery) {
      filters.push(`Search: ${searchQuery}`);
    }

    if (filterOptions.merchantName) {
      filters.push(`Merchant: ${filterOptions.merchantName}`);
    }

    if (filterOptions.paymentMethodId && filterOptions.paymentMethodId !== 'all') {
      const method = transactions.find(t => t.paymentMethod.id === filterOptions.paymentMethodId)?.paymentMethod.name;
      if (method) filters.push(`Payment Method: ${method}`);
    }

    if (filterOptions.currency && filterOptions.currency !== 'all') {
      filters.push(`Currency: ${filterOptions.currency}`);
    }

    if (filterOptions.startDate) {
      filters.push(`From: ${filterOptions.startDate}`);
    }

    if (filterOptions.endDate) {
      filters.push(`To: ${filterOptions.endDate}`);
    }

    if (useStatementMonth) {
      filters.push(`Statement Cycle: Day ${statementCycleDay}`);
    }

    return filters;
  }, [filterOptions, searchQuery, transactions, useStatementMonth, statementCycleDay]);

  // Calculate statement period dates
  const statementPeriod = useMemo(() => {
    if (!useStatementMonth) return null;
    
    // Create a pseudo payment method with statement settings
    const pseudoMethod = {
      statementStartDay: statementCycleDay,
      isMonthlyStatement: true
    };
    
    return getStatementPeriod(pseudoMethod as any);
  }, [useStatementMonth, statementCycleDay]);

  // Apply filters and sort
  const filteredTransactions = useMemo(() => {
    if (isLoading) return [];

    // Debug log to check currencies
    console.log('Available currencies in transactions:', 
      [...new Set(transactions.map(tx => tx.currency))]);

    // Filter by search query
    let filtered = transactions;
    
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(tx => 
        tx.merchant.name.toLowerCase().includes(query) ||
        (tx.notes && tx.notes.toLowerCase().includes(query))
      );
    }
    
    // Apply filters
    if (filterOptions.merchantName) {
      const merchantQuery = filterOptions.merchantName.toLowerCase();
      filtered = filtered.filter(tx => 
        tx.merchant.name.toLowerCase().includes(merchantQuery)
      );
    }
    
    if (filterOptions.paymentMethodId && filterOptions.paymentMethodId !== 'all') {
      filtered = filtered.filter(tx => 
        tx.paymentMethod.id === filterOptions.paymentMethodId
      );
    }
    
    if (filterOptions.currency && filterOptions.currency !== 'all') {
      filtered = filtered.filter(tx => 
        tx.currency === filterOptions.currency
      );
    }
    
    if (filterOptions.startDate) {
      const startDate = new Date(filterOptions.startDate);
      startDate.setHours(0, 0, 0, 0);
      filtered = filtered.filter(tx => {
        const txDate = new Date(tx.date);
        return txDate >= startDate;
      });
    }
    
    if (filterOptions.endDate) {
      const endDate = new Date(filterOptions.endDate);
      endDate.setHours(23, 59, 59, 999);
      filtered = filtered.filter(tx => {
        const txDate = new Date(tx.date);
        return txDate <= endDate;
      });
    }
    
    // Apply statement cycle filter
    if (useStatementMonth && statementPeriod) {
      filtered = filtered.filter(tx => {
        const txDate = new Date(tx.date);
        return txDate >= statementPeriod.start && txDate <= statementPeriod.end;
      });
      
      console.log(`Statement period: ${statementPeriod.start.toISOString()} to ${statementPeriod.end.toISOString()}`);
      console.log(`Filtered to ${filtered.length} transactions in statement period`);
    }
    
    // Apply sorting
    return [...filtered].sort((a, b) => {
      if (sortOption === 'date-desc') {
        return new Date(b.date).getTime() - new Date(a.date).getTime();
      } else if (sortOption === 'date-asc') {
        return new Date(a.date).getTime() - new Date(b.date).getTime();
      } else if (sortOption === 'amount-desc') {
        return b.amount - a.amount;
      } else {
        return a.amount - b.amount;
      }
    });
  }, [isLoading, transactions, searchQuery, filterOptions, sortOption, useStatementMonth, statementPeriod]);

  return {
    filteredTransactions,
    sortOption,
    setSortOption,
    searchQuery,
    setSearchQuery,
    filterOptions,
    handleFilterChange,
    activeFilters,
    resetFilters,
    useStatementMonth,
    setUseStatementMonth,
    statementCycleDay,
    setStatementCycleDay
  };
};

================
File: hooks/use-debounce.ts
================
import { useState, useEffect } from 'react';

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

================
File: hooks/use-mobile.tsx
================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}

================
File: hooks/use-toast.ts
================
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

================
File: hooks/useCardAnalytics.ts
================
import { useState, useEffect } from 'react';
import { PaymentMethod, Transaction } from '@/types';
import { getTransactions } from '@/utils/storageUtils';

export const useCardAnalytics = (selectedPaymentMethod: PaymentMethod | undefined) => {
  // State for transactions
  const [transactions, setTransactions] = useState<Transaction[]>([]);
  
  // State for UOB Visa Signature calculation
  const [nonSgdSpendTotal, setNonSgdSpendTotal] = useState<number>(0);
  const [hasSgdTransactions, setHasSgdTransactions] = useState<boolean>(false);
  
  // State for bonus points tracking
  const [usedBonusPoints, setUsedBonusPoints] = useState<number>(0);
  
  // Load transactions
  useEffect(() => {
    const loadTransactions = async () => {
      try {
        const allTransactions = await getTransactions();
        setTransactions(allTransactions);
      } catch (error) {
        console.error('Error loading transactions:', error);
        setTransactions([]);
      }
    };
    
    loadTransactions();
  }, []);

  // Calculate card-specific metrics based on transactions
  useEffect(() => {
    if (!selectedPaymentMethod) return;
    
    // Calculate for UOB Visa Signature
    if (selectedPaymentMethod?.issuer === 'UOB' && selectedPaymentMethod?.name === 'Visa Signature' && transactions.length > 0) {
      let statementTotal = 0;
      let hasAnySgdTransaction = false;
      
      const statementTransactions = transactions.filter(tx => 
        tx.paymentMethod.id === selectedPaymentMethod.id
      );
      
      statementTransactions.forEach(tx => {
        if (tx.currency === 'SGD') {
          hasAnySgdTransaction = true;
        } else {
          statementTotal += tx.paymentAmount;
        }
      });
      
      setNonSgdSpendTotal(statementTotal);
      setHasSgdTransactions(hasAnySgdTransaction);
    }
    
    // Calculate bonus points used for UOB Preferred Platinum and Citibank Rewards
    if (((selectedPaymentMethod?.issuer === 'UOB' && selectedPaymentMethod?.name === 'Preferred Visa Platinum') ||
        (selectedPaymentMethod?.issuer === 'Citibank' && selectedPaymentMethod?.name === 'Rewards Visa Signature') ||
        (selectedPaymentMethod?.issuer === 'American Express')) && 
        transactions.length > 0) {
      
      const currentDate = new Date();
      let totalMonthBonusPoints = 0;
      
      const currentMonthTransactions = transactions.filter(tx => {
        const txDate = new Date(tx.date);
        return tx.paymentMethod.id === selectedPaymentMethod.id && 
               txDate.getMonth() === currentDate.getMonth() &&
               txDate.getFullYear() === currentDate.getFullYear();
      });
      
      currentMonthTransactions.forEach(tx => {
        if (tx.rewardPoints > 0) {
          // Different multipliers based on card type
          let multiplier = 1;
          let baseMultiplier = 0.4;
          
          if (selectedPaymentMethod.issuer === 'UOB') {
            multiplier = 5;
            baseMultiplier = 0.4;
          } else if (selectedPaymentMethod.issuer === 'Citibank') {
            multiplier = 1;
            baseMultiplier = 0.4;
          } else if (selectedPaymentMethod.issuer === 'American Express') {
            multiplier = 1;
            baseMultiplier = 1.25; // $1.60 = 2 points => 2/1.6 = 1.25 points per dollar
          }
          
          const txAmount = Math.floor(tx.amount / multiplier) * multiplier;
          const basePoints = Math.round(txAmount * baseMultiplier);
          const bonusPoints = Math.max(0, tx.rewardPoints - basePoints);
          totalMonthBonusPoints += bonusPoints;
        }
      });
      
      // Apply cap (if applicable)
      let cap = 4000; // Default cap for UOB and Citibank
      
      // American Express cards have no cap
      if (selectedPaymentMethod.issuer === 'American Express') {
        cap = Number.MAX_SAFE_INTEGER;
      }
      
      setUsedBonusPoints(Math.min(totalMonthBonusPoints, cap));
    }
  }, [selectedPaymentMethod, transactions]);

  return {
    nonSgdSpendTotal,
    hasSgdTransactions,
    usedBonusPoints
  };
};

================
File: hooks/useChartData.ts
================
// src/hooks/useChartData.ts
import { useMemo } from 'react';
import { Transaction, Currency, PaymentMethod } from '@/types';
import { 
  processPieChartData, 
  processTransactionsForChart, 
  ChartProcessingResult
} from '@/utils/chartDataProcessor';
import { ChartDataItem } from '@/types/dashboard';

/**
 * Hook for generating pie chart data from transactions
 * 
 * @param transactions - Array of transactions to visualize
 * @param groupByField - Field to group by (e.g., 'paymentMethod', 'category')
 * @param displayCurrency - Currency to display values in
 * @returns Array of formatted chart data items
 */
export function usePieChartData(
  transactions: Transaction[],
  groupByField: 'paymentMethod' | 'category' | string,
  displayCurrency: Currency
): ChartDataItem[] {
  return useMemo(() => {
    return processPieChartData(
      transactions,
      groupByField,
      displayCurrency
    );
  }, [transactions, groupByField, displayCurrency]);
}

/**
 * Hook for generating spending trend data
 * 
 * @param transactions - Transactions to analyze
 * @param period - Time period for grouping (week, month, quarter, year)
 * @param options - Additional chart processing options
 * @returns Processed chart data with trends and insights
 */
export function useSpendingTrendData(
  transactions: Transaction[],
  period: 'day' | 'week' | 'month' | 'quarter' = 'month',
  options: { 
    includeCategoryBreakdown?: boolean;
    maxTopCategories?: number;
    displayCurrency?: Currency; 
  } = {}
): ChartProcessingResult {
  // Extract options with defaults to use as direct dependencies
  const includeCategoryBreakdown = options.includeCategoryBreakdown ?? true;
  const maxTopCategories = options.maxTopCategories ?? 3;
  const displayCurrency = options.displayCurrency ?? 'SGD';
  
  return useMemo(() => {
    return processTransactionsForChart(transactions, {
      period,
      includeCategoryBreakdown,
      maxTopCategories,
      includeTrend: true,
      displayCurrency
    });
  }, [
    transactions, 
    period, 
    includeCategoryBreakdown, 
    maxTopCategories, 
    displayCurrency
  ]);
}

/**
 * Interface for card optimization suggestions
 */
export interface CardSuggestion {
  /** Category name where optimization is possible */
  category: string;
  /** Number of transactions in this category */
  transactionCount: number;
  /** Currently used payment method */
  currentMethod: string;
  /** Recommended payment method for better rewards */
  suggestedMethod: string;
  /** Estimated monthly savings/additional rewards when using suggested method */
  potentialSavings: number;
}

// Constants for optimization calculations
const MINIMUM_TRANSACTIONS_PER_CATEGORY = 3;
const DEFAULT_REWARD_RATE = 1; // Assume standard 1x points for baseline comparison
const SAVINGS_MULTIPLIER = 0.01; // Convert percentage to decimal (1% = 0.01)

/**
 * Hook for generating payment method optimization recommendations
 * Analyzes transaction patterns and suggests better card choices per category
 * Optimized for performance with large datasets
 * 
 * @param transactions - Array of transactions to analyze
 * @param paymentMethods - Available payment methods to consider
 * @returns Array of card optimization suggestions
 */
export function usePaymentMethodOptimization(
  transactions: Transaction[],
  paymentMethods: PaymentMethod[]
): CardSuggestion[] {
  return useMemo(() => {
    // Skip processing if there's insufficient data (early return)
    if (transactions.length === 0 || paymentMethods.length < 2) {
      return [];
    }

    // Pre-processing: Cache active payment methods to avoid repeated checks
    const activePaymentMethods = paymentMethods.filter(method => method.active);
    if (activePaymentMethods.length < 2) return []; // Need at least 2 active methods
    
    // Pre-compute payment method reward rules for faster lookup
    const methodRewardMap = new Map<string, {
      methodName: string;
      categoryRules: Map<string, number>;
      defaultRate: number;
    }>();
    
    // Pre-process payment methods and their rules for faster lookups
    activePaymentMethods.forEach(method => {
      const categoryRules = new Map<string, number>();
      let defaultRate = DEFAULT_REWARD_RATE; // Default if no rules found
      
      method.rewardRules.forEach(rule => {
        if (rule.type === 'mcc' || rule.type === 'merchant') {
          // Category-specific rules
          const conditions = Array.isArray(rule.condition) 
            ? rule.condition 
            : [rule.condition];
          
          // Store lowercase conditions for case-insensitive matching
          conditions.forEach(cond => {
            if (typeof cond === 'string') {
              const condLower = cond.toLowerCase();
              categoryRules.set(condLower, Math.max(
                categoryRules.get(condLower) || 0, 
                rule.pointsMultiplier
              ));
            }
          });
        } else if (rule.type === 'generic' || rule.type === 'currency' || !rule.type) {
          // Default/base/generic reward rule
          defaultRate = rule.pointsMultiplier;
        }
      });
      
      methodRewardMap.set(method.name, {
        methodName: method.name,
        categoryRules,
        defaultRate
      });
    });
    
    // Optimized data structures for category analysis (single pass)
    type CategoryData = {
      transactions: number;
      amount: number;
      methods: Map<string, { count: number; amount: number }>;
      lowerCaseName: string;
    };
    
    const categoryDataMap = new Map<string, CategoryData>();
    
    // Process all transactions in a single pass
    transactions.forEach(tx => {
      const category = tx.category || 'Uncategorized';
      const methodName = tx.paymentMethod?.name || 'Unknown';
      const amount = tx.amount;
      
      // Get or create category data
      let catData = categoryDataMap.get(category);
      if (!catData) {
        catData = {
          transactions: 0,
          amount: 0,
          methods: new Map(),
          lowerCaseName: category.toLowerCase()
        };
        categoryDataMap.set(category, catData);
      }
      
      // Update category totals
      catData.transactions++;
      catData.amount += amount;
      
      // Update method usage within category
      let methodData = catData.methods.get(methodName);
      if (!methodData) {
        methodData = { count: 0, amount: 0 };
        catData.methods.set(methodName, methodData);
      }
      methodData.count++;
      methodData.amount += amount;
    });
    
    // Process categories to find optimization opportunities (single pass)
    const results: CardSuggestion[] = [];
    
    categoryDataMap.forEach((catData, category) => {
      // Skip categories with too few transactions
      if (catData.transactions < MINIMUM_TRANSACTIONS_PER_CATEGORY) return;
      
      // Find predominant payment method for this category
      let currentMethod = '';
      let currentMethodCount = 0;
      let currentMethodAmount = 0;
      
      catData.methods.forEach((data, method) => {
        if (data.count > currentMethodCount) {
          currentMethod = method;
          currentMethodCount = data.count;
          currentMethodAmount = data.amount;
        }
      });
      
      if (!currentMethod) return; // Skip if no method found
      
      // Find the best rewards card for this category
      let bestMethod = currentMethod;
      let bestReward = DEFAULT_REWARD_RATE; // Start with assumption of 1x for current
      
      // Get the current method's reward info if available
      const currentMethodInfo = methodRewardMap.get(currentMethod);
      if (currentMethodInfo) {
        bestReward = currentMethodInfo.defaultRate;
      }
      
      // Check each payment method for better rewards
      methodRewardMap.forEach((methodInfo, methodName) => {
        if (methodName === currentMethod) return; // Skip current method
        
        // Start with default rate
        let potentialReward = methodInfo.defaultRate;
        
        // Check for category-specific rules that might apply
        // Use the pre-computed category rules for faster lookup
        const categoryLower = catData.lowerCaseName;
        
        // Check exact category match first (most efficient)
        if (methodInfo.categoryRules.has(categoryLower)) {
          potentialReward = Math.max(potentialReward, methodInfo.categoryRules.get(categoryLower)!);
        } else {
          // Check partial matches if no exact match found
          methodInfo.categoryRules.forEach((rate, ruleCat) => {
            if (categoryLower.includes(ruleCat) || ruleCat.includes(categoryLower)) {
              potentialReward = Math.max(potentialReward, rate);
            }
          });
        }
        
        // Update best method if we found a better one
        if (potentialReward > bestReward) {
          bestReward = potentialReward;
          bestMethod = methodName;
        }
      });
      
      // If we found a better method, add it to suggestions
      if (bestMethod !== currentMethod) {
        // Get current method's reward rate
        const currentReward = currentMethodInfo?.defaultRate || DEFAULT_REWARD_RATE;
        const potentialSavings = currentMethodAmount * (bestReward - currentReward) * SAVINGS_MULTIPLIER;
        
        // Only add suggestions with meaningful savings
        if (potentialSavings > 0) {
          results.push({
            category,
            transactionCount: currentMethodCount,
            currentMethod,
            suggestedMethod: bestMethod,
            potentialSavings
          });
        }
      }
    });
    
    // Sort by potential savings (highest first)
    return results.sort((a, b) => b.potentialSavings - a.potentialSavings);
  }, [transactions, paymentMethods]);
}

/**
 * Interface for category savings potential
 */
export interface CategorySavingsPotential {
  /** Category name */
  category: string;
  /** Total spending amount in this category */
  amount: number;
  /** Estimated potential savings amount */
  savingsPotential: number;
  /** Whether this is considered discretionary (non-essential) spending */
  discretionary: boolean;
}

/**
 * Interface for the complete savings analysis result
 */
export interface SavingsAnalysis {
  /** Total spending across all categories */
  totalSpending: number;
  /** Total discretionary (non-essential) spending */
  discretionarySpending: number;
  /** Target savings amount based on goal percentage */
  savingsTarget: number;
  /** Total potential savings amount across all categories */
  savingsPotential: number;
  /** Top discretionary categories with savings opportunities */
  topDiscretionaryCategories: CategorySavingsPotential[];
  /** Progress toward savings goal (as percentage) */
  savingsProgress: number;
}

// Define discretionary spending categories once instead of in every render
const DISCRETIONARY_CATEGORIES = new Set([
  'entertainment', 'dining', 'shopping', 'leisure',
  'subscriptions', 'travel', 'hobbies', 'gifts',
  'alcohol', 'coffee', 'electronics', 'clothing',
  'beauty', 'fast food', 'food & drinks', 'food and drinks',
  'home & entertainment', 'restaurants'
].map(cat => cat.toLowerCase()));

// Constants for savings calculations to avoid magic numbers
const DISCRETIONARY_SAVINGS_RATE = 0.3; // 30% potential savings on discretionary spending
const ESSENTIAL_SAVINGS_RATE = 0.05;    // 5% potential savings on essential spending
const TOP_CATEGORIES_COUNT = 3;         // Number of top categories to return

/**
 * Hook for analyzing spending patterns to identify savings opportunities
 * Optimized for performance with large datasets
 * 
 * @param transactions - Transactions to analyze
 * @param savingsGoalPercentage - Target percentage of total spending to save
 * @returns Detailed savings analysis
 */
export function useSavingsPotential(
  transactions: Transaction[],
  savingsGoalPercentage: number = 20
): SavingsAnalysis {
  return useMemo(() => {
    // Early return for empty data to avoid unnecessary processing
    if (!transactions || transactions.length === 0) {
      return {
        totalSpending: 0,
        discretionarySpending: 0,
        savingsTarget: 0,
        savingsPotential: 0,
        topDiscretionaryCategories: [],
        savingsProgress: 0
      };
    }
    
    let totalSpending = 0;
    let discretionarySpending = 0;
    let totalSavingsPotential = 0;
    
    // Category data storage with category name as key for faster lookups
    const categoryData = new Map<string, CategorySavingsPotential>();
    
    // Single pass algorithm - process all transactions in one loop
    // This combines the three separate loops in the original implementation
    transactions.forEach(tx => {
      const amount = tx.amount;
      const category = tx.category || 'Uncategorized';
      const categoryLower = category.toLowerCase();
      
      // Add to total spending (replaces the first reduce)
      totalSpending += amount;
      
      // Get or create category data entry
      let catData = categoryData.get(category);
      if (!catData) {
        // Check if this is a discretionary category (case-insensitive)
        // Using the Set for O(1) lookups instead of array iteration
        const isDiscretionary = DISCRETIONARY_CATEGORIES.has(categoryLower) ||
          Array.from(DISCRETIONARY_CATEGORIES).some(c => 
            categoryLower.includes(c) || c.includes(categoryLower)
          );
        
        catData = {
          category,
          amount: 0,
          discretionary: isDiscretionary,
          savingsPotential: 0
        };
        categoryData.set(category, catData);
      }
      
      // Update category amount
      catData.amount += amount;
      
      // Recalculate savings potential for this category
      const savingsRate = catData.discretionary ? DISCRETIONARY_SAVINGS_RATE : ESSENTIAL_SAVINGS_RATE;
      catData.savingsPotential = catData.amount * savingsRate;
      
      // Update discretionary spending total
      if (catData.discretionary) {
        discretionarySpending += amount;
      }
      
      // Update total savings potential
      totalSavingsPotential = 0; // Will recalculate below
    });
    
    // Calculate total savings potential from all categories
    categoryData.forEach(cat => {
      totalSavingsPotential += cat.savingsPotential;
    });
    
    // Calculate savings target based on goal percentage
    const savingsTarget = totalSpending * (savingsGoalPercentage / 100);
    
    // Calculate savings progress as percentage of target (capped at 100%)
    const savingsProgress = Math.min(
      100, 
      totalSavingsPotential > 0 && savingsTarget > 0 ? 
        (totalSavingsPotential / savingsTarget) * 100 : 0
    );
    
    // Find top discretionary categories more efficiently
    // Instead of filtering and sorting the entire array, we maintain a top N list
    const topCategories: CategorySavingsPotential[] = [];
    
    categoryData.forEach(catData => {
      if (!catData.discretionary) return; // Skip non-discretionary categories
      
      // Special case for first few items to avoid unnecessary comparisons
      if (topCategories.length < TOP_CATEGORIES_COUNT) {
        topCategories.push(catData);
        // Sort after pushing to maintain descending order by savingsPotential
        topCategories.sort((a, b) => b.savingsPotential - a.savingsPotential);
        return;
      }
      
      // Check if this category should replace the lowest in the top list
      const lowestTopIndex = topCategories.length - 1;
      if (catData.savingsPotential > topCategories[lowestTopIndex].savingsPotential) {
        // Replace the lowest entry and resort
        topCategories[lowestTopIndex] = catData;
        topCategories.sort((a, b) => b.savingsPotential - a.savingsPotential);
      }
    });
    
    return {
      totalSpending,
      discretionarySpending,
      savingsTarget,
      savingsPotential: totalSavingsPotential,
      topDiscretionaryCategories: topCategories,
      savingsProgress
    };
  }, [transactions, savingsGoalPercentage]);
}

================
File: hooks/useCurrencyFormatter.ts
================
// src/hooks/useCurrencyFormatter.ts
import { useMemo, useCallback } from "react";
import { Currency } from "@/types";
import { CurrencyService } from "@/services/CurrencyService";

/**
 * Custom hook that provides memoized currency formatting functions
 * to prevent unnecessary re-renders and duplicate log messages
 */
export function useCurrencyFormatter(defaultCurrency: Currency = "SGD") {
  // Create memoized formatter function that maintains referential equality
  const formatCurrency = useCallback(
    (amount: number, currency: Currency = defaultCurrency): string => {
      return CurrencyService.format(amount, currency);
    },
    [defaultCurrency]
  );

  // Create formatter cache for repeated values in a single render cycle
  const cachedFormatters = useMemo(() => {
    const cache = new Map<string, string>();

    return {
      format: (
        amount: number,
        currency: Currency = defaultCurrency
      ): string => {
        const key = `${amount}-${currency}`;
        if (!cache.has(key)) {
          cache.set(key, CurrencyService.format(amount, currency));
        }
        return cache.get(key)!;
      },

      // Clear cache when currency changes
      clear: () => cache.clear(),
    };
  }, [defaultCurrency]);

  return {
    formatCurrency,
    cachedFormat: cachedFormatters.format,
    clearCache: cachedFormatters.clear,
  };
}

/**
 * Hook specifically designed for chart components that need
 * to format multiple currency values efficiently
 */
export function useChartCurrencyFormatter(currency: Currency = "SGD") {
  // Create tooltip formatter function for recharts
  const tooltipFormatter = useCallback(
    (value: number, name: string) => {
      return [CurrencyService.format(value, currency), name];
    },
    [currency]
  );

  // Create axis formatter function for recharts
  const axisFormatter = useCallback(
    (value: number) => {
      return CurrencyService.format(value, currency);
    },
    [currency]
  );

  return {
    tooltipFormatter,
    axisFormatter,
    currency,
  };
}

================
File: hooks/useDashboard.ts
================
// hooks/useDashboard.ts
import { useState, useMemo, useEffect } from "react";
import { Transaction, Currency } from "@/types";
import { DashboardData, DashboardOptions } from "@/types/dashboard";
import { useTransactionsQuery } from "@/hooks/queries/useTransactionsQuery";
import { usePaymentMethodsQuery } from "@/hooks/queries/usePaymentMethodsQuery";
import { useFilteredTransactions } from "@/hooks/useFilteredTransactions";
import { useDashboardMetrics } from "@/hooks/useDashboardMetrics";
import { supabase } from "@/integrations/supabase/client";
import { TimeframeTab } from "@/utils/transactionProcessor";
import { useQueryClient } from "@tanstack/react-query";

export function useDashboard(options: {
  defaultTimeframe?: TimeframeTab;
  defaultCurrency?: Currency;
  defaultUseStatementMonth?: boolean;
  defaultStatementCycleDay?: number;
}) {
  const {
    defaultTimeframe = "thisMonth",
    defaultCurrency = "SGD",
    defaultUseStatementMonth = false,
    defaultStatementCycleDay = 15,
  } = options;

  // State for filters
  const [activeTab, setActiveTab] = useState<TimeframeTab>(defaultTimeframe);
  const [displayCurrency, setDisplayCurrency] = useState<Currency>(defaultCurrency);
  const [useStatementMonth, setUseStatementMonth] = useState<boolean>(defaultUseStatementMonth);
  const [statementCycleDay, setStatementCycleDay] = useState<number>(defaultStatementCycleDay);
  const [lastUpdate, setLastUpdate] = useState<number>(Date.now());

  // React Query client for cache invalidation
  const queryClient = useQueryClient();

  // Data queries
  const {
    data: transactions = [],
    isLoading: isTransactionsLoading,
    error: transactionsError,
    refetch: refetchTransactions,
  } = useTransactionsQuery();

  const {
    data: paymentMethods = [],
    isLoading: isPaymentMethodsLoading,
    error: paymentMethodsError,
  } = usePaymentMethodsQuery();

  // Get filtered transactions based on current filters
  const { 
    filteredTransactions,
    previousPeriodTransactions
  } = useFilteredTransactions(
    transactions,
    activeTab,
    useStatementMonth,
    statementCycleDay,
    lastUpdate
  );

  // Calculate dashboard metrics
  const { 
    dashboardData,
    isLoading: isMetricsLoading,
    error: metricsError
  } = useDashboardMetrics({
    filteredTransactions,
    previousPeriodTransactions,
    displayCurrency,
    calculateDayOfWeekMetrics: transactions.length > 0,
  });

  // Combined loading and error states
  const isLoading = isTransactionsLoading || isPaymentMethodsLoading || isMetricsLoading;
  const error = transactionsError || paymentMethodsError || metricsError
    ? "Failed to load dashboard data"
    : null;

  // Refresh function
  const refreshData = async (): Promise<void> => {
    try {
      await refetchTransactions();
      setLastUpdate(Date.now());
    } catch (error) {
      console.error("Error refreshing data:", error);
    }
  };

  // Set up Supabase realtime subscription for data updates
  useEffect(() => {
    const channel = supabase
      .channel("dashboard_transactions")
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "transactions",
        },
        () => {
          // Invalidate the transactions query to trigger refetch
          queryClient.invalidateQueries({ queryKey: ["transactions"] });
          setLastUpdate(Date.now());
        }
      )
      .subscribe();

    // Cleanup: unsubscribe on component unmount
    return () => {
      supabase.removeChannel(channel);
    };
  }, [queryClient]);

  return {
    // Data
    transactions,
    paymentMethods,
    dashboardData,
    
    // Status
    isLoading,
    error,
    lastUpdate,

    // Filter state
    activeTab,
    displayCurrency,
    useStatementMonth,
    statementCycleDay,
    
    // Actions
    refreshData,
    setActiveTab,
    setDisplayCurrency,
    setUseStatementMonth,
    setStatementCycleDay,
  };
}

================
File: hooks/useDashboardMetrics.ts
================
// hooks/useDashboardMetrics.ts
import { useMemo } from "react";
import { Transaction, Currency } from "@/types";
import { DashboardData } from "@/types/dashboard";
import { 
  calculateTotalExpenses,
  calculateTotalReimbursed,
  calculatePercentageChange,
  calculateAverageAmount,
  calculateTotalRewardPoints,
  calculateAverageByDayOfWeek
} from "@/utils/dashboardUtils";
import { 
  generatePaymentMethodChartData, 
  generateCategoryChartData 
} from "@/utils/dashboardCalculations";

interface UseDashboardMetricsOptions {
  filteredTransactions: Transaction[];
  previousPeriodTransactions: Transaction[];
  displayCurrency: Currency;
  calculateDayOfWeekMetrics?: boolean;
}

export function useDashboardMetrics(options: UseDashboardMetricsOptions) {
  const {
    filteredTransactions,
    previousPeriodTransactions,
    displayCurrency,
    calculateDayOfWeekMetrics = false
  } = options;

  // Generate dashboard data from filtered transactions
  const dashboardData = useMemo(() => {
    try {
      if (filteredTransactions.length === 0) {
        return {
          filteredTransactions: [],
          metrics: {
            totalExpenses: 0,
            transactionCount: 0,
            averageAmount: 0,
            totalRewardPoints: 0,
            percentageChange: 0,
            totalReimbursed: 0,
            netExpenses: 0,
          },
          top: {},
          charts: {
            paymentMethods: [],
            categories: [],
            dayOfWeekSpending: {},
            spendingTrends: { 
              labels: [], 
              datasets: [{ 
                label: "Expenses",
                data: [],
                backgroundColor: "#8884d8"
              }] 
            },
          }
        } as DashboardData;
      }

      // Calculate metrics
      const totalExpenses = calculateTotalExpenses(
        filteredTransactions,
        displayCurrency
      );

      // Calculate total reimbursed amount
      const totalReimbursed = calculateTotalReimbursed(
        filteredTransactions,
        displayCurrency
      );

      // Calculate previous period expenses for comparison
      const previousPeriodExpenses = calculateTotalExpenses(
        previousPeriodTransactions,
        displayCurrency
      );

      // Calculate previous period reimbursements
      const previousPeriodReimbursed = calculateTotalReimbursed(
        previousPeriodTransactions,
        displayCurrency
      );
      
      // Calculate net expenses for both periods
      const netExpenses = totalExpenses - totalReimbursed;
      const previousNetExpenses = previousPeriodExpenses - previousPeriodReimbursed;
      
      // Calculate percentage change from previous period based on net expenses
      const percentageChange = calculatePercentageChange(
        netExpenses,
        previousNetExpenses
      );

      // Calculate average transaction amount
      const averageAmount = calculateAverageAmount(
        filteredTransactions,
        displayCurrency
      );

      // Calculate total reward points earned
      const totalRewardPoints = calculateTotalRewardPoints(filteredTransactions);

      // Generate chart data
      const paymentMethodsChart = generatePaymentMethodChartData(
        filteredTransactions,
        displayCurrency,
        true // Account for reimbursements
      );

      const categoriesChart = generateCategoryChartData(
        filteredTransactions,
        displayCurrency,
        true // Account for reimbursements
      );

      // Calculate day of week spending if enabled
      const dayOfWeekSpending = calculateDayOfWeekMetrics 
        ? calculateAverageByDayOfWeek(filteredTransactions, displayCurrency)
        : {};

      // Get top values
      const topPaymentMethod = paymentMethodsChart.length > 0 
        ? { name: paymentMethodsChart[0].name, value: paymentMethodsChart[0].value } 
        : undefined;

      const topCategory = categoriesChart.length > 0 
        ? { name: categoriesChart[0].name, value: categoriesChart[0].value } 
        : undefined;

      return {
        filteredTransactions,
        metrics: {
          totalExpenses,
          totalReimbursed,
          transactionCount: filteredTransactions.length,
          averageAmount,
          totalRewardPoints,
          percentageChange,
          netExpenses,
        },
        top: {
          paymentMethod: topPaymentMethod,
          category: topCategory,
        },
        charts: {
          paymentMethods: paymentMethodsChart,
          categories: categoriesChart,
          dayOfWeekSpending,
          spendingTrends: { 
            labels: [], 
            datasets: [{ 
              label: "Expenses",
              data: [],
              backgroundColor: "#8884d8"
            }] 
          },
        }
      } as DashboardData;
    } catch (error) {
      console.error("Error generating dashboard data:", error);
      return null;
    }
  }, [filteredTransactions, previousPeriodTransactions, displayCurrency, calculateDayOfWeekMetrics]);

  return {
    dashboardData,
    isLoading: false,
    error: dashboardData ? null : "Failed to calculate dashboard metrics"
  };
}

================
File: hooks/useExpenseForm.ts
================
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { PaymentMethod } from '@/types';
import { useToast } from '@/hooks/use-toast';
import { FormValues, formSchema } from './expense-form/formSchema';
import { useMerchantData } from './expense-form/useMerchantData';
import { usePaymentMethodLogic } from './expense-form/usePaymentMethodLogic';
import { useRewardPointsStandalone } from './expense-form/useRewardPointsStandalone';
import { useState, useEffect } from 'react';

interface UseExpenseFormProps {
  paymentMethods: PaymentMethod[];
  defaultValues?: Partial<FormValues>;
}

// Change regular export to type export
export type { FormValues } from './expense-form/formSchema';

export const useExpenseForm = ({ paymentMethods, defaultValues }: UseExpenseFormProps) => {
  const { toast } = useToast();
  const [estimatedPoints, setEstimatedPoints] = useState<number | {
    totalPoints: number;
    basePoints?: number;
    bonusPoints?: number;
    remainingMonthlyBonusPoints?: number;
    pointsCurrency?: string;
    messageText?: string;
  }>(0);
  
  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      merchantName: defaultValues?.merchantName || '',
      merchantAddress: defaultValues?.merchantAddress || '',
      isOnline: defaultValues?.isOnline ?? false,
      isContactless: defaultValues?.isContactless ?? false,
      amount: defaultValues?.amount || '',
      currency: defaultValues?.currency || 'SGD',
      paymentMethodId: defaultValues?.paymentMethodId || '',
      paymentAmount: defaultValues?.paymentAmount || '',
      date: defaultValues?.date || new Date(),
      notes: defaultValues?.notes || '',
    },
  });
  
  const merchantName = form.watch('merchantName');
  const currency = form.watch('currency') as any;
  const amount = Number(form.watch('amount')) || 0;
  const paymentAmount = Number(form.watch('paymentAmount')) || 0;
  const isOnline = form.watch('isOnline');
  const isContactless = form.watch('isContactless');
  const paymentMethodId = form.watch('paymentMethodId');
  
  const { selectedMCC, setSelectedMCC } = useMerchantData(form, merchantName);
  
  const { selectedPaymentMethod, shouldOverridePayment } = usePaymentMethodLogic(
    form,
    paymentMethods,
    currency,
    amount,
    isOnline
  );
  
  // Use the standalone simulatePoints from our hook - passing the full array of paymentMethods
  const { estimatedPoints: calculatedPoints } = useRewardPointsStandalone(
    shouldOverridePayment ? paymentAmount : amount,
    paymentMethodId,
    paymentMethods,
    selectedMCC?.code,
    merchantName,
    isOnline,
    isContactless
  );
  
  // Update the local state when the calculated points change
  useEffect(() => {
    setEstimatedPoints(calculatedPoints);
  }, [calculatedPoints]);

  return {
    form,
    selectedMCC,
    setSelectedMCC,
    selectedPaymentMethod,
    shouldOverridePayment,
    estimatedPoints,
  };
};

================
File: hooks/useFilteredTransactions.ts
================
// hooks/useFilteredTransactions.ts
import { useMemo } from "react";
import { Transaction } from "@/types";
import { TimeframeTab, filterTransactionsByTimeframe } from "@/utils/transactionProcessor";
import { getPreviousTimeframe } from "@/utils/dashboardUtils";

export function useFilteredTransactions(
  transactions: Transaction[],
  timeframe: TimeframeTab,
  useStatementMonth: boolean,
  statementCycleDay: number,
  lastUpdate?: number // Optional dependency to force recalculation
) {
  // Get filtered transactions for current timeframe
  const filteredTransactions = useMemo(() => {
    return filterTransactionsByTimeframe(
      transactions,
      timeframe,
      useStatementMonth,
      statementCycleDay
    );
  }, [
    transactions, 
    timeframe, 
    useStatementMonth, 
    statementCycleDay,
    lastUpdate // Include lastUpdate to force recalculation when data is refreshed
  ]);
  
  // Get filtered transactions for previous timeframe (for comparison)
  const previousPeriodTransactions = useMemo(() => {
    // Get the appropriate previous timeframe for comparison
    const previousTimeframe = getPreviousTimeframe(timeframe);
    
    return filterTransactionsByTimeframe(
      transactions,
      previousTimeframe,
      useStatementMonth,
      statementCycleDay
    );
  }, [
    transactions, 
    timeframe, 
    useStatementMonth, 
    statementCycleDay
  ]);

  return {
    filteredTransactions,
    previousPeriodTransactions
  };
}

================
File: hooks/useMediaQuery.ts
================
// src/hooks/useMediaQuery.ts
import { useState, useEffect } from 'react';

/**
 * Custom hook that returns whether the given media query matches
 * 
 * @param query The media query to check
 * @returns boolean indicating if the media query matches
 */
export function useMediaQuery(query: string): boolean {
  // Initialize with the current match state if window exists
  const getMatches = (): boolean => {
    // Check if window is defined (to avoid SSR issues)
    if (typeof window !== 'undefined') {
      return window.matchMedia(query).matches;
    }
    return false;
  };

  const [matches, setMatches] = useState<boolean>(getMatches);

  useEffect(() => {
    // Define a function to handle changes to the media query
    const handleChange = () => setMatches(getMatches());
    
    // Create a media query list object
    const mediaQueryList = window.matchMedia(query);
    
    // Add the listener initially
    handleChange();
    
    // Add event listener for changes
    // Use the appropriate event listener based on browser support
    if (mediaQueryList.addEventListener) {
      mediaQueryList.addEventListener('change', handleChange);
    } else {
      // Fallback for older browsers
      mediaQueryList.addListener(handleChange);
    }
    
    // Clean up
    return () => {
      if (mediaQueryList.removeEventListener) {
        mediaQueryList.removeEventListener('change', handleChange);
      } else {
        // Fallback for older browsers
        mediaQueryList.removeListener(handleChange);
      }
    };
  }, [query]);

  return matches;
}

================
File: hooks/usePaymentMethods.ts
================
import { useState, useEffect } from 'react';
import { PaymentMethod, Currency } from '@/types';
import { supabase } from '@/integrations/supabase/client';

export function usePaymentMethods() {
  const [paymentMethods, setPaymentMethods] = useState<PaymentMethod[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchPaymentMethods = async () => {
      setIsLoading(true);
      try {
        const { data, error } = await supabase
          .from('payment_methods')
          .select('*')
          .order('name');

        if (error) {
          console.error('Supabase error:', error);
          throw error;
        }

        console.log('Raw payment methods from DB:', data);
        
        if (!data || data.length === 0) {
          console.warn('No payment methods found in database');
          setPaymentMethods([]);
          return;
        }

        // Map the data to PaymentMethod objects
        const formattedMethods: PaymentMethod[] = data.map(method => {
          try {
            return {
              id: method.id,
              name: method.name,
              type: method.type as 'cash' | 'credit_card',
              currency: method.currency as Currency,
              issuer: method.issuer || undefined,
              lastFourDigits: method.last_four_digits || undefined,
              active: method.active !== false, // Default to true if null
              imageUrl: method.image_url || undefined,
              color: method.color || undefined,
              statementStartDay: method.statement_start_day || undefined,
              isMonthlyStatement: method.is_monthly_statement || false,
              selectedCategories: method.selected_categories ? 
                (typeof method.selected_categories === 'string' 
                  ? JSON.parse(method.selected_categories) 
                  : method.selected_categories) : [],
              rewardRules: [], // Empty array as placeholder
              conversionRate: method.conversion_rate ? 
                (typeof method.conversion_rate === 'string' 
                  ? JSON.parse(method.conversion_rate) 
                  : method.conversion_rate) : undefined
            };
          } catch (err) {
            console.error('Error parsing payment method:', method, err);
            // Return a basic version to prevent the entire list from failing
            return {
              id: method.id,
              name: method.name || 'Unknown Method',
              type: (method.type as 'cash' | 'credit_card') || 'cash',
              currency: (method.currency as Currency) || 'USD',
              active: true,
              rewardRules: []
            } as PaymentMethod;
          }
        });

        console.log('Formatted payment methods:', formattedMethods);
        setPaymentMethods(formattedMethods);
      } catch (err) {
        console.error('Error fetching payment methods:', err);
        setError('Failed to load payment methods');
      } finally {
        setIsLoading(false);
      }
    };

    fetchPaymentMethods();
  }, []);

  const refetch = async () => {
    try {
      setIsLoading(true);
      const { data, error } = await supabase
        .from('payment_methods')
        .select('*')
        .order('name');

      if (error) {
        throw error;
      }

      // Map the data to PaymentMethod objects
      const formattedMethods: PaymentMethod[] = data.map(method => {
        return {
          id: method.id,
          name: method.name,
          type: method.type as 'cash' | 'credit_card',
          currency: method.currency as Currency, // Cast to Currency type
          issuer: method.issuer || undefined,
          lastFourDigits: method.last_four_digits || undefined,
          active: method.active || false,
          imageUrl: method.image_url || undefined,
          color: method.color || undefined,
          statementStartDay: method.statement_start_day || undefined,
          isMonthlyStatement: method.is_monthly_statement || false,
          selectedCategories: method.selected_categories ? JSON.parse(method.selected_categories as string) : [],
          rewardRules: [], // Empty array as placeholder
          conversionRate: method.conversion_rate ? JSON.parse(method.conversion_rate as string) : undefined
        };
      });

      setPaymentMethods(formattedMethods);
    } catch (err) {
      console.error('Error refetching payment methods:', err);
      setError('Failed to refresh payment methods');
    } finally {
      setIsLoading(false);
    }
  };

  return { paymentMethods, isLoading, error, refetch };
}

================
File: hooks/useSupabaseConnectionCheck.ts
================
import { useState, useEffect } from 'react';
import { supabase, USE_LOCAL_STORAGE_DEFAULT } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';

export const useSupabaseConnectionCheck = () => {
  const [supabaseConnected, setSupabaseConnected] = useState<boolean | null>(null);
  const [useLocalStorage, setUseLocalStorage] = useState<boolean>(USE_LOCAL_STORAGE_DEFAULT);
  const { toast } = useToast();

  useEffect(() => {
    if (!USE_LOCAL_STORAGE_DEFAULT) {
      const checkSupabaseConnection = async () => {
        try {
          console.log('Checking Supabase connection...');
          const { data, error } = await supabase.from('payment_methods').select('id').limit(1);
          
          if (error) {
            console.error('Supabase connection error:', error);
            setSupabaseConnected(false);
            setUseLocalStorage(true);
            toast({
              title: 'Warning',
              description: 'Supabase connection failed. Using local storage fallback.',
              variant: 'destructive',
            });
          } else {
            console.log('Supabase connection successful');
            setSupabaseConnected(true);
            setUseLocalStorage(false);
          }
        } catch (error) {
          console.error('Error checking Supabase connection:', error);
          setSupabaseConnected(false);
          setUseLocalStorage(true);
          toast({
            title: 'Warning',
            description: 'Supabase connection failed. Using local storage fallback.',
            variant: 'destructive',
          });
        }
      };
      
      checkSupabaseConnection();
    } else {
      // Default to local storage without checking Supabase
      setSupabaseConnected(false);
      setUseLocalStorage(true);
      console.log('Using local storage by default.');
    }
  }, [toast]);

  return { supabaseConnected, useLocalStorage };
};

================
File: hooks/useTransactionActions.ts
================
import { useState } from 'react';
import { Transaction } from '@/types';
import { deleteTransaction, editTransaction } from '@/utils/storageUtils';
import { useToast } from '@/hooks/use-toast';

export const useTransactionActions = (transactions: Transaction[], setTransactions: React.Dispatch<React.SetStateAction<Transaction[]>>) => {
  const { toast } = useToast();
  const [selectedTransaction, setSelectedTransaction] = useState<Transaction | null>(null);
  const [isTransactionDialogOpen, setIsTransactionDialogOpen] = useState(false);
  const [dialogMode, setDialogMode] = useState<'view' | 'edit'>('view');
  const [deleteConfirmOpen, setDeleteConfirmOpen] = useState(false);
  const [transactionToDelete, setTransactionToDelete] = useState<Transaction | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const handleViewTransaction = (transaction: Transaction) => {
    setSelectedTransaction(transaction);
    setDialogMode('view');
    setIsTransactionDialogOpen(true);
  };
  
  const handleEditTransaction = (transaction: Transaction) => {
    setSelectedTransaction(transaction);
    setDialogMode('edit');
    setIsTransactionDialogOpen(true);
  };
  
  const handleDeleteTransaction = (transaction: Transaction) => {
    setTransactionToDelete(transaction);
    setDeleteConfirmOpen(true);
  };
  
  const confirmDeleteTransaction = async () => {
    if (!transactionToDelete) return;
    
    try {
      setIsLoading(true);
      
      // Optimistically update the UI first for better user experience
      setTransactions(prev => prev.filter(tx => tx.id !== transactionToDelete.id));
      
      const success = await deleteTransaction(transactionToDelete.id);
      
      if (success) {
        toast({
          title: "Transaction deleted",
          description: "The transaction has been successfully deleted.",
        });
      } else {
        // If there was a problem, revert the optimistic update
        toast({
          title: "Warning",
          description: "Delete operation may not have synced with remote database.",
        });
        // No need to revert transactions state since we're already assuming it was deleted locally
      }
      
      setDeleteConfirmOpen(false);
      setIsTransactionDialogOpen(false);
    } catch (error) {
      console.error('Error deleting transaction:', error);
      
      // Revert the optimistic update if there was an exception
      const originalTransaction = transactionToDelete;
      if (originalTransaction) {
        setTransactions(prev => [...prev, originalTransaction]);
      }
      
      toast({
        title: "Error",
        description: "Failed to delete the transaction. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleSaveEdit = async (updatedTransaction: Omit<Transaction, 'id'>) => {
    if (!selectedTransaction) return;
    
    try {
      setIsLoading(true);
      const result = await editTransaction(selectedTransaction.id, updatedTransaction);
      
      if (result) {
        // Update local state immediately for better UX
        setTransactions(prev => 
          prev.map(tx => tx.id === selectedTransaction.id ? result : tx)
        );
        
        toast({
          title: "Transaction updated",
          description: "The transaction has been successfully updated.",
        });
        
        setIsTransactionDialogOpen(false);
      } else {
        toast({
          title: "Error",
          description: "Failed to update the transaction.",
          variant: "destructive",
        });
      }
    } catch (error) {
      console.error('Error updating transaction:', error);
      toast({
        title: "Error",
        description: "Failed to update the transaction.",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };

  return {
    selectedTransaction,
    isTransactionDialogOpen,
    setIsTransactionDialogOpen,
    dialogMode,
    deleteConfirmOpen,
    setDeleteConfirmOpen,
    transactionToDelete,
    isLoading,
    handleViewTransaction,
    handleEditTransaction,
    handleDeleteTransaction,
    confirmDeleteTransaction,
    handleSaveEdit
  };
};

================
File: hooks/useTransactionList.ts
================
import { useTransactionData } from './transaction-list/useTransactionData';
import { useTransactionFilters } from './transaction-list/useTransactionFilters';
import { FilterOptions, SortOption } from './transaction-list/types';

export type { FilterOptions, SortOption };

export const useTransactionList = () => {
  // Get transaction data
  const { 
    transactions, 
    setTransactions, 
    paymentMethods, 
    isLoading,
    refreshTransactions
  } = useTransactionData();

  // Apply filters and sorting
  const {
    filteredTransactions,
    sortOption,
    setSortOption,
    searchQuery,
    setSearchQuery,
    filterOptions,
    handleFilterChange,
    activeFilters,
    resetFilters
  } = useTransactionFilters(transactions, isLoading);

  return {
    transactions,
    setTransactions,
    paymentMethods,
    filteredTransactions,
    sortOption,
    setSortOption,
    searchQuery,
    setSearchQuery,
    filterOptions,
    handleFilterChange,
    activeFilters,
    resetFilters,
    isLoading,
    refreshTransactions
  };
};

================
File: hooks/useTransactionSubmit.ts
================
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Transaction } from '@/types';
import { addTransaction } from '@/utils/storage/transactions';
import { useToast } from '@/hooks/use-toast';

export const useTransactionSubmit = (useLocalStorage: boolean) => {
  const [isLoading, setIsLoading] = useState(false);
  const [saveError, setSaveError] = useState<string | null>(null);
  const navigate = useNavigate();
  const { toast } = useToast();

  const handleSubmit = async (transactionData: Omit<Transaction, 'id'>) => {
    try {
      console.log('Starting transaction save process...');
      console.log('Initial transaction data:', JSON.stringify(transactionData, null, 2));
      console.log('Using local storage flag:', useLocalStorage);
      
      setSaveError(null);
      setIsLoading(true);
      
      // Validate merchant information
      if (!transactionData.merchant || !transactionData.merchant.name) {
        console.error('Merchant validation failed:', transactionData.merchant);
        throw new Error('Merchant information is missing');
      }
      
      // Validate payment method
      if (!transactionData.paymentMethod || !transactionData.paymentMethod.id) {
        console.error('Payment method validation failed:', transactionData.paymentMethod);
        throw new Error('Payment method is missing or invalid');
      }
      
      // Validate payment amount
      if (isNaN(transactionData.paymentAmount) || transactionData.paymentAmount <= 0) {
        console.error('Payment amount validation failed:', transactionData.paymentAmount);
        throw new Error('Invalid payment amount');
      }
      
      console.log('Validated transaction data:', {
        merchant: transactionData.merchant.name,
        merchantId: transactionData.merchant.id,
        amount: transactionData.amount,
        currency: transactionData.currency,
        paymentMethod: transactionData.paymentMethod.name,
        paymentMethodId: transactionData.paymentMethod.id,
        date: transactionData.date
      });
      
      // Save the transaction, with explicit useLocalStorage parameter
      const result = await addTransaction(transactionData, useLocalStorage);
      
      console.log('Transaction saved successfully:', result);
      
      toast({
        title: 'Success',
        description: 'Transaction saved successfully to ' + (useLocalStorage ? 'local storage' : 'Supabase'),
      });
      
      // Navigate back to the dashboard to see updated metrics
      navigate('/');
      return result;
    } catch (error) {
      console.error('Error saving transaction:', error);
      
      let errorMessage = 'Failed to save transaction';
      
      // Detailed error information for debugging
      if (error instanceof Error) {
        errorMessage = error.message;
        console.error('Error instance details:', {
          message: error.message,
          stack: error.stack
        });
        
        // Check for specific errors
        if (error.message.includes('duplicate key') || error.message.includes('constraint')) {
          errorMessage = 'A merchant with this name already exists';
        } else if (error.message.includes('network')) {
          errorMessage = 'Network error - please check your connection';
        }
      }
      
      setSaveError(errorMessage);
      
      toast({
        title: 'Error',
        description: errorMessage,
        variant: 'destructive',
      });
      
      // Don't navigate when there's an error, let user fix and try again
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  return { handleSubmit, isLoading, saveError };
};



================================================================
End of Codebase
================================================================
