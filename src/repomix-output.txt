This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: components/dashboard/, contexts/, utils/, types/, hooks/, pages/, containers/, services/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
components/
  dashboard/
    cards/
      CardOptimizationCard.tsx
      PaymentMethodCard.tsx
      SavingsPotentialCard.tsx
      SpendingCategoryCard.tsx
      SpendingTrendCard.tsx
      UnusualSpendingCard.tsx
    charts/
      BarChart.tsx
      PieChart.tsx
    tooltips/
      ChartTooltip.tsx
    dashboard-filters.css
    dashboard.css
    Dashboard.tsx
    DashboardHeader.tsx
    DashboardProvider.tsx
    DisplayCurrencySelect.tsx
    EmptyState.tsx
    FilterBar.tsx
    InsightsGrid.tsx
    LoadingDashboard.tsx
    RecentTransactions.tsx
    StatementCycleFilter.tsx
    SummaryCard.tsx
    SummaryCharts.tsx
    SummarySection.tsx
contexts/
  DashboardContext.tsx
hooks/
  dashboard/
    useDashboardData.ts
  expense-form/
    formSchema.ts
    useMerchantData.ts
    usePaymentMethodLogic.ts
    useRewardPoints.ts
  transaction-list/
    types.ts
    useTransactionData.ts
    useTransactionFilters.ts
  use-debounce.ts
  use-mobile.tsx
  use-toast.ts
  useCardAnalytics.ts
  useChartData.ts
  useCurrencyFormatter.ts
  useDashboard.ts
  useDashboardFilters.ts
  useExpenseForm.ts
  useMediaQuery.ts
  usePaymentMethods.ts
  useSupabaseConnectionCheck.ts
  useTransactionActions.ts
  useTransactionList.ts
  useTransactionSubmit.ts
pages/
  AddExpense.tsx
  Index.tsx
  NotFound.tsx
  PaymentMethods.tsx
  RewardPoints.tsx
  Transactions.tsx
services/
  calculators/
    BaseCalculator.ts
    CalculatorRegistry.ts
    RuleBasedCalculator.ts
  BonusPointsTrackingService.ts
  CurrencyService.ts
  RewardCalculationService.ts
types/
  dashboard.ts
  dashboardTypes.ts
  index.ts
utils/
  constants/
    mcc.ts
  defaults/
    paymentMethods.ts
  expense/
    submitExpense.ts
  rewards/
    rewardCalculationAdapter.ts
  storage/
    transactions/
      add.ts
      bonus-points.ts
      calculations.ts
      delete.ts
      edit.ts
      export.ts
      get.ts
      local-storage.ts
      save.ts
    index.ts
    merchants.ts
    merchantTracking.ts
    paymentMethods.ts
    transactions.ts
  cardOptimization.ts
  CardOptimizationAnalyzer.ts
  categoryMapping.ts
  chartDataProcessor.ts
  currencyFormatter.ts
  dashboardCalculations.ts
  dashboardUtils.ts
  dateUtils.ts
  errorHandling.ts
  formatting.ts
  storageUtils.ts
  TransactionAnalyzer.ts
  transactionProcessor.ts
  unusualSpendingDetection.ts

================================================================
Files
================================================================

================
File: components/dashboard/cards/CardOptimizationCard.tsx
================
// src/components/dashboard/cards/CardOptimizationCard.tsx
import React from "react";
import { CreditCardIcon, RefreshCwIcon, ArrowRightIcon } from "lucide-react";
import { Transaction, PaymentMethod, Currency } from "@/types";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { CurrencyService } from "@/services/CurrencyService";
import { Button } from "@/components/ui/button";
import { usePaymentMethodOptimization } from "@/hooks/useChartData";

interface CardOptimizationCardProps {
  title: string;
  transactions: Transaction[];
  paymentMethods: PaymentMethod[];
  currency?: Currency;
  className?: string;
}

/**
 * Card component that analyzes transactions and suggests optimal payment methods
 * Now uses the usePaymentMethodOptimization hook for data processing
 */
const CardOptimizationCard: React.FC<CardOptimizationCardProps> = ({
  title,
  transactions,
  paymentMethods,
  currency = "SGD",
  className = "",
}) => {
  // Use the payment method optimization hook
  const suggestions = usePaymentMethodOptimization(
    transactions,
    paymentMethods
  );

  // Calculate total potential annual savings
  const totalPotentialSavings =
    suggestions.reduce(
      (sum, suggestion) => sum + suggestion.potentialSavings,
      0
    ) * 12; // Multiply by 12 for annual estimate

  return (
    <Card className={className}>
      <CardHeader className="pb-2">
        <div className="flex items-center justify-between">
          <CardTitle className="text-xl flex items-center gap-2">
            <CreditCardIcon className="h-5 w-5 text-primary" />
            {title}
          </CardTitle>

          <Button variant="ghost" size="sm" className="h-8 px-2">
            <RefreshCwIcon className="h-4 w-4 mr-1" />
            <span className="text-xs">Refresh</span>
          </Button>
        </div>
      </CardHeader>

      <CardContent>
        {suggestions.length === 0 ? (
          <div className="flex flex-col items-center justify-center h-60 text-center">
            <CreditCardIcon className="h-8 w-8 text-muted-foreground mb-2" />
            <p className="text-muted-foreground">
              No card optimization suggestions available.
            </p>
            <p className="text-xs text-muted-foreground mt-1">
              You're already using optimal payment methods!
            </p>
          </div>
        ) : (
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <p className="text-sm text-muted-foreground">
                Potential annual savings with optimal cards:
              </p>
              <p className="font-medium text-green-500">
                +{CurrencyService.format(totalPotentialSavings, currency)}
              </p>
            </div>

            <div className="space-y-3">
              {suggestions.map((suggestion, index) => (
                <div
                  key={index}
                  className="p-3 rounded-lg border border-border bg-muted/30"
                >
                  <div className="flex justify-between items-start mb-1">
                    <span className="font-medium text-sm">
                      {suggestion.category}
                    </span>
                    <span className="text-green-500 text-xs">
                      +
                      {CurrencyService.format(
                        suggestion.potentialSavings,
                        currency
                      )}
                      /mo
                    </span>
                  </div>
                  <p className="text-xs text-muted-foreground mb-2">
                    {suggestion.transactionCount} transactions
                  </p>
                  <div className="flex items-center justify-between">
                    <div className="flex-1">
                      <p className="text-xs text-muted-foreground">Current</p>
                      <p className="text-xs font-medium truncate">
                        {suggestion.currentMethod}
                      </p>
                    </div>
                    <div className="mx-2">
                      <ArrowRightIcon size={16} />
                    </div>
                    <div className="flex-1">
                      <p className="text-xs text-muted-foreground">Suggested</p>
                      <p className="text-xs font-medium text-primary truncate">
                        {suggestion.suggestedMethod}
                      </p>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
};

export default React.memo(CardOptimizationCard);

================
File: components/dashboard/cards/PaymentMethodCard.tsx
================
// src/components/dashboard/cards/PaymentMethodCard.tsx
import React from 'react';
import { CreditCardIcon } from 'lucide-react';
import { Currency } from '@/types';
import { PieChart, ChartDataItem } from '@/components/dashboard/charts/PieChart';

interface PaymentMethodCardProps {
  title?: string;
  data: ChartDataItem[];
  currency?: Currency;
  className?: string;
  highlightTopMethod?: boolean;
}

/**
 * A specialized card for displaying payment method distribution
 * Wraps the PieChart component with payment-specific formatting and behavior
 */
const PaymentMethodCard: React.FC<PaymentMethodCardProps> = ({
  title = 'Payment Methods',
  data,
  currency = 'SGD',
  className = '',
  highlightTopMethod = true
}) => {
  // Process data to highlight the top payment method if requested
  const processedData = React.useMemo(() => {
    if (!data || !highlightTopMethod) return data;
    
    // Sort by value descending to find top method
    const sortedData = [...data].sort((a, b) => b.value - a.value);
    
    if (sortedData.length > 0) {
      // Add visual differentiation to the top method (slightly larger outer radius)
      return sortedData.map((item, index) => ({
        ...item,
        // Attributes specific to payment visualization could be added here
        highlighted: index === 0
      }));
    }
    
    return data;
  }, [data, highlightTopMethod]);
  
  // Payment method chart can use different radius to distinguish it from category chart
  const innerRadius = 50;
  const outerRadius = 80;
  
  return (
    <PieChart
      title={title}
      icon={<CreditCardIcon className="h-5 w-5 text-primary" />}
      data={processedData}
      currency={currency}
      className={className}
      innerRadius={innerRadius}
      outerRadius={outerRadius}
    />
  );
};

export default React.memo(PaymentMethodCard);

================
File: components/dashboard/cards/SavingsPotentialCard.tsx
================
// src/components/dashboard/cards/SavingsPotentialCard.tsx
import React from "react";
import { PiggyBankIcon, TrendingDownIcon, BarChart3Icon } from "lucide-react";
import { Transaction, Currency } from "@/types";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { CurrencyService } from "@/services/CurrencyService";
import { Progress } from "@/components/ui/progress";
import { useSavingsPotential } from "@/hooks/useChartData";

interface SavingsPotentialCardProps {
  title: string;
  transactions: Transaction[];
  savingsGoalPercentage?: number;
  currency?: Currency;
  className?: string;
}

/**
 * Card component that analyzes transactions to identify savings potential
 * Optimized with memoization and early returns
 */
const SavingsPotentialCard: React.FC<SavingsPotentialCardProps> = ({
  title,
  transactions,
  savingsGoalPercentage = 20,
  currency = "SGD",
  className = "",
}) => {
  // Check if we have transactions to analyze
  const hasTransactions = transactions.length > 0;

  // Use the savings potential hook with memoized inputs
  const analysis = useSavingsPotential(
    hasTransactions ? transactions : [],
    savingsGoalPercentage
  );

  // Memoize derived values to prevent recalculations in render
  const formattedValues = React.useMemo(() => {
    if (!hasTransactions) return null;

    const savingsPotentialFormatted = CurrencyService.format(
      analysis.savingsPotential,
      currency
    );
    const savingsProgressRounded = Math.round(analysis.savingsProgress);
    const discretionarySpendingFormatted = CurrencyService.format(
      analysis.discretionarySpending,
      currency
    );
    const discretionaryPercentage = Math.round(
      (analysis.discretionarySpending / analysis.totalSpending) * 100
    );

    return {
      savingsPotentialFormatted,
      savingsProgressRounded,
      discretionarySpendingFormatted,
      discretionaryPercentage,
    };
  }, [analysis, currency, hasTransactions]);

  // Memoize the categories to prevent unnecessary re-renders
  const savingsCategories = React.useMemo(() => {
    if (!hasTransactions) return [];

    return analysis.topDiscretionaryCategories.map((category, index) => (
      <div
        key={index}
        className="flex items-center justify-between py-1.5 border-b border-border/50 last:border-0"
      >
        <div className="flex items-center">
          <TrendingDownIcon className="h-3.5 w-3.5 text-green-500 mr-2" />
          <span className="text-xs">{category.category}</span>
        </div>
        <span className="text-xs text-green-500">
          -{CurrencyService.format(category.savingsPotential, currency)}
        </span>
      </div>
    ));
  }, [analysis.topDiscretionaryCategories, currency, hasTransactions]);

  // Early return for empty state
  if (!hasTransactions) {
    return (
      <Card className={className}>
        <CardHeader className="pb-2">
          <CardTitle className="text-xl flex items-center gap-2">
            <PiggyBankIcon className="h-5 w-5 text-primary" />
            {title}
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex flex-col items-center justify-center h-60 text-center">
            <PiggyBankIcon className="h-8 w-8 text-muted-foreground mb-2" />
            <p className="text-muted-foreground">
              No transaction data available.
            </p>
            <p className="text-xs text-muted-foreground mt-1">
              Add transactions to see savings potential.
            </p>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className={className}>
      <CardHeader className="pb-2">
        <CardTitle className="text-xl flex items-center gap-2">
          <PiggyBankIcon className="h-5 w-5 text-primary" />
          {title}
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <p className="text-sm text-muted-foreground">
              Monthly Savings Potential
            </p>
            <p className="font-medium text-green-500">
              {formattedValues?.savingsPotentialFormatted}
            </p>
          </div>

          {/* Savings Progress */}
          <div className="space-y-2">
            <div className="flex justify-between text-xs">
              <span>Progress towards goal</span>
              <span>{formattedValues?.savingsProgressRounded}%</span>
            </div>
            <Progress value={analysis.savingsProgress} className="h-2" />
          </div>

          {/* Discretionary Spending Summary */}
          <div className="p-3 rounded-lg border border-border bg-muted/30">
            <div className="flex justify-between items-center mb-2">
              <span className="font-medium text-sm flex items-center">
                <BarChart3Icon className="h-4 w-4 mr-1" />
                Discretionary Spending
              </span>
              <span className="text-sm font-medium">
                {formattedValues?.discretionarySpendingFormatted}
              </span>
            </div>
            <p className="text-xs text-muted-foreground">
              {formattedValues?.discretionaryPercentage}% of your total spending
            </p>
          </div>

          {/* Top Savings Categories */}
          <div className="space-y-2">
            <p className="text-xs font-medium">Top savings opportunities:</p>
            {savingsCategories}
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

export default React.memo(SavingsPotentialCard);

================
File: components/dashboard/cards/SpendingCategoryCard.tsx
================
// src/components/dashboard/cards/SpendingCategoryCard.tsx
import React from 'react';
import { TagIcon } from 'lucide-react';
import { Currency } from '@/types';
import { PieChart, ChartDataItem } from '@/components/dashboard/charts/PieChart';

interface SpendingCategoryCardProps {
  title?: string;
  data: ChartDataItem[];
  currency?: Currency;
  className?: string;
  maxCategories?: number;
}

/**
 * A specialized card for displaying spending by category
 * Wraps the PieChart component with domain-specific defaults and styling
 */
const SpendingCategoryCard: React.FC<SpendingCategoryCardProps> = ({
  title = 'Expense Categories',
  data,
  currency = 'SGD',
  className = '',
  maxCategories = 10
}) => {
  // Process data to show only the top categories and group others
  const processedData = React.useMemo(() => {
    if (!data || data.length <= maxCategories) return data;
    
    // Sort by value descending
    const sortedData = [...data].sort((a, b) => b.value - a.value);
    
    // Take top categories
    const topCategories = sortedData.slice(0, maxCategories - 1);
    
    // Group the rest as "Other"
    const otherCategories = sortedData.slice(maxCategories - 1);
    const otherValue = otherCategories.reduce((sum, item) => sum + item.value, 0);
    
    if (otherValue > 0) {
      return [
        ...topCategories,
        {
          name: 'Other',
          value: otherValue,
          color: '#9e9e9e' // Gray color for "Other" category
        }
      ];
    }
    
    return topCategories;
  }, [data, maxCategories]);
  
  // Use specific domain settings for category visualization
  const innerRadius = 50;
  const outerRadius = 80;
  
  return (
    <PieChart
      title={title}
      icon={<TagIcon className="h-5 w-5 text-primary" />}
      data={processedData}
      currency={currency}
      className={className}
      innerRadius={innerRadius}
      outerRadius={outerRadius}
    />
  );
};

export default React.memo(SpendingCategoryCard);

================
File: components/dashboard/cards/SpendingTrendCard.tsx
================
// src/components/dashboard/cards/SpendingTrendCard.tsx
import React, { useState, useMemo } from "react";
import { TrendingUpIcon, TrendingDownIcon } from "lucide-react";
import { Transaction, Currency } from "@/types";
import { BarChart } from "@/components/dashboard/charts/BarChart";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { CurrencyService } from "@/services/CurrencyService";

interface SpendingTrendCardProps {
  title?: string;
  transactions: Transaction[];
  currency?: Currency;
  initialPeriod?: "day" | "week" | "month" | "quarter";
  className?: string;
}

/**
 * A specialized card for displaying spending trends over time with period selection
 * Mimics the implementation of SpendingTrendChart but as a functional component
 */
const SpendingTrendCard: React.FC<SpendingTrendCardProps> = ({
  title = "Spending Trends",
  transactions,
  currency = "SGD",
  initialPeriod = "month",
  className = "",
}) => {
  // State for selected period
  const [selectedPeriod, setSelectedPeriod] = useState(initialPeriod);

  // Apply domain-specific colors for spending trends
  const spendingBarColor = "#8884d8";
  const spendingHoverColor = "#7171d6";

  // Check if transactions exist early to prevent unnecessary calculations
  const hasTransactions = transactions.length > 0;

  // Memoize category processing function to avoid recreation on each render
  const getTopCategoriesForPeriod = React.useCallback(
    (
      periodTransactions: Transaction[]
    ): Array<{ category: string; amount: number }> => {
      // Group by category
      const categoryMap = new Map<string, number>();

      periodTransactions.forEach((tx) => {
        if (!tx.category) return;

        const existingAmount = categoryMap.get(tx.category) || 0;
        categoryMap.set(tx.category, existingAmount + tx.amount);
      });

      // Convert to array and sort by amount (descending)
      const categories = Array.from(categoryMap.entries())
        .map(([category, amount]) => ({ category, amount }))
        .sort((a, b) => b.amount - a.amount);

      return categories.slice(0, 3); // Return top 3 categories
    },
    []
  );

  // Memoize period mapping to avoid recreation on each render
  const periodMapping = React.useMemo(
    () => ({
      week: "day",
      month: "week",
      quarter: "month",
      year: "month",
    }),
    []
  );

  // Process transactions for spending trends analysis with optimized memoization
  const { chartData, trend, average, topCategories } = useMemo(() => {
    if (!hasTransactions) {
      return { chartData: [], trend: 0, average: 0, topCategories: [] };
    }

    // Group transactions by date
    const groupedTransactions = new Map<string, Transaction[]>();

    // Use the selected period to determine the grouping granularity
    const groupBy = periodMapping[selectedPeriod];

    transactions.forEach((tx) => {
      const txDate = new Date(tx.date);
      let key: string;

      // Create the appropriate date key based on the grouping period
      switch (groupBy) {
        case "day":
          key = txDate.toISOString().split("T")[0]; // YYYY-MM-DD
          break;
        case "week": {
          // Get the start of the week (Sunday)
          const startOfWeek = new Date(txDate);
          startOfWeek.setDate(txDate.getDate() - txDate.getDay());
          key = startOfWeek.toISOString().split("T")[0];
          break;
        }
        case "month":
          key = `${txDate.getFullYear()}-${String(txDate.getMonth() + 1).padStart(2, "0")}`;
          break;
        default:
          key = txDate.toISOString().split("T")[0];
      }

      if (!groupedTransactions.has(key)) {
        groupedTransactions.set(key, []);
      }
      groupedTransactions.get(key)?.push(tx);
    });

    // Get sorted keys once to avoid repeated sorting
    const sortedKeys = Array.from(groupedTransactions.keys()).sort();

    // Get most recent period data for top categories
    const latestKey =
      sortedKeys.length > 0 ? sortedKeys[sortedKeys.length - 1] : null;
    const latestTransactions = latestKey
      ? groupedTransactions.get(latestKey) || []
      : [];
    const topCats = getTopCategoriesForPeriod(latestTransactions);

    // Process data for chart with a single loop
    const processedChartData = sortedKeys.map((key) => {
      const periodTransactions = groupedTransactions.get(key) || [];

      // Calculate total with a single reduce operation
      const total = periodTransactions.reduce((sum, tx) => sum + tx.amount, 0);

      // Optimize date formatting based on period type
      let displayDate = key;
      if (groupBy === "week") {
        // For weeks, show date range
        const startDate = new Date(key);
        const endDate = new Date(startDate);
        endDate.setDate(startDate.getDate() + 6);
        displayDate = `${startDate.getDate()}/${startDate.getMonth() + 1} - ${endDate.getDate()}/${endDate.getMonth() + 1}`;
      } else if (groupBy === "month") {
        // For months, show month name
        const [year, month] = key.split("-");
        const date = new Date(parseInt(year), parseInt(month) - 1, 1);
        displayDate = date.toLocaleString("default", { month: "short" });
        if (selectedPeriod === "quarter") {
          displayDate += ` ${year}`;
        }
      }

      return {
        period: displayDate,
        amount: total,
        originalKey: key,
        // Only calculate top categories when needed (helps performance for large datasets)
        topCategories:
          periodTransactions.length > 0
            ? getTopCategoriesForPeriod(periodTransactions)
            : [],
      };
    });

    // Calculate trend and average in a single pass if possible
    let calculatedTrend = 0;
    let calculatedTotal = 0;

    if (processedChartData.length >= 2) {
      const currentAmount =
        processedChartData[processedChartData.length - 1].amount;
      const previousAmount =
        processedChartData[processedChartData.length - 2].amount;

      calculatedTrend =
        previousAmount === 0
          ? currentAmount > 0
            ? 100
            : 0
          : ((currentAmount - previousAmount) / previousAmount) * 100;
    }

    // Calculate average in a single pass to avoid a second loop
    const calculatedAverage =
      processedChartData.length > 0
        ? processedChartData.reduce((sum, item) => {
            calculatedTotal += item.amount;
            return calculatedTotal;
          }, 0) / processedChartData.length
        : 0;

    return {
      chartData: processedChartData,
      trend: calculatedTrend,
      average: calculatedAverage,
      topCategories: topCats,
    };
  }, [
    transactions,
    selectedPeriod,
    periodMapping,
    getTopCategoriesForPeriod,
    hasTransactions,
  ]);

  // Generate spending insights
  const renderInsights = () => {
    if (chartData.length < 2) {
      return <p>Not enough data for meaningful insights</p>;
    }

    const trendType = trend >= 0 ? "increase" : "decrease";
    const trendIcon =
      trend >= 0 ? (
        <TrendingUpIcon className="h-4 w-4 text-red-600 dark:text-red-400" />
      ) : (
        <TrendingDownIcon className="h-4 w-4 text-green-600 dark:text-green-400" />
      );

    // Find the highest spending category
    const topCategory = topCategories[0];

    return (
      <div className="mt-2 text-sm space-y-1">
        <div className="flex items-center gap-1">
          {trendIcon}
          <span>
            Your spending {trendType}d by {Math.abs(trend).toFixed(1)}% compared
            to last period
          </span>
        </div>

        {topCategory && (
          <p className="text-muted-foreground">
            Highest spending:{" "}
            {CurrencyService.format(topCategory.amount, currency)} on{" "}
            {topCategory.category}
          </p>
        )}
      </div>
    );
  };

  // Handle period change
  const handlePeriodChange = (value: string) => {
    setSelectedPeriod(value as "day" | "week" | "month" | "quarter");
  };

  // Return the custom card with period selector and trends
  return (
    <Card className={className}>
      <CardHeader className="pb-2">
        <div className="flex items-center justify-between">
          <CardTitle className="text-xl flex items-center gap-2">
            <TrendingUpIcon className="h-5 w-5 text-primary" />
            {title}
          </CardTitle>

          {/* Period Selector Dropdown - mimicking the original */}
          <Select value={selectedPeriod} onValueChange={handlePeriodChange}>
            <SelectTrigger className="w-32 h-8">
              <SelectValue placeholder="Select period" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="week">Daily</SelectItem>
              <SelectItem value="month">Weekly</SelectItem>
              <SelectItem value="quarter">Monthly</SelectItem>
              <SelectItem value="year">Quarterly</SelectItem>
            </SelectContent>
          </Select>
        </div>
      </CardHeader>

      <CardContent>
        {/* Display trend and average */}
        {chartData.length >= 2 && (
          <div className="flex items-center justify-between mb-4">
            <div>
              <p className="text-sm text-muted-foreground">Trend</p>
              <div className="flex items-center gap-1 mt-1">
                {trend >= 0 ? (
                  <TrendingUpIcon className="h-4 w-4 text-red-600 dark:text-red-400" />
                ) : (
                  <TrendingDownIcon className="h-4 w-4 text-green-600 dark:text-green-400" />
                )}
                <span
                  className={
                    trend >= 0
                      ? "font-medium text-red-600 dark:text-red-400"
                      : "font-medium text-green-600 dark:text-green-400"
                  }
                >
                  {Math.abs(trend).toFixed(1)}%
                </span>
              </div>
            </div>

            <div className="text-right">
              <p className="text-sm text-muted-foreground">Average</p>
              <p className="font-medium mt-1">
                {CurrencyService.format(average, currency)}
              </p>
            </div>
          </div>
        )}

        {/* Use the BarChart component for visualization */}
        <BarChart
          title=""
          transactions={transactions}
          period={selectedPeriod}
          currency={currency}
          barColor={spendingBarColor}
          hoverColor={spendingHoverColor}
          showInsights={false} // We handle insights separately
        />

        {/* Show insights below the chart */}
        {chartData.length >= 2 && renderInsights()}
      </CardContent>
    </Card>
  );
};

export default React.memo(SpendingTrendCard);

================
File: components/dashboard/cards/UnusualSpendingCard.tsx
================
// src/components/dashboard/cards/UnusualSpendingCard.tsx
import React from "react";
import { AlertTriangleIcon, ChevronRightIcon } from "lucide-react";
import { Transaction, Currency } from "@/types";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { CurrencyService } from "@/services/CurrencyService";
import {
  SpendingAnomaly,
  useUnusualSpending,
} from "@/utils/unusualSpendingDetection";
import { Link } from "react-router-dom";

interface UnusualSpendingCardProps {
  title?: string;
  transactions: Transaction[];
  currency?: Currency;
  className?: string;
  maxDisplayedAnomalies?: number;
}

/**
 * Card component that displays unusual spending patterns and anomalies
 */
const UnusualSpendingCard: React.FC<UnusualSpendingCardProps> = ({
  title = "Unusual Spending",
  transactions,
  currency = "USD",
  className = "",
  maxDisplayedAnomalies = 3,
}) => {
  // Use our custom hook to detect anomalies
  const { anomalies, alertCount } = useUnusualSpending(transactions);

  // Get a subset of anomalies to display
  const displayedAnomalies = anomalies.slice(0, maxDisplayedAnomalies);

  // Helper to get dot color based on severity
  const getSeverityColor = (severity: "low" | "medium" | "high"): string => {
    switch (severity) {
      case "high":
        return "text-red-500 fill-red-500";
      case "medium":
        return "text-orange-500 fill-orange-500";
      case "low":
        return "text-blue-500 fill-blue-500";
      default:
        return "text-gray-500 fill-gray-500";
    }
  };

  return (
    <Card className={`overflow-hidden ${className}`}>
      <CardHeader className="pb-2">
        <div className="flex items-center justify-between">
          <CardTitle className="text-xl flex items-center gap-2">
            <AlertTriangleIcon className="h-5 w-5 text-amber-500" />
            {title}
          </CardTitle>

          {alertCount > 0 && (
            <Badge
              variant="outline"
              className="bg-amber-100 text-amber-800 border-amber-200 px-2 py-0.5"
            >
              {alertCount} {alertCount === 1 ? "alert" : "alerts"}
            </Badge>
          )}
        </div>
      </CardHeader>

      <CardContent>
        {anomalies.length === 0 ? (
          <div className="flex flex-col items-center justify-center h-48 text-center">
            <div className="bg-green-50 dark:bg-green-900/20 p-3 rounded-full mb-3">
              <AlertTriangleIcon className="h-6 w-6 text-green-500" />
            </div>
            <p className="text-muted-foreground">
              No unusual spending detected.
            </p>
            <p className="text-xs text-muted-foreground mt-1">
              We'll notify you when we spot any anomalies in your spending.
            </p>
          </div>
        ) : (
          <div className="space-y-4">
            {/* Anomaly List */}
            <div className="space-y-3">
              {displayedAnomalies.map((anomaly, index) => (
                <div
                  key={anomaly.transactionId}
                  className="flex items-start justify-between py-2"
                >
                  <div className="flex items-start gap-3">
                    {/* Severity Dot */}
                    <div
                      className={`mt-1.5 h-2 w-2 rounded-full ${getSeverityColor(anomaly.severity)}`}
                    />

                    {/* Merchant and Reason */}
                    <div>
                      <p className="font-medium">{anomaly.merchantName}</p>
                      <p className="text-sm text-muted-foreground">
                        {anomaly.reason}
                      </p>
                    </div>
                  </div>

                  {/* Amount */}
                  <div className="text-right font-medium">
                    {CurrencyService.format(anomaly.amount, currency)}
                  </div>
                </div>
              ))}
            </div>

            {/* View All Link */}
            {alertCount > maxDisplayedAnomalies && (
              <Link
                to="/transactions?filter=anomalies"
                className="text-sm text-primary flex items-center justify-center mt-2 hover:underline"
              >
                View All Anomalies <ChevronRightIcon className="h-4 w-4 ml-1" />
              </Link>
            )}
          </div>
        )}
      </CardContent>
    </Card>
  );
};

export default React.memo(UnusualSpendingCard);

================
File: components/dashboard/charts/BarChart.tsx
================
// src/components/dashboard/charts/BarChart.tsx
import React, { useMemo } from 'react';
import { BarChart as RechartsBar, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Currency } from '@/types';
import { Transaction } from '@/types';
import { TrendingUpIcon, TrendingDownIcon } from 'lucide-react';
import { 
  processTransactionsForChart, 
  ProcessedChartItem
} from '@/utils/chartDataProcessor';
import { useChartCurrencyFormatter } from '@/hooks/useCurrencyFormatter';

export interface BarChartProps {
  title: string;
  icon?: React.ReactNode;
  transactions: Transaction[];
  period?: 'day' | 'week' | 'month' | 'quarter';
  currency?: Currency;
  barColor?: string;
  hoverColor?: string;
  className?: string;
  showInsights?: boolean;
}

/**
 * Reusable bar chart component for displaying time-based data
 * Uses consolidated chart processing utility for consistent formatting
 * Optimized with custom hooks for currency formatting
 */
const BarChart: React.FC<BarChartProps> = ({
  title,
  icon,
  transactions,
  period = 'month',
  currency = 'SGD',
  barColor = '#8884d8',
  hoverColor = '#7171d6',
  className = '',
  showInsights = true
}) => {
  // Use the chart currency formatter hook
  const { tooltipFormatter, axisFormatter } = useChartCurrencyFormatter(currency);
  
  // Early return with empty data when no transactions to avoid unnecessary processing
  const hasTransactions = transactions.length > 0;
  
  // Process data for the chart using our utility - only when we have transactions
  const { chartData, trend, average, topCategories } = useMemo(() => {
    if (!hasTransactions) {
      return { chartData: [], trend: 0, average: 0, topCategories: [] };
    }
    
    return processTransactionsForChart(transactions, {
      period,
      includeCategoryBreakdown: showInsights,  // Only include category data if insights are shown
      maxTopCategories: 3,
      includeTrend: showInsights,
      displayCurrency: currency
    });
  }, [transactions, period, currency, hasTransactions, showInsights]);
  
  // Memoize tooltip component to prevent unnecessary re-renders
  const CustomTooltip = useMemo(() => {
    // Return a function component for the tooltip
    return function TooltipComponent({ active, payload, label }: any) {
      if (active && payload && payload.length) {
        const data = payload[0].payload as ProcessedChartItem;
        
        // Pre-format currency values
        const amountFormatted = axisFormatter(payload[0].value);
        
        return (
          <div className="bg-background border border-border p-3 rounded-md shadow-md max-w-xs">
            <p className="font-medium">{label}</p>
            <p className="text-primary text-lg font-semibold">
              {amountFormatted}
            </p>
            
            {showInsights && data.topCategories && data.topCategories.length > 0 && (
              <>
                <p className="mt-2 font-medium text-xs text-muted-foreground">Top Categories:</p>
                <div className="mt-1 space-y-1">
                  {data.topCategories.map((cat, index) => {
                    // Pre-format category amounts
                    const catAmountFormatted = axisFormatter(cat.amount);
                    
                    return (
                      <div key={index} className="flex justify-between text-xs">
                        <span>{cat.category}</span>
                        <span>{catAmountFormatted}</span>
                      </div>
                    );
                  })}
                </div>
              </>
            )}
          </div>
        );
      }
      return null;
    };
  }, [showInsights, axisFormatter]);
  
  // Generate spending insights component
  const renderInsights = useMemo(() => {
    if (chartData.length < 2) {
      return <p>Not enough data for meaningful insights</p>;
    }
    
    const trendType = trend >= 0 ? 'increase' : 'decrease';
    const trendIcon = trend >= 0 ? (
      <TrendingUpIcon className="h-4 w-4 text-red-600 dark:text-red-400" />
    ) : (
      <TrendingDownIcon className="h-4 w-4 text-green-600 dark:text-green-400" />
    );
    
    // Find the highest spending category
    const topCategory = topCategories[0];
    const topCategoryAmountFormatted = topCategory ? axisFormatter(topCategory.amount) : '';
    
    return (
      <div className="mt-2 text-sm space-y-1">
        <div className="flex items-center gap-1">
          {trendIcon}
          <span>
            Your spending {trendType}d by {Math.abs(trend).toFixed(1)}% compared to last period
          </span>
        </div>
        
        {topCategory && (
          <p className="text-muted-foreground">
            Highest spending: {topCategoryAmountFormatted} on {topCategory.category}
          </p>
        )}
      </div>
    );
  }, [chartData.length, trend, topCategories, axisFormatter]);
  
  // Empty state
  if (chartData.length === 0) {
    return (
      <Card className={`${className}`}>
        <CardHeader className="pb-2">
          <CardTitle className="text-xl flex items-center gap-2">
            {icon}
            {title}
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex items-center justify-center h-48 text-muted-foreground">
            <p>No data available for this period</p>
          </div>
        </CardContent>
      </Card>
    );
  }
  
  return (
    <Card className={`${className}`}>
      <CardHeader className="pb-2">
        <CardTitle className="text-xl flex items-center gap-2">
          {icon}
          {title}
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="h-48 w-full">
          <ResponsiveContainer width="100%" height="100%">
            <RechartsBar
              data={chartData}
              margin={{ top: 5, right: 5, left: 5, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" opacity={0.3} />
              <XAxis 
                dataKey="period" 
                axisLine={false}
                tickLine={false}
                tick={{ fontSize: 12 }}
              />
              <YAxis 
                axisLine={false}
                tickLine={false}
                tick={{ fontSize: 12 }}
                tickFormatter={axisFormatter}
              />
              <Tooltip content={CustomTooltip} />
              <Bar 
                dataKey="amount" 
                fill={barColor}
                activeBar={{ fill: hoverColor }}
                radius={[4, 4, 0, 0]}
              />
            </RechartsBar>
          </ResponsiveContainer>
        </div>
        
        {/* Show insights if enabled */}
        {showInsights && renderInsights}
      </CardContent>
    </Card>
  );
};

// Export both as named export and default export for flexibility
export { BarChart };
export default React.memo(BarChart);

================
File: components/dashboard/charts/PieChart.tsx
================
// src/components/dashboard/charts/PieChart.tsx
import React, { useMemo, useState, useEffect, useRef } from "react";
import {
  PieChart as RechartsPie,
  Pie,
  Cell,
  ResponsiveContainer,
  Tooltip,
} from "recharts";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Currency } from "@/types";
import { CurrencyService } from "@/services/CurrencyService";

/**
 * Common data structure for pie chart data
 */
export interface ChartDataItem {
  name: string;
  value: number;
  color: string;
}

export interface PieChartProps {
  title: string;
  icon?: React.ReactNode;
  data: ChartDataItem[];
  currency?: Currency;
  className?: string;
  innerRadius?: number;
  outerRadius?: number;
  paddingAngle?: number;
}

/**
 * Enhanced PieChart component with real-time responsive sizing
 */
const PieChart: React.FC<PieChartProps> = ({
  title,
  icon,
  data,
  currency = "SGD",
  className = "",
  innerRadius = 60,
  outerRadius = 80,
  paddingAngle = 2,
}) => {
  // Create a ref for the chart container
  const chartContainerRef = useRef<HTMLDivElement>(null);

  // State to hold the calculated radius values
  const [radius, setRadius] = useState({
    innerRadius: innerRadius,
    outerRadius: outerRadius,
  });

  // Process data to include percentages - optimized to avoid deep copying when not needed
  const processedData = useMemo(() => {
    if (!data || data.length === 0) return [];

    const total = data.reduce((sum, item) => sum + item.value, 0);

    if (total === 0) return [];

    return data.map((item) => ({
      ...item,
      percentage: (item.value / total) * 100,
    }));
  }, [data]);

  // Memoize radius calculation based on original props
  const baseRadius = useMemo(
    () => ({
      innerScale: innerRadius / 200,
      outerScale: outerRadius / 200,
    }),
    [innerRadius, outerRadius]
  );

  // Use ResizeObserver with fewer dependencies and throttled updates
  useEffect(() => {
    const container = chartContainerRef.current;
    if (!container || !processedData.length) return;

    // Throttle resize calculations to reduce performance impact
    let rafId: number;
    let lastUpdateTime = 0;
    const THROTTLE_DELAY = 100; // ms

    // Create a throttled handler for resize events
    const handleResize = (entries: ResizeObserverEntry[]) => {
      const now = Date.now();
      if (now - lastUpdateTime < THROTTLE_DELAY) {
        // Cancel any pending updates and schedule a new one
        cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(() => processResize(entries));
        return;
      }

      lastUpdateTime = now;
      processResize(entries);
    };

    const processResize = (entries: ResizeObserverEntry[]) => {
      const entry = entries[0];
      if (!entry) return;

      // Get container dimensions
      const { width, height } = entry.contentRect;
      const minDimension = Math.min(width, height);

      // Update radius values using memoized scales
      setRadius({
        innerRadius: Math.max(minDimension * baseRadius.innerScale, 20),
        outerRadius: Math.min(
          minDimension * baseRadius.outerScale,
          Math.min(width, height) / 2 - 10
        ),
      });
    };

    const resizeObserver = new ResizeObserver(handleResize);
    resizeObserver.observe(container);

    return () => {
      cancelAnimationFrame(rafId);
      resizeObserver.disconnect();
    };
  }, [baseRadius, processedData.length]); // Only re-setup when base scales change or data presence changes

  // Memoize tooltip component to prevent recreation on each render
  const CustomTooltip = useMemo(() => {
    // Define proper types for the tooltip props
    interface TooltipProps {
      active?: boolean;
      payload?: Array<{
        name: string;
        value: number;
        payload: {
          percentage: number;
          [key: string]: unknown;
        };
        [key: string]: unknown;
      }>;
    }

    return ({ active, payload }: TooltipProps) => {
      if (!active || !payload || !payload.length) return null;

      const item = payload[0];
      const entry = item.payload;

      return (
        <div className="bg-background border border-border p-3 rounded-md shadow-lg">
          <p className="font-medium text-sm mb-1">{item.name}</p>
          <p className="text-primary font-bold">
            {CurrencyService.format(item.value, currency)}
          </p>
          <p className="text-xs text-muted-foreground mt-1">
            {Math.round(entry.percentage)}% of total
          </p>
        </div>
      );
    };
  }, [currency]);

  // Memoize legend items to prevent expensive re-calculation
  const legendItems = useMemo(() => {
    if (!processedData || processedData.length === 0) return null;

    return (
      <div className="grid grid-cols-1 gap-2 w-full max-h-[240px] overflow-y-auto pr-2">
        {processedData.map((entry, index) => (
          <div
            key={`legend-${index}`}
            className="flex items-center justify-between text-xs"
          >
            <div className="flex items-center">
              <div
                className="w-3 h-3 rounded-sm mr-2 flex-shrink-0"
                style={{ backgroundColor: entry.color }}
              />
              <span className="truncate max-w-[150px]" title={entry.name}>
                {entry.name}
              </span>
            </div>
            <span className="ml-1 font-medium whitespace-nowrap">
              {entry.percentage.toFixed(1)}%
            </span>
          </div>
        ))}
      </div>
    );
  }, [processedData]);

  // Empty state
  if (processedData.length === 0) {
    return (
      <Card className={`${className}`}>
        <CardHeader className="pb-2">
          <CardTitle className="text-xl flex items-center gap-2">
            {icon}
            {title}
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex items-center justify-center h-64 text-muted-foreground">
            <p>No data available</p>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className={`${className}`}>
      <CardHeader className="pb-2">
        <CardTitle className="text-xl flex items-center gap-2">
          {icon}
          {title}
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="flex flex-col md:flex-row h-auto">
          {/* Chart container that shrinks proportionally - using ref for size detection */}
          <div
            ref={chartContainerRef}
            className="w-full md:w-1/2 h-[200px] sm:h-[220px] md:h-[240px] lg:h-[260px] flex items-center justify-center"
          >
            <ResponsiveContainer width="100%" height="100%">
              <RechartsPie>
                <Pie
                  data={processedData}
                  cx="50%"
                  cy="50%"
                  innerRadius={radius.innerRadius}
                  outerRadius={radius.outerRadius}
                  paddingAngle={paddingAngle}
                  dataKey="value"
                  isAnimationActive={false}
                  labelLine={false}
                >
                  {processedData.map((entry, index) => (
                    <Cell
                      key={`cell-${index}`}
                      fill={entry.color}
                      stroke="var(--background)"
                      strokeWidth={2}
                    />
                  ))}
                </Pie>
                <Tooltip content={<CustomTooltip />} />
              </RechartsPie>
            </ResponsiveContainer>
          </div>

          {/* Legend container that adapts to available space */}
          <div className="w-full md:w-1/2 mt-4 md:mt-0 md:pl-4 max-h-[200px] md:max-h-[240px] overflow-y-auto">
            {legendItems}
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

// Export both as named export and default export for flexibility
export { PieChart };
export default React.memo(PieChart);

================
File: components/dashboard/tooltips/ChartTooltip.tsx
================
// src/components/dashboard/tooltips/ChartTooltip.tsx
import React from "react";
import { CurrencyService } from "@/services/CurrencyService";
import { Currency } from "@/types";

const DEFAULT_CURRENCY: Currency = "SGD";

// Define a type for category data
interface CategoryData {
  category: string;
  amount: number;
}

// Define the payload item's nested payload object
interface NestedPayload {
  topCategories?: CategoryData[];
  // Add other known properties you might use
  [key: string]: unknown;
}

// Define a type for the payload items
interface TooltipPayloadItem {
  value: number;
  name: string;
  dataKey?: string;
  payload: NestedPayload;
  stroke?: string;
  fill?: string;
  // For other properties that might exist in the payload item
  [key: string]: unknown;
}

// Common props for all chart tooltips
export interface ChartTooltipProps {
  active?: boolean;
  payload?: TooltipPayloadItem[];
  label?: string;
  currency?: Currency;
}

// Base tooltip component with common styling and structure
export const ChartTooltip: React.FC<ChartTooltipProps> = ({
  active,
  payload,
  label,
  currency = DEFAULT_CURRENCY,
}) => {
  if (!active || !payload || !payload.length) {
    return null;
  }

  return (
    <div className="bg-background border border-border p-3 rounded-md shadow-md">
      <p className="font-medium">{label}</p>
      <p className="text-primary">
        {CurrencyService.format(payload[0].value, currency)}
      </p>
    </div>
  );
};

// Props for tooltips with additional category insights
export interface InsightTooltipProps extends ChartTooltipProps {
  showInsights?: boolean;
}

// Extended tooltip for spending charts with category insights
export const SpendingInsightTooltip: React.FC<InsightTooltipProps> = ({
  active,
  payload,
  label,
  currency = DEFAULT_CURRENCY,
  showInsights = true,
}) => {
  if (!active || !payload || !payload.length) {
    return null;
  }

  const data = payload[0].payload;

  return (
    <div className="bg-background border border-border p-3 rounded-md shadow-md max-w-xs">
      <p className="font-medium">{label}</p>
      <p className="text-primary text-lg font-semibold">
        {CurrencyService.format(payload[0].value, currency)}
      </p>

      {showInsights && data.topCategories && data.topCategories.length > 0 && (
        <>
          <p className="mt-2 font-medium text-xs text-muted-foreground">
            Top Categories:
          </p>
          <div className="mt-1 space-y-1">
            {data.topCategories.map((cat: CategoryData, index: number) => (
              <div key={index} className="flex justify-between text-xs">
                <span>{cat.category}</span>
                <span>{CurrencyService.format(cat.amount, currency)}</span>
              </div>
            ))}
          </div>
        </>
      )}
    </div>
  );
};

// Utility functions to create formatters for Recharts' built-in tooltip
export const createCurrencyFormatter = (currency: Currency = "USD") => {
  return (value: number, name: string, props?: unknown) => [
    CurrencyService.format(value, currency),
    name,
  ];
};

export const createLabelFormatter = () => {
  return (name: string) => name;
};

// HOC to add tooltip capability to any chart component
export function withTooltip<P extends object>(
  Component: React.ComponentType<P>,
  TooltipComponent: React.ComponentType<ChartTooltipProps> = ChartTooltip
) {
  return function TooltipWrapper(props: P & ChartTooltipProps) {
    const renderCustomTooltip = (tooltipProps: ChartTooltipProps) => {
      return <TooltipComponent {...tooltipProps} currency={props.currency} />;
    };

    return <Component {...props} customTooltip={renderCustomTooltip} />;
  };
}

================
File: components/dashboard/dashboard-filters.css
================
/* src/components/dashboard/dashboard-filters.css */

/* Consistent styling for filter components */
.filter-component {
    display: inline-flex;
    align-items: center;
    height: 40px;
    padding: 0;
    border-radius: 0.75rem;
    background: transparent;
    transition: all 300ms ease;
  }
  
  .component-hover-box {
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    height: 40px; /* Same height as Add Expense button */
    min-width: 120px;
    padding: 0 1rem;
    border-radius: 0.75rem;
    gap: 0.5rem;
    background: transparent;
    transition: all 300ms ease;
  }
  
  /* Ensure all selects and inputs have consistent height */
  .component-hover-box select,
  .component-hover-box input,
  .component-hover-box button,
  .component-hover-box .select-trigger {
    height: 32px; /* Consistent inner component height */
  }
  
  /* Apply the gradient on hover */
  .component-hover-box:hover {
    background: linear-gradient(to right, #6366f1, #a855f7);
    box-shadow: 0 10px 15px -3px rgba(99, 102, 241, 0.3), 0 4px 6px -4px rgba(168, 85, 247, 0.3);
    transform: translateY(-1px);
  }
  
  /* Apply style to icons */
  .component-hover-box svg {
    width: 16px;
    height: 16px;
  }
  
  /* Make text white on hover */
  .component-hover-box:hover,
  .component-hover-box:hover span,
  .component-hover-box:hover label,
  .component-hover-box:hover div,
  .component-hover-box:hover input,
  .component-hover-box:hover select,
  .component-hover-box:hover button {
    color: white !important;
  }
  
  /* Make SVG icons white on hover */
  .component-hover-box:hover svg {
    color: white !important;
    stroke: white !important;
  }
  
  /* Fix alignment of select components */
  .select-value {
    display: flex;
    align-items: center;
  }
  
  /* Ensure consistent spacing around icons */
  .icon-wrapper {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    margin-right: 8px;
  }

================
File: components/dashboard/dashboard.css
================
/* Dashboard component hover effects to match Add Expense button exactly */
.component-hover-box {
  position: relative;
  border-radius: 0.75rem; /* Slightly more rounded as requested */
  transition: all 300ms ease;
  height: 40px; /* h-10 from button */
  min-width: 120px; /* ensure minimum width consistent with button */
  padding: 0 1rem; /* px-4 from button, only horizontal padding */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem; /* gap-2 from button */
  background: transparent;
}

/* Apply the exact same gradient as the Add Expense button */
.component-hover-box:hover {
  background: linear-gradient(to right, #6366f1, #a855f7);
  box-shadow: 0 10px 15px -3px rgba(99, 102, 241, 0.3), 0 4px 6px -4px rgba(168, 85, 247, 0.3);
  transform: translateY(-1px);
}

/* Match icon styling from Add Expense button */
.component-hover-box svg {
  width: 16px;
  height: 16px;
}

/* Make text white on hover */
.component-hover-box:hover,
.component-hover-box:hover span,
.component-hover-box:hover label,
.component-hover-box:hover div {
  color: white !important;
}

/* Make SVG icons white on hover */
.component-hover-box:hover svg {
  color: white !important;
  stroke: white !important;
}

/* Custom animations */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes scaleIn {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.animate-fadeIn {
  animation: fadeIn 0.5s ease-out forwards;
}

.animate-scaleIn {
  animation: scaleIn 0.3s ease-out forwards;
}

/* Micro-interactions for cards */
.glass-card {
  border-radius: 1rem;
  background: rgba(255, 255, 255, 0.05);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  transition: all 0.3s ease;
}

.glass-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
}

.glass-card-elevated {
  border-radius: 1rem;
  background: rgba(255, 255, 255, 0.05);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  transition: all 0.3s ease;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
}

.glass-card-elevated:hover {
  transform: translateY(-2px) scale(1.01);
  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
}

/* Enhanced text gradients */
.text-gradient {
  background-image: linear-gradient(to right, #6366f1, #a855f7);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  letter-spacing: -0.025em;
}

/* Variable font weight utility */
.font-variable {
  font-variation-settings: "wght" var(--font-weight, 400);
}

.font-variable-semi {
  --font-weight: 600;
}

.font-variable-bold {
  --font-weight: 700;
}

.font-variable-black {
  --font-weight: 900;
}

/* Sparkline styles */
.sparkline {
  display: flex;
  align-items: flex-end;
  height: 20px;
  gap: 1px;
}

.sparkline-bar {
  width: 3px;
  background-color: currentColor;
  border-radius: 1px;
  opacity: 0.5;
  transition: height 0.3s ease, opacity 0.3s ease;
}

.sparkline-bar:last-child {
  opacity: 1;
  background-color: var(--primary);
}

.sparkline:hover .sparkline-bar {
  opacity: 0.8;
}

/* Interactive links */
.interactive-link {
  position: relative;
  transition: all 0.3s ease;
}

.interactive-link:after {
  content: "";
  position: absolute;
  width: 0;
  height: 1px;
  bottom: -2px;
  left: 0;
  background: currentColor;
  transition: width 0.3s ease;
}

.interactive-link:hover:after {
  width: 100%;
}

/* Enhanced button hover effect */
.btn-hover-effect {
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
}

.btn-hover-effect:after {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0.1);
  transform: translateX(-100%);
  transition: transform 0.6s ease;
}

.btn-hover-effect:hover:after {
  transform: translateX(0);
}

.btn-hover-effect:active {
  transform: scale(0.98);
}

/* Subtle texture background */
.texture-bg {
  background-color: var(--background);
  background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%239C92AC' fill-opacity='0.03'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
}

================
File: components/dashboard/Dashboard.tsx
================
// src/components/dashboard/Dashboard.tsx
import React from 'react';
import { useDashboardContext } from '@/contexts/DashboardContext';
import DashboardHeader from '@/components/dashboard/DashboardHeader';
import SummarySection from '@/components/dashboard/SummarySection';
import InsightsGrid from '@/components/dashboard/InsightsGrid';
import RecentTransactions from '@/components/dashboard/RecentTransactions';
import LoadingDashboard from '@/components/dashboard/LoadingDashboard';
import FilterBar from '@/components/dashboard/FilterBar';
import { EmptyState } from '@/components/dashboard/EmptyState';
import { PieChartIcon } from 'lucide-react';

export function Dashboard() {
  const {
    transactions,
    dashboardData,
    isLoading,
    activeTab,
    displayCurrency,
    useStatementMonth,
    statementCycleDay,
    setActiveTab,
    setDisplayCurrency,
    setUseStatementMonth,
    setStatementCycleDay
  } = useDashboardContext();

  // Early return for loading state
  if (isLoading) {
    return <LoadingDashboard />;
  }

  // No transactions state
  if (transactions.length === 0) {
    return (
      <div className="min-h-screen">
        <div className="container max-w-7xl mx-auto pb-8 md:pb-16 px-4 md:px-6">
          <DashboardHeader />
          <div className="mt-10 border border-dashed rounded-xl">
            <EmptyState 
              title="No Transactions Found"
              description="Add your first transaction to start tracking your expenses."
              icon={<PieChartIcon className="h-16 w-16 text-muted-foreground" />}
            />
          </div>
        </div>
      </div>
    );
  }

  // More efficient recent transactions calculation
  const recentTransactions = React.useMemo(() => {
    return transactions
      .slice()
      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
      .slice(0, 5);
  }, [transactions]);

  // Filter state grouped for FilterBar
  const filterState = {
    activeTab,
    displayCurrency,
    useStatementMonth,
    statementCycleDay,
    handleTimeframeChange: setActiveTab,
    handleCurrencyChange: setDisplayCurrency,
    handleStatementMonthToggle: setUseStatementMonth,
    handleStatementCycleDayChange: setStatementCycleDay
  };

  return (
    <div className="min-h-screen">
      <div className="container max-w-7xl mx-auto pb-8 md:pb-16 px-4 md:px-6">
        <DashboardHeader />
        
        {/* Dashboard Title and Global Filter Bar */}
        <div className="flex flex-col sm:flex-row sm:items-center justify-between gap-4 mb-6">
          <h2 className="text-2xl font-bold tracking-tight bg-clip-text text-transparent bg-gradient-to-r from-[#6366f1] to-[#a855f7]">
            Expense Summary
          </h2>
          
          {/* Global Filter Bar */}
          <FilterBar filters={filterState} />
        </div>
        
        {/* Summary Section */}
        <SummarySection />
        
        {/* Insights Grid */}
        <InsightsGrid />
        
        {/* Recent Transactions */}
        <RecentTransactions transactions={recentTransactions} />
      </div>
    </div>
  );
}

export default React.memo(Dashboard);

================
File: components/dashboard/DashboardHeader.tsx
================
// src/components/dashboard/DashboardHeader.tsx
import React from 'react';
import { Link } from 'react-router-dom';
import { Button } from '@/components/ui/button';
import { PlusCircleIcon } from 'lucide-react';
import { ThemeToggle } from '@/components/theme/theme-toggle';
import { useMediaQuery } from '@/hooks/useMediaQuery';

/**
 * Component that displays the dashboard header with title and actions
 */
const DashboardHeader: React.FC = () => {
  const isMobile = useMediaQuery('(max-width: 640px)');
  
  return (
    <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-6 sm:mb-10 mt-4">
      <div className="mb-4 sm:mb-0">
        <h1 className="text-3xl font-bold tracking-tight text-gradient">
          Expense Tracker
        </h1>
        <p className="text-muted-foreground mt-1.5 text-sm">
          Track and manage your expenses
        </p>
      </div>
      
      <div className="flex items-center gap-3">
        <ThemeToggle />
        <Link to="/add-expense">
          <Button className={`btn-hover-effect bg-gradient-to-r from-[#6366f1] to-[#a855f7] ${!isMobile ? 'gap-2' : 'w-10 h-10 p-0'}`}>
            <PlusCircleIcon className="h-4 w-4" />
            {!isMobile && <span>Add Expense</span>}
          </Button>
        </Link>
      </div>
    </div>
  );
};

export default React.memo(DashboardHeader);

================
File: components/dashboard/DashboardProvider.tsx
================
// src/components/dashboard/DashboardProvider.tsx
import React from 'react';
import { 
  DashboardContext, 
  DashboardProviderProps 
} from '@/contexts/DashboardContext';
import { useDashboardData } from '@/hooks/dashboard/useDashboardData';
import { DashboardConfig } from '@/types/dashboard';
import { Currency } from '@/types';
import { TimeframeTab } from '@/utils/transactionProcessor';

interface ExtendedDashboardProviderProps extends DashboardProviderProps {
  config?: Partial<DashboardConfig>;
}

export function DashboardProvider({ 
  children, 
  config 
}: ExtendedDashboardProviderProps) {
  // Default configuration values
  const defaultConfig: DashboardConfig = {
    defaultCurrency: 'SGD' as Currency,
    defaultTimeframe: 'thisMonth' as TimeframeTab,
    defaultStatementDay: 15,
    defaultUseStatementMonth: false,
  };

  // Merge provided config with defaults
  const mergedConfig = { ...defaultConfig, ...config };

  // Use the dashboard data hook
  const dashboardState = useDashboardData(
    mergedConfig.defaultTimeframe,
    mergedConfig.defaultCurrency,
    mergedConfig.defaultUseStatementMonth,
    mergedConfig.defaultStatementDay
  );

  return (
    <DashboardContext.Provider value={dashboardState}>
      {children}
    </DashboardContext.Provider>
  );
}

================
File: components/dashboard/DisplayCurrencySelect.tsx
================
import { useState } from "react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { CurrencyService } from "@/services/CurrencyService";
import { Currency } from "@/types";
import { DollarSign } from "lucide-react";

interface DisplayCurrencySelectProps {
  value: Currency;
  onChange: (currency: Currency) => void;
  className?: string;
}

const currencyOptions = CurrencyService.getCurrencyOptions();

const DisplayCurrencySelect = ({
  value,
  onChange,
  className = "",
}: DisplayCurrencySelectProps) => {
  return (
    <div className={`flex items-center h-full ${className}`}>
      <DollarSign className="h-5 w-5 text-muted-foreground mr-2" />
      <Select
        value={value}
        onValueChange={(value: string) => onChange(value as Currency)}
        defaultValue="SGD"
      >
        <SelectTrigger className="w-[80px] h-8 text-sm bg-transparent border-none">
          <SelectValue placeholder="SGD" />
        </SelectTrigger>
        <SelectContent>
          {currencyOptions.map((option) => (
            <SelectItem key={option.value} value={option.value}>
              {option.value}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
};

export default DisplayCurrencySelect;

================
File: components/dashboard/EmptyState.tsx
================
// src/components/dashboard/EmptyState.tsx
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { Button } from '@/components/ui/button';
import { PlusCircleIcon } from 'lucide-react';

interface EmptyStateProps {
  title?: string;
  description?: string;
  icon?: React.ReactNode;
  action?: {
    label: string;
    onClick: () => void;
  };
  className?: string;
}

export function EmptyState({
  title = 'No data available',
  description = 'Add transactions to see insights and visualizations.',
  icon,
  action,
  className = '',
}: EmptyStateProps) {
  const navigate = useNavigate();

  // Default action to add expense
  const defaultAction = {
    label: 'Add Transaction',
    onClick: () => navigate('/add-expense')
  };

  const finalAction = action || defaultAction;

  return (
    <div className={`p-6 text-center ${className}`}>
      {icon && <div className="mb-4 flex justify-center">{icon}</div>}
      <h3 className="text-lg font-medium mb-2">{title}</h3>
      <p className="text-muted-foreground mb-6">{description}</p>
      <Button 
        onClick={finalAction.onClick}
        className="gap-2 bg-gradient-to-r from-[#6366f1] to-[#a855f7]"
      >
        <PlusCircleIcon className="h-4 w-4" />
        {finalAction.label}
      </Button>
    </div>
  );
}

================
File: components/dashboard/FilterBar.tsx
================
// src/components/dashboard/FilterBar.tsx
import React from 'react';
import { Filter } from 'lucide-react';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import DisplayCurrencySelect from './DisplayCurrencySelect';
import StatementCycleFilter from './StatementCycleFilter';
import { TimeframeTab } from '@/utils/transactionProcessor';
import { Currency } from '@/types';
import './dashboard-filters.css';

/**
 * Props for the FilterBar component
 */
interface FilterBarProps {
  filters: {
    activeTab: string;
    displayCurrency: Currency;
    useStatementMonth: boolean;
    statementCycleDay: number;
    handleTimeframeChange: (value: string) => void;
    handleCurrencyChange: (currency: Currency) => void;
    handleStatementMonthToggle: (value: boolean) => void;
    handleStatementCycleDayChange: (day: number) => void;
  };
  className?: string;
}

/**
 * Global filter bar component for dashboard
 */
const FilterBar: React.FC<FilterBarProps> = ({ 
  filters,
  className = ''
}) => {
  const { 
    activeTab, 
    displayCurrency, 
    useStatementMonth, 
    statementCycleDay,
    handleTimeframeChange,
    handleCurrencyChange,
    handleStatementMonthToggle,
    handleStatementCycleDayChange
  } = filters;

  return (
    <div className={`flex flex-wrap items-center gap-2 ${className}`}>
      {/* Currency Selector */}
      <div className="flex items-center h-10">
        <DisplayCurrencySelect 
          value={displayCurrency} 
          onChange={handleCurrencyChange}
          className="component-hover-box"
        />
      </div>
      
      {/* Time Frame Selector */}
      <div className="flex items-center h-10 component-hover-box">
        <Filter className="h-5 w-5 text-muted-foreground mr-2" />
        <Select
          value={activeTab}
          onValueChange={handleTimeframeChange}
        >
          <SelectTrigger className="w-[120px] h-8 text-sm bg-transparent border-none">
            <SelectValue placeholder="This Month" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="thisMonth">This Month</SelectItem>
            <SelectItem value="lastMonth">Last Month</SelectItem>
            <SelectItem value="lastThreeMonths">Last 3 Months</SelectItem>
            <SelectItem value="thisYear">This Year</SelectItem>
          </SelectContent>
        </Select>
      </div>
      
      {/* Statement Month toggle */}
      <div className="flex items-center h-10">
        <StatementCycleFilter
          useStatementMonth={useStatementMonth}
          setUseStatementMonth={handleStatementMonthToggle}
          statementCycleDay={statementCycleDay}
          setStatementCycleDay={handleStatementCycleDayChange}
          className="component-hover-box"
        />
      </div>
    </div>
  );
};

export default React.memo(FilterBar);

================
File: components/dashboard/InsightsGrid.tsx
================
// src/components/dashboard/InsightsGrid.tsx
import React from 'react';
import { useDashboardContext } from '@/contexts/DashboardContext';
import PaymentMethodCard from '@/components/dashboard/cards/PaymentMethodCard';
import SpendingCategoryCard from '@/components/dashboard/cards/SpendingCategoryCard';
import SpendingTrendCard from '@/components/dashboard/cards/SpendingTrendCard';
import CardOptimizationCard from '@/components/dashboard/cards/CardOptimizationCard';
import SavingsPotentialCard from '@/components/dashboard/cards/SavingsPotentialCard';
import UnusualSpendingCard from '@/components/dashboard/cards/UnusualSpendingCard';
import { useMediaQuery } from '@/hooks/useMediaQuery';
import { EmptyState } from './EmptyState';
import { BarChartIcon } from 'lucide-react';

/**
 * Grid component that displays financial insights using domain-specific cards
 * Uses the Dashboard context instead of props
 */
const InsightsGrid: React.FC = () => {
  const {
    dashboardData,
    paymentMethods,
    displayCurrency
  } = useDashboardContext();

  // Ensure dashboardData is defined before destructuring
  const filteredTransactions = dashboardData?.filteredTransactions || [];
  const charts = dashboardData?.charts || { paymentMethods: [], categories: [] };
  
  // Early return if no data to prevent rendering empty charts
  const hasData = filteredTransactions.length > 0;
  
  // Use media query hook
  const isMobile = useMediaQuery('(max-width: 768px)');
  
  // Memoize common class to prevent recreation on every render
  const commonCardClass = React.useMemo(() => 
    'rounded-xl border border-border/50 bg-card hover:shadow-md transition-all',
    []
  );
  
  // Early return for empty data state
  if (!hasData) {
    return (
      <div className="my-6 space-y-6">
        <h2 className="text-2xl font-bold tracking-tight bg-clip-text text-transparent bg-gradient-to-r from-[#6366f1] to-[#a855f7]">
          Financial Insights
        </h2>
        <div className="p-6 text-center border border-dashed rounded-xl">
          <EmptyState 
            title="No Insights Available"
            description="Add transactions to see financial insights and visualizations."
            icon={<BarChartIcon className="h-16 w-16 text-muted-foreground" />}
          />
        </div>
      </div>
    );
  }
  
  return (
    <div className="my-6 space-y-6">
      <h2 className="text-2xl font-bold tracking-tight bg-clip-text text-transparent bg-gradient-to-r from-[#6366f1] to-[#a855f7]">
        Financial Insights
      </h2>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {/* Payment Methods Card */}
        <PaymentMethodCard
          data={charts.paymentMethods}
          currency={displayCurrency}
          className={commonCardClass}
          highlightTopMethod={true}
        />
        
        {/* Expense Categories Card */}
        <SpendingCategoryCard
          data={charts.categories}
          currency={displayCurrency}
          className={commonCardClass}
          maxCategories={7}
        />
        
        {/* Spending Trends Card */}
        <SpendingTrendCard
          transactions={filteredTransactions}
          currency={displayCurrency}
          className={commonCardClass}
          initialPeriod="day"
        />
        
        {/* Unusual Spending Card */}
        <UnusualSpendingCard
          transactions={filteredTransactions}
          currency={displayCurrency}
          className={commonCardClass}
          maxDisplayedAnomalies={isMobile ? 2 : 3}
        />
        
        {/* Container for optimization cards */}
        <div className={`grid grid-cols-1 gap-4 ${isMobile ? '' : 'col-span-2'}`}>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {/* Card Optimization Card */}
            <CardOptimizationCard
              title="Card Optimization"
              transactions={filteredTransactions}
              paymentMethods={paymentMethods}
              currency={displayCurrency}
              className={commonCardClass}
            />
            
            {/* Savings Potential Card */}
            <SavingsPotentialCard
              title="Savings Potential"
              transactions={filteredTransactions}
              savingsGoalPercentage={20}
              currency={displayCurrency}
              className={commonCardClass}
            />
          </div>
        </div>
      </div>
    </div>
  );
};

export default React.memo(InsightsGrid);

================
File: components/dashboard/LoadingDashboard.tsx
================
// src/components/dashboard/LoadingDashboard.tsx
import React from 'react';

/**
 * Component that displays an optimized loading state for the dashboard
 */
const LoadingDashboard: React.FC = () => {
  // Create reusable skeleton components
  const SkeletonBlock = ({ className }: { className: string }) => (
    <div className={`animate-pulse bg-muted ${className}`}></div>
  );
  
  // Render the summary cards skeleton
  const SummaryCardSkeleton = () => (
    <SkeletonBlock className="h-28 rounded-xl" />
  );
  
  // Render the insight card skeleton
  const InsightCardSkeleton = () => (
    <SkeletonBlock className="h-64 rounded-xl" />
  );
  
  // Render the transaction card skeleton
  const TransactionCardSkeleton = () => (
    <SkeletonBlock className="h-24 rounded-xl" />
  );
  
  return (
    <div className="min-h-screen animate-fadeIn">  
      <div className="container max-w-7xl mx-auto pb-16 px-4 md:px-6">
        {/* Header Skeleton */}
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-10 mt-4">
          <SkeletonBlock className="h-10 w-48 rounded-md" />
          <SkeletonBlock className="h-10 w-32 rounded-md mt-4 sm:mt-0" />
        </div>
        
        {/* Filter Controls Skeleton */}
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-6">
          <SkeletonBlock className="h-8 w-40 rounded-md" />
          <div className="flex flex-wrap gap-2 mt-2 sm:mt-0">
            <SkeletonBlock className="h-8 w-24 rounded-md" />
            <SkeletonBlock className="h-8 w-32 rounded-md" />
            <SkeletonBlock className="h-8 w-28 rounded-md" />
          </div>
        </div>
        
        {/* Summary Cards Skeleton */}
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
          {Array(4).fill(0).map((_, index) => (
            <SummaryCardSkeleton key={`summary-${index}`} />
          ))}
        </div>
        
        {/* Insights Title Skeleton */}
        <SkeletonBlock className="h-8 w-48 rounded-md mb-6" />
        
        {/* Insights Grid Skeleton */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
          {Array(4).fill(0).map((_, index) => (
            <InsightCardSkeleton key={`insight-${index}`} />
          ))}
        </div>
        
        {/* Recent Transactions Skeleton */}
        <div className="mt-8">
          <div className="flex justify-between items-center mb-4">
            <SkeletonBlock className="h-8 w-48 rounded-md" />
            <SkeletonBlock className="h-8 w-24 rounded-md" />
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {Array(3).fill(0).map((_, index) => (
              <TransactionCardSkeleton key={`tx-${index}`} />
            ))}
          </div>
        </div>
      </div>
    </div>
  );
};

export default LoadingDashboard;

================
File: components/dashboard/RecentTransactions.tsx
================
// src/components/dashboard/RecentTransactions.tsx
import React, { useMemo, useCallback } from 'react';
import { Link } from 'react-router-dom';
import { Transaction } from '@/types';
import { Button } from '@/components/ui/button';
import { PlusCircleIcon, ArrowUpRightIcon } from 'lucide-react';
import TransactionCard from '@/components/expense/TransactionCard';
import { useMediaQuery } from '@/hooks/useMediaQuery';

interface RecentTransactionsProps {
  transactions: Transaction[];
  maxItems?: number;
}

/**
 * Displays the most recent transactions in a grid layout
 * Optimized with memoization and stable callbacks to prevent unnecessary re-renders
 */
const RecentTransactions: React.FC<RecentTransactionsProps> = ({
  transactions,
  maxItems = 5
}) => {
  // Use the media query hook for responsive design
  const isMobile = useMediaQuery('(max-width: 768px)');
  
  // Optimize to only sort and slice without creating new objects
  // This avoids unnecessary object creation and deep cloning of transaction objects
  const recentTransactions = useMemo(() => {
    if (!transactions.length) return [];
    
    // Sort transactions by date (newest first) and take only what we need
    return transactions
      .slice(0, maxItems)
      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
  }, [transactions, maxItems]);
  
  // Render the empty state when no transactions are available
  const renderEmptyState = useCallback(() => {
    return (
      <div className="glass-card p-6 sm:p-8 text-center rounded-xl border border-border/50 bg-card hover:shadow-md transition-all">
        <p className="text-muted-foreground mb-4">No transactions recorded yet.</p>
        <Link to="/add-expense">
          <Button className={`btn-hover-effect bg-gradient-to-r from-[#6366f1] to-[#a855f7] ${!isMobile ? 'gap-2' : 'w-10 h-10 p-0'}`}>
            <PlusCircleIcon className={isMobile ? "h-4 w-4" : "mr-2 h-4 w-4"} />
            {!isMobile && <span>Record Your First Expense</span>}
          </Button>
        </Link>
      </div>
    );
  }, [isMobile]);
  
  // Removed console.log
  
  // Create a stable reference for the transaction cards
  const transactionCards = useMemo(() => {
    if (recentTransactions.length === 0) {
      return renderEmptyState();
    }
    
    return (
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {recentTransactions.map((transaction) => (
          <TransactionCard 
            key={transaction.id} 
            transaction={transaction}
            className="glass-card-elevated rounded-xl border border-border/50 bg-card hover:shadow-md hover:scale-[1.01] transition-all"
          />
        ))}
      </div>
    );
  }, [recentTransactions, renderEmptyState]);
  
  return (
    <div className="mt-6">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-2xl font-bold tracking-tight bg-clip-text text-transparent bg-gradient-to-r from-[#6366f1] to-[#a855f7]">
          Recent Transactions
        </h2>
        <Link to="/transactions" className="interactive-link text-primary flex items-center text-sm font-medium">
          View All <ArrowUpRightIcon className="ml-1 h-4 w-4" />
        </Link>
      </div>
      
      {transactionCards}
    </div>
  );
};

// Use memo to prevent unnecessary re-renders
export default React.memo(RecentTransactions);

================
File: components/dashboard/StatementCycleFilter.tsx
================
import { useState } from 'react';
import { Input } from '@/components/ui/input';
import { Calendar } from 'lucide-react';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";

interface StatementCycleFilterProps {
  useStatementMonth: boolean;
  setUseStatementMonth: (value: boolean) => void;
  statementCycleDay: number;
  setStatementCycleDay: (value: number) => void;
  className?: string;
}

const StatementCycleFilter = ({
  useStatementMonth,
  setUseStatementMonth,
  statementCycleDay,
  setStatementCycleDay,
  className = ''
}: StatementCycleFilterProps) => {
  
  const handleDayChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = parseInt(e.target.value);
    if (isNaN(value)) return;
    
    // Ensure the day is between 1 and 31
    const validDay = Math.max(1, Math.min(31, value));
    setStatementCycleDay(validDay);
  };
  
  return (
    <div className={`flex items-center h-full ${className}`}>
      <Calendar className="h-5 w-5 text-muted-foreground mr-2" />
      <Select
        value={useStatementMonth ? "statement" : "calendar"}
        onValueChange={(value) => setUseStatementMonth(value === "statement")}
      >
        <SelectTrigger className="w-[160px] h-8 text-sm bg-transparent border-none">
          <SelectValue placeholder="Calendar Month" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="statement">Statement Month</SelectItem>
          <SelectItem value="calendar">Calendar Month</SelectItem>
        </SelectContent>
      </Select>
      
      {useStatementMonth && (
        <div className="ml-2 flex items-center">
          <span className="text-sm text-muted-foreground mr-1">
            Day:
          </span>
          <Input
            id="statement-cycle-day"
            type="number"
            min={1}
            max={31}
            value={statementCycleDay}
            onChange={handleDayChange}
            className="h-8 w-14 text-xs px-2"
          />
        </div>
      )}
    </div>
  );
};

export default StatementCycleFilter;

================
File: components/dashboard/SummaryCard.tsx
================
// src/components/dashboard/SummaryCard.tsx
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { TrendingUpIcon, TrendingDownIcon } from 'lucide-react';

interface SummaryCardProps {
  /**
   * Card title displayed in the header
   */
  title: string;
  
  /**
   * Icon component to display next to the title
   */
  icon: React.ReactNode;
  
  /**
   * Primary value to display in the card
   */
  value: string;
  
  /**
   * Optional description text or component
   */
  description?: string | React.ReactNode;
  
  /**
   * Optional percentage trend value
   * Positive values show up/red, negative values show down/green
   */
  trend?: number;
  
  /**
   * Optional background color class for the card
   */
  cardColor?: string;
  
  /**
   * Optional text color class for the value
   */
  valueColor?: string;
  
  /**
   * Optional className for additional styling
   */
  className?: string;
}

/**
 * Reusable summary card component for displaying metric information
 * Supports trend indicators and custom styling
 */
const SummaryCard: React.FC<SummaryCardProps> = ({ 
  title, 
  icon, 
  value, 
  description, 
  trend, 
  cardColor = "bg-card",
  valueColor = "text-foreground",
  className = ""
}) => {
  // Format trend data with appropriate styling
  const renderTrend = () => {
    if (trend === undefined) return null;
    
    const isTrendPositive = trend >= 0;
    // For expenses, negative is good (spending less)
    const trendColor = isTrendPositive 
      ? "text-red-500 dark:text-red-400" 
      : "text-green-500 dark:text-green-400";
    const formattedTrend = `${isTrendPositive ? '+' : ''}${trend.toFixed(1)}%`;
    const TrendIcon = isTrendPositive ? TrendingUpIcon : TrendingDownIcon;
    
    return (
      <span className={`flex items-center gap-1 ${trendColor}`}>
        <TrendIcon className="h-3.5 w-3.5" />
        <span>{formattedTrend}</span>
      </span>
    );
  };

  return (
    <Card className={`summary-card overflow-hidden animate-fadeIn ${cardColor} ${className}`}>
      <CardHeader className="pb-2">
        <CardTitle className="text-xs font-medium text-muted-foreground uppercase tracking-wider flex items-center">
          {icon && <span className="mr-1.5">{icon}</span>}
          {title}
        </CardTitle>
        
        <div className="mt-2">
          <div 
            className={`text-2xl font-bold truncate ${valueColor}`}
            title={value} // Add title for tooltip on hover
          >
            {value}
          </div>
        </div>
      </CardHeader>
      
      <CardContent className="pt-0">
        <div className="text-xs text-muted-foreground flex items-center gap-1">
          {trend !== undefined ? renderTrend() : description}
        </div>
      </CardContent>
    </Card>
  );
};

export default React.memo(SummaryCard);

================
File: components/dashboard/SummaryCharts.tsx
================
import { Currency } from "@/types";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  PieChart,
  Pie,
  Cell,
  ResponsiveContainer,
  Tooltip,
  Legend,
  TooltipProps,
} from "recharts";
import { CreditCardIcon, TagIcon } from "lucide-react";
import { CurrencyService } from "@/services/CurrencyService";

interface ChartData {
  name: string;
  value: number;
  color: string;
}

interface SummaryChartsProps {
  paymentMethodChartData: Array<ChartData>;
  categoryChartData: Array<ChartData>;
  displayCurrency: Currency;
}

// Define the value and name types that will be used in TooltipProps
type ValueType = number;
type NameType = string;

// Define a formatter function type
type FormatterFunc = (value: ValueType) => string;

interface CustomTooltipProps {
  active?: boolean;
  payload?: Array<{
    name: string;
    value: ValueType;
    payload: {
      totalValue: number;
    };
  }>;
  formatter?: FormatterFunc;
}

const SummaryCharts = ({
  paymentMethodChartData,
  categoryChartData,
  displayCurrency,
}: SummaryChartsProps) => {
  // Custom tooltip component
  const CustomTooltip = ({
    active,
    payload,
    formatter,
  }: CustomTooltipProps) => {
    if (active && payload && payload.length) {
      return (
        <div className="bg-background border border-border p-3 rounded-md shadow-lg">
          <p className="font-medium text-sm mb-1">{payload[0].name}</p>
          <p className="text-primary font-bold">
            {formatter ? formatter(payload[0].value) : payload[0].value}
          </p>
          <p className="text-xs text-muted-foreground mt-1">
            {Math.round(
              (payload[0].value / payload[0].payload.totalValue) * 100
            )}
            % of total
          </p>
        </div>
      );
    }
    return null;
  };

  // Add total value to each data point for percentage calculation
  const prepareChartData = (data: ChartData[]) => {
    const totalValue = data.reduce((sum, item) => sum + item.value, 0);
    return data.map((item) => ({
      ...item,
      totalValue,
    }));
  };

  const preparedMethodData = prepareChartData(paymentMethodChartData);
  const preparedCategoryData = prepareChartData(categoryChartData);

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 min-h-[300px]">
      {/* Payment Methods Chart */}
      <Card className="rounded-xl border border-border/50 bg-card hover:shadow-md transition-all overflow-hidden">
        <CardHeader className="pb-2">
          <CardTitle className="text-xl flex items-center gap-2">
            <CreditCardIcon className="h-5 w-5 text-primary" />
            Payment Methods
          </CardTitle>
        </CardHeader>
        <CardContent>
          {preparedMethodData.length > 0 ? (
            <div className="w-full h-60 mt-2">
              <ResponsiveContainer width="100%" height="100%">
                <PieChart>
                  <Pie
                    data={preparedMethodData}
                    cx="50%"
                    cy="50%"
                    innerRadius={60}
                    outerRadius={80}
                    paddingAngle={2}
                    dataKey="value"
                  >
                    {preparedMethodData.map((entry, index) => (
                      <Cell
                        key={`cell-${index}`}
                        fill={entry.color}
                        stroke="var(--background)"
                        strokeWidth={2}
                      />
                    ))}
                  </Pie>
                  <Tooltip
                    content={
                      <CustomTooltip
                        formatter={(value: number) =>
                          CurrencyService.format(value, displayCurrency)
                        }
                      />
                    }
                  />
                  <Legend
                    layout="vertical"
                    verticalAlign="middle"
                    align="right"
                    formatter={(value, entry, index) => (
                      <span className="text-xs">{value}</span>
                    )}
                  />
                </PieChart>
              </ResponsiveContainer>
            </div>
          ) : (
            <div className="flex items-center justify-center h-60 text-muted-foreground">
              <p>No payment method data available</p>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Categories Chart */}
      <Card className="rounded-xl border border-border/50 bg-card hover:shadow-md transition-all overflow-hidden">
        <CardHeader className="pb-2">
          <CardTitle className="text-xl flex items-center gap-2">
            <TagIcon className="h-5 w-5 text-primary" />
            Expense Categories
          </CardTitle>
        </CardHeader>
        <CardContent>
          {preparedCategoryData.length > 0 ? (
            <div className="w-full h-60 mt-2">
              <ResponsiveContainer width="100%" height="100%">
                <PieChart>
                  <Pie
                    data={preparedCategoryData}
                    cx="50%"
                    cy="50%"
                    innerRadius={60}
                    outerRadius={80}
                    paddingAngle={2}
                    dataKey="value"
                  >
                    {preparedCategoryData.map((entry, index) => (
                      <Cell
                        key={`cell-${index}`}
                        fill={entry.color}
                        stroke="var(--background)"
                        strokeWidth={2}
                      />
                    ))}
                  </Pie>
                  <Tooltip
                    content={
                      <CustomTooltip
                        formatter={(value: number) =>
                          CurrencyService.format(value, displayCurrency)
                        }
                      />
                    }
                  />
                  <Legend
                    layout="vertical"
                    verticalAlign="middle"
                    align="right"
                    formatter={(value, entry, index) => (
                      <span className="text-xs">{value}</span>
                    )}
                  />
                </PieChart>
              </ResponsiveContainer>
            </div>
          ) : (
            <div className="flex items-center justify-center h-60 text-muted-foreground">
              <p>No category data available</p>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
};

export default SummaryCharts;

================
File: components/dashboard/SummarySection.tsx
================
// src/components/dashboard/SummarySection.tsx
import React from 'react';
import { useDashboardContext } from '@/contexts/DashboardContext';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import SummaryCard from './SummaryCard';
import { BarChartIcon, ArrowDownLeftIcon } from 'lucide-react';
import { useCurrencyFormatter } from '@/hooks/useCurrencyFormatter';

/**
 * Displays summary cards with key metrics for the dashboard
 * Uses the Dashboard context instead of props
 */
const SummarySection: React.FC = () => {
  const {
    dashboardData,
    displayCurrency,
    activeTab,
    setActiveTab
  } = useDashboardContext();

  // Use the custom currency formatter hook
  const { formatCurrency } = useCurrencyFormatter(displayCurrency);

  // Ensure we have valid data structure to prevent errors
  const metrics = dashboardData?.metrics || {
    totalExpenses: 0,
    transactionCount: 0,
    averageAmount: 0,
    totalRewardPoints: 0,
    percentageChange: 0,
    totalReimbursed: 0
  };
  
  const filteredTransactions = dashboardData?.filteredTransactions || [];
  
  // Calculate count of transactions with reimbursements
  const reimbursedTransactionsCount = React.useMemo(() => {
    if (!filteredTransactions.length) return 0;
    
    return filteredTransactions.reduce((count, tx) => 
      (tx.reimbursementAmount || 0) > 0 ? count + 1 : count, 0);
  }, [filteredTransactions]);

  // Calculate net expenses (total expenses minus reimbursements)
  const netExpenses = (metrics?.totalExpenses || 0) - (metrics?.totalReimbursed || 0);

  // Handle tab change
  const handleTabChange = React.useCallback((value: string) => {
    setActiveTab(value as any);
  }, [setActiveTab]);

  return (
    <div className="space-y-4 w-full">
      <Tabs 
        defaultValue={activeTab || 'thisMonth'}
        value={activeTab || 'thisMonth'}
        onValueChange={handleTabChange}
        className="w-full"
      >
        {/* Always render content regardless of tab selection */}
        <TabsContent 
          value={activeTab || 'thisMonth'} 
          className="mt-4 space-y-4 animate-fadeIn"
          forceMount
        >
          {/* Summary Cards - Removed specified cards and rearranged grid */}
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
            {/* Net Expenses Card */}
            <SummaryCard
              title="Net Expenses"
              icon={<BarChartIcon className="h-5 w-5 text-primary" />}
              value={formatCurrency(netExpenses)}
              trend={metrics?.percentageChange || 0}
              cardColor="bg-gradient-to-br from-violet-500/10 to-purple-600/10"
              valueColor="text-violet-800 dark:text-violet-300"
            />
            
            {/* Reimbursements Card */}
            <SummaryCard
              title="Reimbursements"
              icon={<ArrowDownLeftIcon className="h-5 w-5 text-primary" />}
              value={formatCurrency(metrics?.totalReimbursed || 0)}
              description={`From ${reimbursedTransactionsCount} transactions`}
              cardColor="bg-gradient-to-br from-green-500/10 to-emerald-600/10"
              valueColor="text-green-800 dark:text-green-300"
            />
          </div>
        </TabsContent>
      </Tabs>
    </div>
  );
};

export default React.memo(SummarySection);

================
File: contexts/DashboardContext.tsx
================
// src/contexts/DashboardContext.tsx
import React, { createContext, useContext, ReactNode } from 'react';
import { Transaction, PaymentMethod, Currency } from '@/types';
import { DashboardData } from '@/types/dashboard';
import { TimeframeTab } from '@/utils/transactionProcessor';

export interface DashboardContextState {
  // Data state
  transactions: Transaction[];
  paymentMethods: PaymentMethod[];
  dashboardData: DashboardData | null;
  isLoading: boolean;
  error: string | null;
  lastUpdate: number;

  // Filter state
  activeTab: TimeframeTab;
  displayCurrency: Currency;
  useStatementMonth: boolean;
  statementCycleDay: number;

  // Action handlers
  refreshData: () => Promise<void>;
  setActiveTab: (tab: TimeframeTab) => void;
  setDisplayCurrency: (currency: Currency) => void;
  setUseStatementMonth: (use: boolean) => void;
  setStatementCycleDay: (day: number) => void;
}

// Create context with a default undefined value
const DashboardContext = createContext<DashboardContextState | undefined>(undefined);

// Custom hook to use the dashboard context
export function useDashboardContext() {
  const context = useContext(DashboardContext);
  if (context === undefined) {
    throw new Error('useDashboardContext must be used within a DashboardProvider');
  }
  return context;
}

// Provider props type
interface DashboardProviderProps {
  children: ReactNode;
}

// The actual Provider component will be implemented in DashboardProvider.tsx

export { DashboardContext };
export type { DashboardProviderProps };

================
File: hooks/dashboard/useDashboardData.ts
================
// src/hooks/dashboard/useDashboardData.ts
import { useState, useEffect, useCallback } from 'react';
import { Transaction, PaymentMethod, Currency } from '@/types';
import { DashboardData, DashboardOptions } from '@/types/dashboard';
import { getTransactions, getPaymentMethods } from '@/utils/storageUtils';
import { supabase, USE_LOCAL_STORAGE_DEFAULT } from '@/integrations/supabase/client';
import { useDashboard } from '@/hooks/useDashboard';
import { TimeframeTab } from '@/utils/transactionProcessor';
import { tryCatchWrapper, ErrorType } from '@/utils/errorHandling';

export function useDashboardData(
  defaultTimeframe: TimeframeTab = 'thisMonth',
  defaultCurrency: Currency = 'SGD',
  defaultUseStatementMonth: boolean = false,
  defaultStatementCycleDay: number = 15
) {
  // State for data
  const [transactions, setTransactions] = useState<Transaction[]>([]);
  const [paymentMethods, setPaymentMethods] = useState<PaymentMethod[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [lastUpdate, setLastUpdate] = useState<number>(Date.now());
  
  // State for filters
  const [activeTab, setActiveTab] = useState<TimeframeTab>(defaultTimeframe);
  const [displayCurrency, setDisplayCurrency] = useState<Currency>(defaultCurrency);
  const [useStatementMonth, setUseStatementMonth] = useState<boolean>(defaultUseStatementMonth);
  const [statementCycleDay, setStatementCycleDay] = useState<number>(defaultStatementCycleDay);

  // Build dashboard options
  const dashboardOptions: DashboardOptions = {
    transactions,
    displayCurrency,
    timeframe: activeTab,
    useStatementMonth,
    statementCycleDay,
    calculateDayOfWeekMetrics: transactions.length > 0,
    lastUpdate
  };

  // Get dashboard data
  const dashboardData = useDashboard(dashboardOptions);

  // Load dashboard data with proper error handling
  const loadData = useCallback(async () => {
    try {
      setIsLoading(true);
      
      // Get payment methods with error handling wrapper
      const loadedPaymentMethods = await tryCatchWrapper(
        async () => getPaymentMethods(),
        ErrorType.DATA_FETCH,
        { source: 'getPaymentMethods' },
        [] as PaymentMethod[]
      );
      
      // Get transactions with error handling wrapper
      const allTransactions = await tryCatchWrapper(
        async () => getTransactions(USE_LOCAL_STORAGE_DEFAULT),
        ErrorType.DATA_FETCH,
        { source: 'getTransactions' },
        [] as Transaction[]
      );
      
      // Filter out deleted transactions
      const loadedTransactions = allTransactions.filter(tx => !tx.is_deleted);
      
      setTransactions(loadedTransactions);
      setPaymentMethods(loadedPaymentMethods);
      setError(null);
      setLastUpdate(Date.now());
    } catch (error) {
      console.error('Error loading data:', error);
      setError('Failed to load dashboard data');
    } finally {
      setIsLoading(false);
    }
  }, []);
  
  // Set up Supabase realtime subscription for data updates
  useEffect(() => {
    // Load data immediately when component mounts
    loadData();
    
    // Set up real-time subscriptions
    const channel = supabase
      .channel('dashboard_transactions')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'transactions'
      }, () => {
        // Force reload on any transaction changes
        loadData();
      })
      .subscribe();
    
    // Cleanup: unsubscribe on component unmount
    return () => {
      supabase.removeChannel(channel);
    };
  }, [loadData]);

  return {
    // Data state
    transactions,
    paymentMethods,
    dashboardData,
    isLoading,
    error,
    lastUpdate,

    // Filter state
    activeTab,
    displayCurrency,
    useStatementMonth,
    statementCycleDay,

    // Action handlers
    refreshData: loadData,
    setActiveTab,
    setDisplayCurrency,
    setUseStatementMonth,
    setStatementCycleDay
  };
}

================
File: hooks/expense-form/formSchema.ts
================
import { z } from 'zod';
import { MerchantCategoryCode } from '@/types';

// Form schema definition
export const formSchema = z.object({
  merchantName: z.string().min(1, 'Merchant name is required'),
  merchantAddress: z.string().optional(),
  isOnline: z.boolean().default(false),
  isContactless: z.boolean().default(false),
  amount: z.string().min(1, 'Amount is required').refine(value => !isNaN(Number(value)) && Number(value) > 0, {
    message: 'Amount must be a positive number',
  }),
  currency: z.string().min(1, 'Currency is required'),
  paymentMethodId: z.string().min(1, 'Payment method is required'),
  paymentAmount: z.string().refine(value => !isNaN(Number(value)) && Number(value) >= 0, {
    message: 'Payment amount must be a non-negative number',
  }).optional(),
  reimbursementAmount: z.string().refine(value => value === '' || (!isNaN(Number(value)) && Number(value) >= 0), {
    message: 'Reimbursement amount must be a non-negative number',
  }).default('0'),
  date: z.date({
    required_error: 'Date is required',
  }),
  notes: z.string().optional(),
  mcc: z.any().optional(),
});

export type FormValues = z.infer<typeof formSchema>;

================
File: hooks/expense-form/useMerchantData.ts
================
import { useCallback, useEffect, useState } from 'react';
import { MerchantCategoryCode } from '@/types';
import { UseFormReturn } from 'react-hook-form';
import { FormValues } from './formSchema';
import { getMerchantByName } from '@/utils/storageUtils';
import { getSuggestedMerchantCategory, hasMerchantCategorySuggestions } from '@/utils/storage/merchantTracking';

export const useMerchantData = (
  form: UseFormReturn<FormValues>,
  merchantName: string
) => {
  const [selectedMCC, setSelectedMCC] = useState<MerchantCategoryCode | undefined>();
  const [suggestionChecked, setSuggestionChecked] = useState(false);

  // Memoize merchant fetch to prevent excessive rerenders
  const fetchMerchant = useCallback(async (name: string) => {
    if (name && name.trim().length >= 3) {
      try {
        // First check if we have a merchant in database
        const existingMerchant = await getMerchantByName(name);
        if (existingMerchant?.mcc) {
          setSelectedMCC(existingMerchant.mcc);
          form.setValue('mcc', existingMerchant.mcc);
          return; // Exit if we found merchant with MCC
        }
        
        // If no merchant with MCC is found, check our mappings
        if (!suggestionChecked) {
          setSuggestionChecked(true);
          
          // Check if this merchant name has suggestions enabled and is not deleted
          const hasSuggestions = await hasMerchantCategorySuggestions(name);
          if (hasSuggestions) {
            const suggestedMCC = await getSuggestedMerchantCategory(name);
            if (suggestedMCC && (!selectedMCC || suggestedMCC.code !== selectedMCC.code)) {
              setSelectedMCC(suggestedMCC);
              form.setValue('mcc', suggestedMCC);
              return true; // Return true to indicate we found a suggestion
            }
          }
        }
        
        return false; // Return false to indicate no suggestion found
      } catch (error) {
        console.error('Error fetching merchant:', error);
        return false;
      }
    }
    return false;
  }, [form, selectedMCC, suggestionChecked]);

  // Debounce merchant fetch to avoid excessive API calls
  useEffect(() => {
    if (merchantName.trim().length < 3) {
      setSuggestionChecked(false); // Reset when merchant name changes significantly
      return;
    }
    
    const timer = setTimeout(() => {
      fetchMerchant(merchantName);
    }, 300); // 300ms debounce
    
    return () => clearTimeout(timer);
  }, [merchantName, fetchMerchant]);

  return { 
    selectedMCC, 
    setSelectedMCC,
    hasSuggestion: suggestionChecked
  };
};

================
File: hooks/expense-form/usePaymentMethodLogic.ts
================
import { useCallback, useEffect, useState } from 'react';
import { UseFormReturn } from 'react-hook-form';
import { PaymentMethod, Currency } from '@/types';
import { FormValues } from './formSchema';
import { findCashPaymentMethodForCurrency } from '@/utils/defaults/paymentMethods';

export const usePaymentMethodLogic = (
  form: UseFormReturn<FormValues>,
  paymentMethods: PaymentMethod[],
  currency: Currency,
  amount: number,
  isOnline: boolean
) => {
  const [selectedPaymentMethod, setSelectedPaymentMethod] = useState<PaymentMethod | undefined>();
  const [shouldOverridePayment, setShouldOverridePayment] = useState(false);
  
  const paymentMethodId = form.watch('paymentMethodId');

  // Initialize selected payment method based on stored payment methods
  useEffect(() => {
    if (paymentMethods.length > 0 && !paymentMethodId) {
      // Find default cash payment method for the selected currency
      const cashMethod = findCashPaymentMethodForCurrency(currency);
      if (cashMethod) {
        form.setValue('paymentMethodId', cashMethod.id);
        form.trigger('paymentMethodId');
      } else {
        // Use the first payment method as fallback
        form.setValue('paymentMethodId', paymentMethods[0].id);
        form.trigger('paymentMethodId');
      }
    }
  }, [paymentMethods, form, paymentMethodId, currency]);

  // Update payment method when currency changes
  useEffect(() => {
    if (currency && !paymentMethodId) {
      const cashMethod = findCashPaymentMethodForCurrency(currency);
      if (cashMethod) {
        form.setValue('paymentMethodId', cashMethod.id);
        form.trigger('paymentMethodId');
      }
    }
  }, [currency, form, paymentMethodId]);

  // Handle payment method selection changes - memoized to prevent excessive rerenders
  const updateSelectedPaymentMethod = useCallback(() => {
    if (paymentMethodId) {
      const method = paymentMethods.find(pm => pm.id === paymentMethodId);
      
      if (method) {
        setSelectedPaymentMethod(method);
        
        // Check if we need to handle currency conversion
        if (currency !== method.currency) {
          setShouldOverridePayment(true);
          
          // Set initial payment amount only if amount has changed
          if (amount > 0) {
            const conversionRates: Record<string, Record<string, number>> = {
              USD: { SGD: 1.35, EUR: 0.92, GBP: 0.78 },
              SGD: { USD: 0.74, EUR: 0.68, GBP: 0.58 },
              EUR: { USD: 1.09, SGD: 1.47, GBP: 0.85 },
              GBP: { USD: 1.28, SGD: 1.73, EUR: 1.17 }
            };
            
            const rate = conversionRates[currency]?.[method.currency] || 1;
            const convertedAmount = (amount * rate).toFixed(2);
            form.setValue('paymentAmount', convertedAmount);
          }
        } else {
          setShouldOverridePayment(false);
          form.setValue('paymentAmount', form.watch('amount'));
        }
        
        // Set contactless for credit cards when not online
        if (!isOnline && method.type === 'credit_card') {
          form.setValue('isContactless', true);
        }
      } else {
        setSelectedPaymentMethod(undefined);
        setShouldOverridePayment(false);
      }
    } else {
      setSelectedPaymentMethod(undefined);
      setShouldOverridePayment(false);
    }
  }, [currency, paymentMethodId, form, paymentMethods, amount, isOnline]);

  // Call the memoized update function when dependencies change
  useEffect(() => {
    updateSelectedPaymentMethod();
  }, [updateSelectedPaymentMethod]);

  return {
    selectedPaymentMethod,
    shouldOverridePayment,
  };
};

================
File: hooks/expense-form/useRewardPoints.ts
================
// src/hooks/expense-form/useRewardPoints.ts
import { useState } from 'react';
import { PaymentMethod } from '@/types';
import { rewardCalculationService } from '@/services/RewardCalculationService';
import { bonusPointsTrackingService } from '@/services/BonusPointsTrackingService';
import { simulateRewardPoints } from '@/utils/rewards/rewardCalculationAdapter';

// Define return type for clearer API
export interface PointsSimulationResult {
  totalPoints: number;
  basePoints?: number;
  bonusPoints?: number;
  remainingMonthlyBonusPoints?: number;
  messageText?: string;
  pointsCurrency?: string;
  isLoading?: boolean;
  error?: string;
}

export const useRewardPoints = () => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | undefined>(undefined);

  /**
   * Simulate points for a transaction based on the given parameters
   */
  const simulatePoints = async (
    amount: number,
    currency: string,
    paymentMethod: PaymentMethod,
    mcc?: string,
    merchantName?: string,
    isOnline?: boolean,
    isContactless?: boolean
  ): Promise<PointsSimulationResult> => {
    // Reset state
    setIsLoading(true);
    setError(undefined);
    
    try {
      // Use the adapter function which handles both calculation and error handling
      const result = await simulateRewardPoints(
        amount,
        currency,
        paymentMethod,
        mcc,
        merchantName,
        isOnline,
        isContactless,
        new Date() // Use current date
      );
      
      return {
        ...result,
        isLoading: false
      };
    } catch (err) {
      // Handle any unexpected errors
      const errorMessage = err instanceof Error ? err.message : 'Error calculating reward points';
      setError(errorMessage);
      console.error('Error in simulatePoints hook:', err);
      
      // Return fallback result with error - using Math.round for proper rounding
      return {
        totalPoints: Math.round(amount),
        basePoints: Math.round(amount),
        bonusPoints: 0,
        error: errorMessage,
        isLoading: false,
        pointsCurrency: rewardCalculationService.getPointsCurrency(paymentMethod)
      };
    } finally {
      setIsLoading(false);
    }
  };

  /**
   * Synchronous version for immediate UI feedback
   * Less accurate (doesn't account for used bonus points) but faster
   */
  const estimatePointsSync = (
    amount: number,
    currency: string,
    paymentMethod: PaymentMethod,
    mcc?: string,
    merchantName?: string,
    isOnline?: boolean,
    isContactless?: boolean
  ): PointsSimulationResult => {
    if (paymentMethod.type === 'cash') {
      return { totalPoints: 0 };
    }
    
    try {
      // Use synchronous calculation (doesn't account for used bonus points)
      const result = rewardCalculationService.simulatePoints(
        amount,
        currency,
        paymentMethod,
        mcc,
        merchantName,
        isOnline,
        isContactless,
        0 // Assume 0 used bonus points for synchronous calculation
      );
      
      return {
        ...result,
        pointsCurrency: rewardCalculationService.getPointsCurrency(paymentMethod)
      };
    } catch (err) {
      // Return fallback result for sync calculation - using Math.round for proper rounding
      return {
        totalPoints: Math.round(amount),
        basePoints: Math.round(amount),
        bonusPoints: 0,
        pointsCurrency: rewardCalculationService.getPointsCurrency(paymentMethod)
      };
    }
  };

  return { 
    simulatePoints,
    estimatePointsSync,
    isLoading,
    error
  };
};

================
File: hooks/transaction-list/types.ts
================
import { Transaction, PaymentMethod } from '@/types';

export type FilterOptions = {
  merchantName: string;
  paymentMethodId: string;
  currency: string;
  startDate: string;
  endDate: string;
};

export type SortOption = 'date-desc' | 'date-asc' | 'amount-desc' | 'amount-asc';

================
File: hooks/transaction-list/useTransactionData.ts
================
import { useState, useEffect, useCallback } from 'react';
import { Transaction, PaymentMethod } from '@/types';
import { getTransactions, getPaymentMethods } from '@/utils/storageUtils';
import { useToast } from '@/hooks/use-toast';
import { supabase, USE_LOCAL_STORAGE_DEFAULT } from '@/integrations/supabase/client';

export const useTransactionData = () => {
  const { toast } = useToast();
  const [transactions, setTransactions] = useState<Transaction[]>([]);
  const [paymentMethods, setPaymentMethods] = useState<PaymentMethod[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  // Function to load transactions
  const loadTransactions = useCallback(async () => {
    try {
      setIsLoading(true);
      console.log('Loading transactions with forceLocalStorage:', USE_LOCAL_STORAGE_DEFAULT);
      
      // Use the global setting for storage preference
      const loadedTransactions = await getTransactions(USE_LOCAL_STORAGE_DEFAULT);
      const loadedPaymentMethods = await getPaymentMethods();
      
      console.log('Loaded transactions:', loadedTransactions.length);
      setTransactions(loadedTransactions);
      setPaymentMethods(loadedPaymentMethods);
    } catch (error) {
      console.error('Error loading data:', error);
      toast({
        title: 'Error',
        description: 'Failed to load transaction data',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  }, [toast]);
  
  // Set up Supabase listener only once on mount
  useEffect(() => {
    // Initial load
    loadTransactions();
    
    // Only set up the Supabase channel if we're not defaulting to local storage
    const channel = !USE_LOCAL_STORAGE_DEFAULT ? supabase
      .channel('public:transactions')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'transactions'
      }, () => {
        // When any transaction changes, reload the transactions
        loadTransactions();
      })
      .subscribe() : null;
    
    return () => {
      if (channel) supabase.removeChannel(channel);
    };
  }, [loadTransactions]);

  return {
    transactions,
    setTransactions,
    paymentMethods,
    isLoading,
    refreshTransactions: loadTransactions
  };
};

================
File: hooks/transaction-list/useTransactionFilters.ts
================
import { useState, useEffect, useMemo } from 'react';
import { Transaction, Currency } from '@/types';
import { SortOption } from '@/components/transaction/TransactionSortAndView';
import { FilterOptions } from '@/components/transaction/TransactionFilters';
import { getStatementPeriod } from '@/utils/dateUtils';

const initialFilterOptions: FilterOptions = {
  merchantName: '',
  paymentMethodId: 'all', // Changed from empty string to 'all'
  currency: 'all', // Changed from empty string to 'all'
  startDate: '',
  endDate: '',
};

export const useTransactionFilters = (transactions: Transaction[], isLoading: boolean) => {
  const [sortOption, setSortOption] = useState<SortOption>('date-desc');
  const [searchQuery, setSearchQuery] = useState('');
  const [filterOptions, setFilterOptions] = useState<FilterOptions>(initialFilterOptions);
  const [useStatementMonth, setUseStatementMonth] = useState(false);
  const [statementCycleDay, setStatementCycleDay] = useState(15); // Default to 15th

  // Reset filters when transactions load
  useEffect(() => {
    if (!isLoading && transactions.length > 0) {
      setFilterOptions(initialFilterOptions);
    }
  }, [isLoading, transactions.length]);

  const handleFilterChange = (key: keyof FilterOptions, value: string) => {
    setFilterOptions(prev => ({ ...prev, [key]: value }));
  };

  const resetFilters = () => {
    setFilterOptions(initialFilterOptions);
    setSearchQuery('');
    setUseStatementMonth(false);
  };

  // Get active filters for displaying in UI
  const activeFilters = useMemo(() => {
    const filters: string[] = [];

    if (searchQuery) {
      filters.push(`Search: ${searchQuery}`);
    }

    if (filterOptions.merchantName) {
      filters.push(`Merchant: ${filterOptions.merchantName}`);
    }

    if (filterOptions.paymentMethodId && filterOptions.paymentMethodId !== 'all') {
      const method = transactions.find(t => t.paymentMethod.id === filterOptions.paymentMethodId)?.paymentMethod.name;
      if (method) filters.push(`Payment Method: ${method}`);
    }

    if (filterOptions.currency && filterOptions.currency !== 'all') {
      filters.push(`Currency: ${filterOptions.currency}`);
    }

    if (filterOptions.startDate) {
      filters.push(`From: ${filterOptions.startDate}`);
    }

    if (filterOptions.endDate) {
      filters.push(`To: ${filterOptions.endDate}`);
    }

    if (useStatementMonth) {
      filters.push(`Statement Cycle: Day ${statementCycleDay}`);
    }

    return filters;
  }, [filterOptions, searchQuery, transactions, useStatementMonth, statementCycleDay]);

  // Calculate statement period dates
  const statementPeriod = useMemo(() => {
    if (!useStatementMonth) return null;
    
    // Create a pseudo payment method with statement settings
    const pseudoMethod = {
      statementStartDay: statementCycleDay,
      isMonthlyStatement: true
    };
    
    return getStatementPeriod(pseudoMethod as any);
  }, [useStatementMonth, statementCycleDay]);

  // Apply filters and sort
  const filteredTransactions = useMemo(() => {
    if (isLoading) return [];

    // Debug log to check currencies
    console.log('Available currencies in transactions:', 
      [...new Set(transactions.map(tx => tx.currency))]);

    // Filter by search query
    let filtered = transactions;
    
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(tx => 
        tx.merchant.name.toLowerCase().includes(query) ||
        (tx.notes && tx.notes.toLowerCase().includes(query))
      );
    }
    
    // Apply filters
    if (filterOptions.merchantName) {
      const merchantQuery = filterOptions.merchantName.toLowerCase();
      filtered = filtered.filter(tx => 
        tx.merchant.name.toLowerCase().includes(merchantQuery)
      );
    }
    
    if (filterOptions.paymentMethodId && filterOptions.paymentMethodId !== 'all') {
      filtered = filtered.filter(tx => 
        tx.paymentMethod.id === filterOptions.paymentMethodId
      );
    }
    
    if (filterOptions.currency && filterOptions.currency !== 'all') {
      filtered = filtered.filter(tx => 
        tx.currency === filterOptions.currency
      );
    }
    
    if (filterOptions.startDate) {
      const startDate = new Date(filterOptions.startDate);
      startDate.setHours(0, 0, 0, 0);
      filtered = filtered.filter(tx => {
        const txDate = new Date(tx.date);
        return txDate >= startDate;
      });
    }
    
    if (filterOptions.endDate) {
      const endDate = new Date(filterOptions.endDate);
      endDate.setHours(23, 59, 59, 999);
      filtered = filtered.filter(tx => {
        const txDate = new Date(tx.date);
        return txDate <= endDate;
      });
    }
    
    // Apply statement cycle filter
    if (useStatementMonth && statementPeriod) {
      filtered = filtered.filter(tx => {
        const txDate = new Date(tx.date);
        return txDate >= statementPeriod.start && txDate <= statementPeriod.end;
      });
      
      console.log(`Statement period: ${statementPeriod.start.toISOString()} to ${statementPeriod.end.toISOString()}`);
      console.log(`Filtered to ${filtered.length} transactions in statement period`);
    }
    
    // Apply sorting
    return [...filtered].sort((a, b) => {
      if (sortOption === 'date-desc') {
        return new Date(b.date).getTime() - new Date(a.date).getTime();
      } else if (sortOption === 'date-asc') {
        return new Date(a.date).getTime() - new Date(b.date).getTime();
      } else if (sortOption === 'amount-desc') {
        return b.amount - a.amount;
      } else {
        return a.amount - b.amount;
      }
    });
  }, [isLoading, transactions, searchQuery, filterOptions, sortOption, useStatementMonth, statementPeriod]);

  return {
    filteredTransactions,
    sortOption,
    setSortOption,
    searchQuery,
    setSearchQuery,
    filterOptions,
    handleFilterChange,
    activeFilters,
    resetFilters,
    useStatementMonth,
    setUseStatementMonth,
    statementCycleDay,
    setStatementCycleDay
  };
};

================
File: hooks/use-debounce.ts
================
import { useState, useEffect } from 'react';

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

================
File: hooks/use-mobile.tsx
================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}

================
File: hooks/use-toast.ts
================
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

================
File: hooks/useCardAnalytics.ts
================
import { useState, useEffect } from 'react';
import { PaymentMethod, Transaction } from '@/types';
import { getTransactions } from '@/utils/storageUtils';

export const useCardAnalytics = (selectedPaymentMethod: PaymentMethod | undefined) => {
  // State for transactions
  const [transactions, setTransactions] = useState<Transaction[]>([]);
  
  // State for UOB Visa Signature calculation
  const [nonSgdSpendTotal, setNonSgdSpendTotal] = useState<number>(0);
  const [hasSgdTransactions, setHasSgdTransactions] = useState<boolean>(false);
  
  // State for bonus points tracking
  const [usedBonusPoints, setUsedBonusPoints] = useState<number>(0);
  
  // Load transactions
  useEffect(() => {
    const loadTransactions = async () => {
      try {
        const allTransactions = await getTransactions();
        setTransactions(allTransactions);
      } catch (error) {
        console.error('Error loading transactions:', error);
        setTransactions([]);
      }
    };
    
    loadTransactions();
  }, []);

  // Calculate card-specific metrics based on transactions
  useEffect(() => {
    if (!selectedPaymentMethod) return;
    
    // Calculate for UOB Visa Signature
    if (selectedPaymentMethod?.issuer === 'UOB' && selectedPaymentMethod?.name === 'Visa Signature' && transactions.length > 0) {
      let statementTotal = 0;
      let hasAnySgdTransaction = false;
      
      const statementTransactions = transactions.filter(tx => 
        tx.paymentMethod.id === selectedPaymentMethod.id
      );
      
      statementTransactions.forEach(tx => {
        if (tx.currency === 'SGD') {
          hasAnySgdTransaction = true;
        } else {
          statementTotal += tx.paymentAmount;
        }
      });
      
      setNonSgdSpendTotal(statementTotal);
      setHasSgdTransactions(hasAnySgdTransaction);
    }
    
    // Calculate bonus points used for UOB Preferred Platinum and Citibank Rewards
    if (((selectedPaymentMethod?.issuer === 'UOB' && selectedPaymentMethod?.name === 'Preferred Visa Platinum') ||
        (selectedPaymentMethod?.issuer === 'Citibank' && selectedPaymentMethod?.name === 'Rewards Visa Signature') ||
        (selectedPaymentMethod?.issuer === 'American Express')) && 
        transactions.length > 0) {
      
      const currentDate = new Date();
      let totalMonthBonusPoints = 0;
      
      const currentMonthTransactions = transactions.filter(tx => {
        const txDate = new Date(tx.date);
        return tx.paymentMethod.id === selectedPaymentMethod.id && 
               txDate.getMonth() === currentDate.getMonth() &&
               txDate.getFullYear() === currentDate.getFullYear();
      });
      
      currentMonthTransactions.forEach(tx => {
        if (tx.rewardPoints > 0) {
          // Different multipliers based on card type
          let multiplier = 1;
          let baseMultiplier = 0.4;
          
          if (selectedPaymentMethod.issuer === 'UOB') {
            multiplier = 5;
            baseMultiplier = 0.4;
          } else if (selectedPaymentMethod.issuer === 'Citibank') {
            multiplier = 1;
            baseMultiplier = 0.4;
          } else if (selectedPaymentMethod.issuer === 'American Express') {
            multiplier = 1;
            baseMultiplier = 1.25; // $1.60 = 2 points => 2/1.6 = 1.25 points per dollar
          }
          
          const txAmount = Math.floor(tx.amount / multiplier) * multiplier;
          const basePoints = Math.round(txAmount * baseMultiplier);
          const bonusPoints = Math.max(0, tx.rewardPoints - basePoints);
          totalMonthBonusPoints += bonusPoints;
        }
      });
      
      // Apply cap (if applicable)
      let cap = 4000; // Default cap for UOB and Citibank
      
      // American Express cards have no cap
      if (selectedPaymentMethod.issuer === 'American Express') {
        cap = Number.MAX_SAFE_INTEGER;
      }
      
      setUsedBonusPoints(Math.min(totalMonthBonusPoints, cap));
    }
  }, [selectedPaymentMethod, transactions]);

  return {
    nonSgdSpendTotal,
    hasSgdTransactions,
    usedBonusPoints
  };
};

================
File: hooks/useChartData.ts
================
// src/hooks/useChartData.ts
import { useMemo } from 'react';
import { Transaction, Currency, PaymentMethod } from '@/types';
import { 
  processPieChartData, 
  processTransactionsForChart, 
  ChartProcessingResult
} from '@/utils/chartDataProcessor';
import { ChartDataItem } from '@/utils/dashboardUtils';

/**
 * Hook for generating pie chart data from transactions
 * 
 * @param transactions - Array of transactions to visualize
 * @param groupByField - Field to group by (e.g., 'paymentMethod', 'category')
 * @param displayCurrency - Currency to display values in
 * @returns Array of formatted chart data items
 */
export function usePieChartData(
  transactions: Transaction[],
  groupByField: 'paymentMethod' | 'category' | string,
  displayCurrency: Currency
): ChartDataItem[] {
  return useMemo(() => {
    return processPieChartData(
      transactions,
      groupByField,
      displayCurrency
    );
  }, [transactions, groupByField, displayCurrency]);
}

/**
 * Hook for generating spending trend data
 * 
 * @param transactions - Transactions to analyze
 * @param period - Time period for grouping (week, month, quarter, year)
 * @param options - Additional chart processing options
 * @returns Processed chart data with trends and insights
 */
export function useSpendingTrendData(
  transactions: Transaction[],
  period: 'day' | 'week' | 'month' | 'quarter' = 'month',
  options: { 
    includeCategoryBreakdown?: boolean;
    maxTopCategories?: number;
    displayCurrency?: Currency; 
  } = {}
): ChartProcessingResult {
  // Extract options with defaults to use as direct dependencies
  const includeCategoryBreakdown = options.includeCategoryBreakdown ?? true;
  const maxTopCategories = options.maxTopCategories ?? 3;
  const displayCurrency = options.displayCurrency ?? 'SGD';
  
  return useMemo(() => {
    return processTransactionsForChart(transactions, {
      period,
      includeCategoryBreakdown,
      maxTopCategories,
      includeTrend: true,
      displayCurrency
    });
  }, [
    transactions, 
    period, 
    includeCategoryBreakdown, 
    maxTopCategories, 
    displayCurrency
  ]);
}

/**
 * Interface for card optimization suggestions
 */
export interface CardSuggestion {
  /** Category name where optimization is possible */
  category: string;
  /** Number of transactions in this category */
  transactionCount: number;
  /** Currently used payment method */
  currentMethod: string;
  /** Recommended payment method for better rewards */
  suggestedMethod: string;
  /** Estimated monthly savings/additional rewards when using suggested method */
  potentialSavings: number;
}

// Constants for optimization calculations
const MINIMUM_TRANSACTIONS_PER_CATEGORY = 3;
const DEFAULT_REWARD_RATE = 1; // Assume standard 1x points for baseline comparison
const SAVINGS_MULTIPLIER = 0.01; // Convert percentage to decimal (1% = 0.01)

/**
 * Hook for generating payment method optimization recommendations
 * Analyzes transaction patterns and suggests better card choices per category
 * Optimized for performance with large datasets
 * 
 * @param transactions - Array of transactions to analyze
 * @param paymentMethods - Available payment methods to consider
 * @returns Array of card optimization suggestions
 */
export function usePaymentMethodOptimization(
  transactions: Transaction[],
  paymentMethods: PaymentMethod[]
): CardSuggestion[] {
  return useMemo(() => {
    // Skip processing if there's insufficient data (early return)
    if (transactions.length === 0 || paymentMethods.length < 2) {
      return [];
    }

    // Pre-processing: Cache active payment methods to avoid repeated checks
    const activePaymentMethods = paymentMethods.filter(method => method.active);
    if (activePaymentMethods.length < 2) return []; // Need at least 2 active methods
    
    // Pre-compute payment method reward rules for faster lookup
    const methodRewardMap = new Map<string, {
      methodName: string;
      categoryRules: Map<string, number>;
      defaultRate: number;
    }>();
    
    // Pre-process payment methods and their rules for faster lookups
    activePaymentMethods.forEach(method => {
      const categoryRules = new Map<string, number>();
      let defaultRate = DEFAULT_REWARD_RATE; // Default if no rules found
      
      method.rewardRules.forEach(rule => {
        if (rule.type === 'mcc' || rule.type === 'merchant') {
          // Category-specific rules
          const conditions = Array.isArray(rule.condition) 
            ? rule.condition 
            : [rule.condition];
          
          // Store lowercase conditions for case-insensitive matching
          conditions.forEach(cond => {
            if (typeof cond === 'string') {
              const condLower = cond.toLowerCase();
              categoryRules.set(condLower, Math.max(
                categoryRules.get(condLower) || 0, 
                rule.pointsMultiplier
              ));
            }
          });
        } else if (rule.type === 'generic' || rule.type === 'currency' || !rule.type) {
          // Default/base/generic reward rule
          defaultRate = rule.pointsMultiplier;
        }
      });
      
      methodRewardMap.set(method.name, {
        methodName: method.name,
        categoryRules,
        defaultRate
      });
    });
    
    // Optimized data structures for category analysis (single pass)
    type CategoryData = {
      transactions: number;
      amount: number;
      methods: Map<string, { count: number; amount: number }>;
      lowerCaseName: string;
    };
    
    const categoryDataMap = new Map<string, CategoryData>();
    
    // Process all transactions in a single pass
    transactions.forEach(tx => {
      const category = tx.category || 'Uncategorized';
      const methodName = tx.paymentMethod?.name || 'Unknown';
      const amount = tx.amount;
      
      // Get or create category data
      let catData = categoryDataMap.get(category);
      if (!catData) {
        catData = {
          transactions: 0,
          amount: 0,
          methods: new Map(),
          lowerCaseName: category.toLowerCase()
        };
        categoryDataMap.set(category, catData);
      }
      
      // Update category totals
      catData.transactions++;
      catData.amount += amount;
      
      // Update method usage within category
      let methodData = catData.methods.get(methodName);
      if (!methodData) {
        methodData = { count: 0, amount: 0 };
        catData.methods.set(methodName, methodData);
      }
      methodData.count++;
      methodData.amount += amount;
    });
    
    // Process categories to find optimization opportunities (single pass)
    const results: CardSuggestion[] = [];
    
    categoryDataMap.forEach((catData, category) => {
      // Skip categories with too few transactions
      if (catData.transactions < MINIMUM_TRANSACTIONS_PER_CATEGORY) return;
      
      // Find predominant payment method for this category
      let currentMethod = '';
      let currentMethodCount = 0;
      let currentMethodAmount = 0;
      
      catData.methods.forEach((data, method) => {
        if (data.count > currentMethodCount) {
          currentMethod = method;
          currentMethodCount = data.count;
          currentMethodAmount = data.amount;
        }
      });
      
      if (!currentMethod) return; // Skip if no method found
      
      // Find the best rewards card for this category
      let bestMethod = currentMethod;
      let bestReward = DEFAULT_REWARD_RATE; // Start with assumption of 1x for current
      
      // Get the current method's reward info if available
      const currentMethodInfo = methodRewardMap.get(currentMethod);
      if (currentMethodInfo) {
        bestReward = currentMethodInfo.defaultRate;
      }
      
      // Check each payment method for better rewards
      methodRewardMap.forEach((methodInfo, methodName) => {
        if (methodName === currentMethod) return; // Skip current method
        
        // Start with default rate
        let potentialReward = methodInfo.defaultRate;
        
        // Check for category-specific rules that might apply
        // Use the pre-computed category rules for faster lookup
        const categoryLower = catData.lowerCaseName;
        
        // Check exact category match first (most efficient)
        if (methodInfo.categoryRules.has(categoryLower)) {
          potentialReward = Math.max(potentialReward, methodInfo.categoryRules.get(categoryLower)!);
        } else {
          // Check partial matches if no exact match found
          methodInfo.categoryRules.forEach((rate, ruleCat) => {
            if (categoryLower.includes(ruleCat) || ruleCat.includes(categoryLower)) {
              potentialReward = Math.max(potentialReward, rate);
            }
          });
        }
        
        // Update best method if we found a better one
        if (potentialReward > bestReward) {
          bestReward = potentialReward;
          bestMethod = methodName;
        }
      });
      
      // If we found a better method, add it to suggestions
      if (bestMethod !== currentMethod) {
        // Get current method's reward rate
        const currentReward = currentMethodInfo?.defaultRate || DEFAULT_REWARD_RATE;
        const potentialSavings = currentMethodAmount * (bestReward - currentReward) * SAVINGS_MULTIPLIER;
        
        // Only add suggestions with meaningful savings
        if (potentialSavings > 0) {
          results.push({
            category,
            transactionCount: currentMethodCount,
            currentMethod,
            suggestedMethod: bestMethod,
            potentialSavings
          });
        }
      }
    });
    
    // Sort by potential savings (highest first)
    return results.sort((a, b) => b.potentialSavings - a.potentialSavings);
  }, [transactions, paymentMethods]);
}

/**
 * Interface for category savings potential
 */
export interface CategorySavingsPotential {
  /** Category name */
  category: string;
  /** Total spending amount in this category */
  amount: number;
  /** Estimated potential savings amount */
  savingsPotential: number;
  /** Whether this is considered discretionary (non-essential) spending */
  discretionary: boolean;
}

/**
 * Interface for the complete savings analysis result
 */
export interface SavingsAnalysis {
  /** Total spending across all categories */
  totalSpending: number;
  /** Total discretionary (non-essential) spending */
  discretionarySpending: number;
  /** Target savings amount based on goal percentage */
  savingsTarget: number;
  /** Total potential savings amount across all categories */
  savingsPotential: number;
  /** Top discretionary categories with savings opportunities */
  topDiscretionaryCategories: CategorySavingsPotential[];
  /** Progress toward savings goal (as percentage) */
  savingsProgress: number;
}

// Define discretionary spending categories once instead of in every render
const DISCRETIONARY_CATEGORIES = new Set([
  'entertainment', 'dining', 'shopping', 'leisure',
  'subscriptions', 'travel', 'hobbies', 'gifts',
  'alcohol', 'coffee', 'electronics', 'clothing',
  'beauty', 'fast food', 'food & drinks', 'food and drinks',
  'home & entertainment', 'restaurants'
].map(cat => cat.toLowerCase()));

// Constants for savings calculations to avoid magic numbers
const DISCRETIONARY_SAVINGS_RATE = 0.3; // 30% potential savings on discretionary spending
const ESSENTIAL_SAVINGS_RATE = 0.05;    // 5% potential savings on essential spending
const TOP_CATEGORIES_COUNT = 3;         // Number of top categories to return

/**
 * Hook for analyzing spending patterns to identify savings opportunities
 * Optimized for performance with large datasets
 * 
 * @param transactions - Transactions to analyze
 * @param savingsGoalPercentage - Target percentage of total spending to save
 * @returns Detailed savings analysis
 */
export function useSavingsPotential(
  transactions: Transaction[],
  savingsGoalPercentage: number = 20
): SavingsAnalysis {
  return useMemo(() => {
    // Early return for empty data to avoid unnecessary processing
    if (!transactions || transactions.length === 0) {
      return {
        totalSpending: 0,
        discretionarySpending: 0,
        savingsTarget: 0,
        savingsPotential: 0,
        topDiscretionaryCategories: [],
        savingsProgress: 0
      };
    }
    
    let totalSpending = 0;
    let discretionarySpending = 0;
    let totalSavingsPotential = 0;
    
    // Category data storage with category name as key for faster lookups
    const categoryData = new Map<string, CategorySavingsPotential>();
    
    // Single pass algorithm - process all transactions in one loop
    // This combines the three separate loops in the original implementation
    transactions.forEach(tx => {
      const amount = tx.amount;
      const category = tx.category || 'Uncategorized';
      const categoryLower = category.toLowerCase();
      
      // Add to total spending (replaces the first reduce)
      totalSpending += amount;
      
      // Get or create category data entry
      let catData = categoryData.get(category);
      if (!catData) {
        // Check if this is a discretionary category (case-insensitive)
        // Using the Set for O(1) lookups instead of array iteration
        const isDiscretionary = DISCRETIONARY_CATEGORIES.has(categoryLower) ||
          Array.from(DISCRETIONARY_CATEGORIES).some(c => 
            categoryLower.includes(c) || c.includes(categoryLower)
          );
        
        catData = {
          category,
          amount: 0,
          discretionary: isDiscretionary,
          savingsPotential: 0
        };
        categoryData.set(category, catData);
      }
      
      // Update category amount
      catData.amount += amount;
      
      // Recalculate savings potential for this category
      const savingsRate = catData.discretionary ? DISCRETIONARY_SAVINGS_RATE : ESSENTIAL_SAVINGS_RATE;
      catData.savingsPotential = catData.amount * savingsRate;
      
      // Update discretionary spending total
      if (catData.discretionary) {
        discretionarySpending += amount;
      }
      
      // Update total savings potential
      totalSavingsPotential = 0; // Will recalculate below
    });
    
    // Calculate total savings potential from all categories
    categoryData.forEach(cat => {
      totalSavingsPotential += cat.savingsPotential;
    });
    
    // Calculate savings target based on goal percentage
    const savingsTarget = totalSpending * (savingsGoalPercentage / 100);
    
    // Calculate savings progress as percentage of target (capped at 100%)
    const savingsProgress = Math.min(
      100, 
      totalSavingsPotential > 0 && savingsTarget > 0 ? 
        (totalSavingsPotential / savingsTarget) * 100 : 0
    );
    
    // Find top discretionary categories more efficiently
    // Instead of filtering and sorting the entire array, we maintain a top N list
    const topCategories: CategorySavingsPotential[] = [];
    
    categoryData.forEach(catData => {
      if (!catData.discretionary) return; // Skip non-discretionary categories
      
      // Special case for first few items to avoid unnecessary comparisons
      if (topCategories.length < TOP_CATEGORIES_COUNT) {
        topCategories.push(catData);
        // Sort after pushing to maintain descending order by savingsPotential
        topCategories.sort((a, b) => b.savingsPotential - a.savingsPotential);
        return;
      }
      
      // Check if this category should replace the lowest in the top list
      const lowestTopIndex = topCategories.length - 1;
      if (catData.savingsPotential > topCategories[lowestTopIndex].savingsPotential) {
        // Replace the lowest entry and resort
        topCategories[lowestTopIndex] = catData;
        topCategories.sort((a, b) => b.savingsPotential - a.savingsPotential);
      }
    });
    
    return {
      totalSpending,
      discretionarySpending,
      savingsTarget,
      savingsPotential: totalSavingsPotential,
      topDiscretionaryCategories: topCategories,
      savingsProgress
    };
  }, [transactions, savingsGoalPercentage]);
}

================
File: hooks/useCurrencyFormatter.ts
================
// src/hooks/useCurrencyFormatter.ts
import { useMemo, useCallback } from "react";
import { Currency } from "@/types";
import { CurrencyService } from "@/services/CurrencyService";

/**
 * Custom hook that provides memoized currency formatting functions
 * to prevent unnecessary re-renders and duplicate log messages
 */
export function useCurrencyFormatter(defaultCurrency: Currency = "SGD") {
  // Create memoized formatter function that maintains referential equality
  const formatCurrency = useCallback(
    (amount: number, currency: Currency = defaultCurrency): string => {
      return CurrencyService.format(amount, currency);
    },
    [defaultCurrency]
  );

  // Create a formatting function that accepts an array of amounts
  // This is useful for components that need to format multiple values
  const formatCurrencyBatch = useCallback(
    (amounts: number[], currency: Currency = defaultCurrency): string[] => {
      console.log(`Batch formatting ${amounts.length} currency values`);
      return amounts.map((amount) => CurrencyService.format(amount, currency));
    },
    [defaultCurrency]
  );

  // Create formatter cache for repeated values in a single render cycle
  const cachedFormatters = useMemo(() => {
    const cache = new Map<string, string>();

    return {
      format: (
        amount: number,
        currency: Currency = defaultCurrency
      ): string => {
        const key = `${amount}-${currency}`;
        if (!cache.has(key)) {
          cache.set(key, CurrencyService.format(amount, currency));
        }
        return cache.get(key)!;
      },

      // Clear cache when currency changes
      clear: () => cache.clear(),
    };
  }, [defaultCurrency]);

  return {
    formatCurrency,
    formatCurrencyBatch,
    cachedFormat: cachedFormatters.format,
    clearCache: cachedFormatters.clear,
  };
}

/**
 * Hook specifically designed for chart components that need
 * to format multiple currency values efficiently
 */
export function useChartCurrencyFormatter(currency: Currency = "SGD") {
  // Create tooltip formatter function for recharts
  const tooltipFormatter = useCallback(
    (value: number, name: string) => {
      return [CurrencyService.format(value, currency), name];
    },
    [currency]
  );

  // Create axis formatter function for recharts
  const axisFormatter = useCallback(
    (value: number) => {
      return CurrencyService.format(value, currency);
    },
    [currency]
  );

  return {
    tooltipFormatter,
    axisFormatter,
    currency,
  };
}

================
File: hooks/useDashboard.ts
================
// src/hooks/useDashboard.ts
import { useMemo } from 'react';
import { Transaction, Currency } from '@/types';
import { DashboardData, DashboardOptions } from '@/types/dashboardTypes';
import { filterTransactionsByTimeframe, getDaysInPeriod } from '@/utils/transactionProcessor';
import { usePieChartData, useSpendingTrendData } from '@/hooks/useChartData';
import {
  calculateTotalExpenses,
  calculatePercentageChange,
  calculateAverageAmount,
  calculateTotalRewardPoints,
  calculateTransactionVelocity,
  calculateAverageByDayOfWeek,
  calculateTotalReimbursed,
  getTopChartItem,
  getPreviousTimeframe,
  hasEnoughDataForTrends
} from '@/utils/dashboardUtils';

/**
 * Custom hook that processes transaction data and calculates dashboard metrics
 * 
 * This hook is responsible for:
 * 1. Filtering transactions based on selected timeframe
 * 2. Calculating key metrics (expenses, counts, averages)
 * 3. Generating chart data for visualizations
 * 4. Computing comparison metrics with previous periods
 * 5. Now also calculating reimbursement amounts
 * 
 * @param options Configuration options for dashboard processing
 * @returns Processed dashboard data ready for display
 */
export function useDashboard(options: DashboardOptions): DashboardData {
  // Extract and set default options with destructuring
  const {
    transactions = [],
    displayCurrency = 'SGD',
    timeframe = 'thisMonth',
    useStatementMonth = false,
    statementCycleDay = 15,
    previousPeriodTransactions = [],
    calculateDayOfWeekMetrics = false,
    calculateVelocity = false,
    lastUpdate = Date.now() // Add lastUpdate with default
  } = options;

  /**
   * Use a consistent chart period instead of deriving it from timeframe filter
   * This separation allows timeframe to control date range and chart period
   * to control visualization granularity independently
   */
  const chartPeriod = 'month' as const; // Fixed value for type safety

  /**
   * Step 2: Filter transactions - only recalculate when filter criteria change
   * Performance improvement: we don't recompute this when only display currency changes
   */
  const filteredTransactions = useMemo(() => {
    // Early return for empty transactions to avoid unnecessary processing
    if (!transactions.length) return [];
    
    console.log(`Filtering ${transactions.length} transactions for timeframe ${timeframe}`);
    
    return filterTransactionsByTimeframe(
      transactions,
      timeframe,
      useStatementMonth,
      statementCycleDay
    );
  }, [transactions, timeframe, useStatementMonth, statementCycleDay, lastUpdate]);

  /**
   * Step 3: Generate comparison data - separating this from other calculations
   * allows it to be recalculated independently
   */
  const filteredPreviousPeriodTransactions = useMemo(() => {
    if (!transactions.length) return [];
    
    if (previousPeriodTransactions.length > 0) {
      return filterTransactionsByTimeframe(
        previousPeriodTransactions,
        timeframe,
        useStatementMonth,
        statementCycleDay
      );
    } else {
      const prevTimeframe = getPreviousTimeframe(timeframe);
      return filterTransactionsByTimeframe(
        transactions,
        prevTimeframe,
        useStatementMonth,
        statementCycleDay
      );
    }
  }, [previousPeriodTransactions, transactions, timeframe, useStatementMonth, statementCycleDay, lastUpdate]);

  /**
   * Step 4: Calculate primary metrics only when filtered data or currency changes
   */
  const basicMetrics = useMemo(() => {
    // Skip expensive calculations for empty datasets
    if (!filteredTransactions.length) {
      return {
        totalExpenses: 0,
        transactionCount: 0,
        averageAmount: 0,
        totalRewardPoints: 0,
        percentageChange: 0,
        totalReimbursed: 0, // Add reimbursement total
        hasEnoughData: false
      };
    }
    
    console.log(`Calculating metrics for ${filteredTransactions.length} filtered transactions`);
    
    // Current period metrics
    const totalExpenses = calculateTotalExpenses(filteredTransactions, displayCurrency);
    const transactionCount = filteredTransactions.length;
    const averageAmount = calculateAverageAmount(totalExpenses, transactionCount);
    const totalRewardPoints = calculateTotalRewardPoints(filteredTransactions);
    const totalReimbursed = calculateTotalReimbursed(filteredTransactions, displayCurrency);
    
    // Comparison metrics with previous period
    // For net expenses, we should use (totalExpenses - totalReimbursed) for both current and previous periods
    const previousExpenses = calculateTotalExpenses(filteredPreviousPeriodTransactions, displayCurrency);
    const previousReimbursed = calculateTotalReimbursed(filteredPreviousPeriodTransactions, displayCurrency);
    
    // Calculate percentage change based on net expenses (expenses - reimbursements)
    const currentNetExpenses = totalExpenses - totalReimbursed;
    const previousNetExpenses = previousExpenses - previousReimbursed;
    const percentageChange = calculatePercentageChange(currentNetExpenses, previousNetExpenses);
    
    return {
      totalExpenses,
      transactionCount,
      averageAmount,
      totalRewardPoints,
      percentageChange,
      totalReimbursed,
      hasEnoughData: hasEnoughDataForTrends(filteredTransactions)
    };
  }, [filteredTransactions, filteredPreviousPeriodTransactions, displayCurrency, lastUpdate]);

  /**
   * Step 5: Generate chart data using specialized hooks
   * Each chart type now has a separately memoized result
   */
  const paymentMethods = usePieChartData(filteredTransactions, 'paymentMethod', displayCurrency);
  const categories = usePieChartData(filteredTransactions, 'category', displayCurrency);

  /**
   * Memoize options for spending trend data - only recreated when currency changes
   */
  const spendingTrendOptions = useMemo(() => ({
    includeCategoryBreakdown: true,
    displayCurrency,
    accountForReimbursements: true // Include this flag for reimbursement calculation
  }), [displayCurrency]);
  
  /**
   * Spending trend calculation now depends only on what it needs
   */
  const spendingTrends = useSpendingTrendData(
    filteredTransactions, 
    chartPeriod, 
    spendingTrendOptions
  );

  /**
   * Optimize optional metrics with proper dependency checking
   */
  const dayOfWeekSpending = useMemo(() => {
    if (!calculateDayOfWeekMetrics || !filteredTransactions.length) return undefined;
    return calculateAverageByDayOfWeek(filteredTransactions, displayCurrency);
  }, [filteredTransactions, displayCurrency, calculateDayOfWeekMetrics, lastUpdate]);

  /**
   * Extract top values with appropriate dependencies
   */
  const topValues = useMemo(() => ({
    paymentMethod: getTopChartItem(paymentMethods),
    category: getTopChartItem(categories)
  }), [paymentMethods, categories]);

  /**
   * Optimize additional metrics calculation
   */
  const additionalMetrics = useMemo(() => {
    const metrics: { transactionVelocity?: number } = {};
    
    if (calculateVelocity && filteredTransactions.length) {
      const daysInPeriod = getDaysInPeriod(timeframe, useStatementMonth, statementCycleDay);
      metrics.transactionVelocity = calculateTransactionVelocity(
        filteredTransactions, 
        daysInPeriod
      );
    }
    
    return metrics;
  }, [filteredTransactions, timeframe, useStatementMonth, statementCycleDay, calculateVelocity, lastUpdate]);

  // Create a properly typed spending trends object that matches the expected interface
  const typedSpendingTrends = useMemo(() => {
    return {
      labels: spendingTrends?.labels || [],
      datasets: spendingTrends?.datasets || []
    };
  }, [spendingTrends]);

  /**
   * Combine all calculated data into the final dashboard data structure
   */
  return {
    // Raw filtered transaction data
    filteredTransactions,
    
    // Combined metrics
    metrics: {
      ...basicMetrics,
      ...additionalMetrics
    },
    
    // Top values for summary display
    top: topValues,
    
    // Chart data for visualizations
    charts: {
      paymentMethods,
      categories,
      dayOfWeekSpending,
      spendingTrends: typedSpendingTrends // Use the properly typed version
    }
  };
}

================
File: hooks/useDashboardFilters.ts
================
// src/hooks/useDashboardFilters.ts
import { useState, useCallback } from 'react';
import { Currency } from '@/types';
import { TimeframeTab } from '@/utils/transactionProcessor';

/**
 * Custom hook to manage dashboard filter state
 * Centralizes all filter-related state and handlers in one place
 */
export function useDashboardFilters(defaultCurrency: Currency = 'SGD') {
  // Filter state
  const [activeTab, setActiveTab] = useState<TimeframeTab>('thisMonth');
  const [displayCurrency, setDisplayCurrency] = useState<Currency>(defaultCurrency);
  const [useStatementMonth, setUseStatementMonth] = useState(false);
  const [statementCycleDay, setStatementCycleDay] = useState(15);
  
  // Handler functions
  const handleTimeframeChange = useCallback((value: string) => {
    setActiveTab(value as TimeframeTab);
  }, []);
  
  const handleCurrencyChange = useCallback((currency: Currency) => {
    setDisplayCurrency(currency);
  }, []);
  
  const handleStatementMonthToggle = useCallback((value: boolean) => {
    setUseStatementMonth(value);
  }, []);
  
  const handleStatementCycleDayChange = useCallback((day: number) => {
    setStatementCycleDay(day);
  }, []);
  
  return {
    // Filter state
    activeTab,
    displayCurrency,
    useStatementMonth,
    statementCycleDay,
    
    // Handlers
    handleTimeframeChange,
    handleCurrencyChange,
    handleStatementMonthToggle,
    handleStatementCycleDayChange,
    
    // Setter functions (for backward compatibility)
    setActiveTab,
    setDisplayCurrency,
    setUseStatementMonth,
    setStatementCycleDay
  };
}

================
File: hooks/useExpenseForm.ts
================
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { PaymentMethod } from '@/types';
import { useToast } from '@/hooks/use-toast';
import { FormValues, formSchema } from './expense-form/formSchema';
import { useMerchantData } from './expense-form/useMerchantData';
import { usePaymentMethodLogic } from './expense-form/usePaymentMethodLogic';
import { useRewardPoints } from './expense-form/useRewardPoints';
import { useState, useEffect } from 'react';

interface UseExpenseFormProps {
  paymentMethods: PaymentMethod[];
  defaultValues?: Partial<FormValues>;
}

// Change regular export to type export
export type { FormValues } from './expense-form/formSchema';

export const useExpenseForm = ({ paymentMethods, defaultValues }: UseExpenseFormProps) => {
  const { toast } = useToast();
  const [estimatedPoints, setEstimatedPoints] = useState<number | {
    totalPoints: number;
    basePoints?: number;
    bonusPoints?: number;
    remainingMonthlyBonusPoints?: number;
    pointsCurrency?: string;
  }>(0);
  
  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      merchantName: defaultValues?.merchantName || '',
      merchantAddress: defaultValues?.merchantAddress || '',
      isOnline: defaultValues?.isOnline ?? false,
      isContactless: defaultValues?.isContactless ?? false,
      amount: defaultValues?.amount || '',
      currency: defaultValues?.currency || 'SGD',
      paymentMethodId: defaultValues?.paymentMethodId || '',
      paymentAmount: defaultValues?.paymentAmount || '',
      date: defaultValues?.date || new Date(),
      notes: defaultValues?.notes || '',
    },
  });
  
  const merchantName = form.watch('merchantName');
  const currency = form.watch('currency') as any;
  const amount = Number(form.watch('amount')) || 0;
  const paymentAmount = Number(form.watch('paymentAmount')) || 0;
  const isOnline = form.watch('isOnline');
  const isContactless = form.watch('isContactless');
  
  const { selectedMCC, setSelectedMCC } = useMerchantData(form, merchantName);
  
  const { selectedPaymentMethod, shouldOverridePayment } = usePaymentMethodLogic(
    form,
    paymentMethods,
    currency,
    amount,
    isOnline
  );
  
  const { simulatePoints } = useRewardPoints();
  
  // Calculate estimated points when relevant fields change
  const calculateEstimatedPoints = async () => {
    if (selectedPaymentMethod && amount > 0) {
      try {
        // Use paymentAmount when currencies differ, otherwise use amount
        const amountToUse = shouldOverridePayment ? paymentAmount : amount;

        const points = await simulatePoints(
          amountToUse,
          currency,
          selectedPaymentMethod,
          selectedMCC?.code,
          merchantName,
          isOnline,
          isContactless
        );
        setEstimatedPoints(points);
      } catch (error) {
        console.error('Error calculating reward points:', error);
        setEstimatedPoints(0);
      }
    } else {
      setEstimatedPoints(0);
    }
  };
  
  // Call the calculation function when dependencies change
  useEffect(() => {
    calculateEstimatedPoints();
  }, [selectedPaymentMethod, amount, paymentAmount, shouldOverridePayment, currency, selectedMCC, merchantName, isOnline, isContactless]);

  return {
    form,
    selectedMCC,
    setSelectedMCC,
    selectedPaymentMethod,
    shouldOverridePayment,
    estimatedPoints,
  };
};

================
File: hooks/useMediaQuery.ts
================
// src/hooks/useMediaQuery.ts
import { useState, useEffect } from 'react';

/**
 * Custom hook that returns whether the given media query matches
 * 
 * @param query The media query to check
 * @returns boolean indicating if the media query matches
 */
export function useMediaQuery(query: string): boolean {
  // Initialize with the current match state if window exists
  const getMatches = (): boolean => {
    // Check if window is defined (to avoid SSR issues)
    if (typeof window !== 'undefined') {
      return window.matchMedia(query).matches;
    }
    return false;
  };

  const [matches, setMatches] = useState<boolean>(getMatches);

  useEffect(() => {
    // Define a function to handle changes to the media query
    const handleChange = () => setMatches(getMatches());
    
    // Create a media query list object
    const mediaQueryList = window.matchMedia(query);
    
    // Add the listener initially
    handleChange();
    
    // Add event listener for changes
    // Use the appropriate event listener based on browser support
    if (mediaQueryList.addEventListener) {
      mediaQueryList.addEventListener('change', handleChange);
    } else {
      // Fallback for older browsers
      mediaQueryList.addListener(handleChange);
    }
    
    // Clean up
    return () => {
      if (mediaQueryList.removeEventListener) {
        mediaQueryList.removeEventListener('change', handleChange);
      } else {
        // Fallback for older browsers
        mediaQueryList.removeListener(handleChange);
      }
    };
  }, [query]);

  return matches;
}

================
File: hooks/usePaymentMethods.ts
================
import { useState, useEffect } from 'react';
import { PaymentMethod, RewardRule } from '@/types';
import { getPaymentMethods, savePaymentMethods } from '@/utils/storageUtils';
import { useToast } from '@/hooks/use-toast';
import { CardRegistry } from '@/components/expense/cards/CardRegistry';
import { cardRuleService } from '@/components/expense/cards/CardRuleService';
import { v4 as uuidv4 } from 'uuid';
import { defaultPaymentMethods } from '@/utils/defaults/paymentMethods';

export const usePaymentMethods = () => {
  const [paymentMethods, setPaymentMethods] = useState<PaymentMethod[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const { toast } = useToast();

  // Helper function to check if a payment method needs to be added from defaults
  const findMissingDefaultMethods = (existingMethods: PaymentMethod[]): PaymentMethod[] => {
    const missingMethods: PaymentMethod[] = [];
    
    // Check each default payment method
    defaultPaymentMethods.forEach(defaultMethod => {
      // For credit cards, check by issuer and name
      if (defaultMethod.type === 'credit_card' && defaultMethod.issuer && defaultMethod.name) {
        const exists = existingMethods.some(method => 
          method.issuer?.toLowerCase() === defaultMethod.issuer?.toLowerCase() && 
          method.name.toLowerCase() === defaultMethod.name.toLowerCase()
        );
        
        if (!exists) {
          console.log(`Adding missing card: ${defaultMethod.issuer} ${defaultMethod.name}`);
          missingMethods.push({
            ...defaultMethod,
            id: uuidv4() // Generate a new UUID for the card
          });
        }
      }
      // For cash methods, check by currency
      else if (defaultMethod.type === 'cash') {
        const exists = existingMethods.some(method => 
          method.type === 'cash' && 
          method.currency === defaultMethod.currency
        );
        
        if (!exists) {
          console.log(`Adding missing cash method: ${defaultMethod.name} (${defaultMethod.currency})`);
          missingMethods.push({
            ...defaultMethod,
            id: uuidv4() // Generate a new UUID for the method
          });
        }
      }
    });
    
    return missingMethods;
  };

  useEffect(() => {
    const loadData = async () => {
      try {
        console.log('Loading payment methods...');
        let methods = await getPaymentMethods();
        console.log('Payment methods loaded:', methods);
        
        // Check for missing payment methods from defaults
        const missingMethods = findMissingDefaultMethods(methods);
        
        // If any missing methods were found, add them to the database
        if (missingMethods.length > 0) {
          console.log(`Found ${missingMethods.length} missing payment methods, adding them now`);
          methods = [...methods, ...missingMethods];
          await savePaymentMethods(methods);
          toast({
            title: 'Payment Methods Updated',
            description: `Added ${missingMethods.length} new payment method(s)`,
          });
        }
        
        if (!methods || methods.length === 0) {
          console.error('No payment methods found');
          toast({
            title: 'Warning',
            description: 'No payment methods found. Please add some payment methods first.',
            variant: 'destructive',
          });
        } else {
          console.log(`${methods.length} payment methods loaded`, methods);
          
          // Verify CardRegistry structure
          console.log('Card Registry:', {
            firstCard: CardRegistry.getAllCards()[0],
            availableCards: CardRegistry.getAllCards().map(c => c.id),
            methods: Object.getOwnPropertyNames(CardRegistry)
          });
          
          // Load card rules from CardRuleService
          await cardRuleService.loadRules();
          console.log('Card rules loaded');
          
          // Connect card rules to payment methods
          const enhancedMethods = methods.map(method => {
            console.log(`Processing payment method: ${method.issuer} ${method.name} (${method.type})`);
            
            if (method.type === 'credit_card' && method.issuer && method.name) {
              // Find corresponding card in registry
              const cardInfo = CardRegistry.findCard(method.issuer, method.name);
              console.log(`Card match result:`, cardInfo ? {
                id: cardInfo.id,
                issuer: cardInfo.issuer,
                name: cardInfo.name
              } : 'No match found');
              
              if (cardInfo) {
                // Get rules for this card type
                const cardRules = cardRuleService.getRulesForCardType(cardInfo.id);
                console.log(`Rules for ${cardInfo.id}:`, cardRules.length > 0 ? 
                  cardRules.map(r => ({ id: r.id, name: r.name, cardType: r.cardType })) : 
                  'No rules found');
                
                if (cardRules.length > 0) {
                  // Convert card rule configurations to RewardRule objects for UI display
                  const rewardRules: RewardRule[] = cardRules.map(rule => {
                    // Determine the appropriate rule type
                    let ruleType: 'mcc' | 'merchant' | 'currency' | 'spend_threshold' | 'online' | 'contactless' = 'mcc';
                    let condition: string | string[] = '';
                    
                    if (rule.isOnlineOnly) {
                      ruleType = 'online';
                      condition = 'All online transactions';
                    } else if (rule.isContactlessOnly) {
                      ruleType = 'contactless';
                      condition = 'All contactless transactions';
                    } else if (rule.includedMCCs && rule.includedMCCs.length > 0) {
                      ruleType = 'mcc';
                      condition = rule.includedMCCs;
                    } else if (rule.currencyRestrictions && rule.currencyRestrictions.length > 0) {
                      ruleType = 'currency';
                      condition = rule.currencyRestrictions;
                    }
                    
                    const pointsMultiplier = rule.bonusPointRate > 0 
                      ? (rule.bonusPointRate / rule.basePointRate) + 1 // Add 1 to include base rate
                      : 1;
                      
                    return {
                      id: rule.id || uuidv4(),
                      name: rule.name,
                      description: rule.description || rule.name,
                      type: ruleType,
                      condition,
                      pointsMultiplier,
                      maxSpend: rule.monthlyCap > 0 ? rule.monthlyCap : undefined
                    };
                  });
                  
                  console.log(`Created ${rewardRules.length} reward rules for ${method.issuer} ${method.name}`);
                  return { ...method, rewardRules };
                } else {
                  console.log(`No rules found for ${method.issuer} ${method.name}`);
                }
              } else {
                console.log(`No matching card found in registry for ${method.issuer} ${method.name}`);
                
                // Debug: Check if there's a close match with different capitalization
                const allCards = CardRegistry.getAllCards();
                const potentialMatches = allCards.filter(card => 
                  card.issuer.toLowerCase().includes(method.issuer.toLowerCase()) || 
                  method.issuer.toLowerCase().includes(card.issuer.toLowerCase()) ||
                  card.name.toLowerCase().includes(method.name.toLowerCase()) ||
                  method.name.toLowerCase().includes(card.name.toLowerCase())
                );
                
                if (potentialMatches.length > 0) {
                  console.log('Potential matches found:', potentialMatches.map(m => ({
                    id: m.id,
                    issuer: m.issuer,
                    name: m.name,
                    issuerMatch: m.issuer.toLowerCase() === method.issuer.toLowerCase(),
                    nameMatch: m.name.toLowerCase() === method.name.toLowerCase()
                  })));
                }
              }
            }
            return method;
          });
          
          // Update state with enhanced methods
          setPaymentMethods(enhancedMethods);
          
          // Check if any rules were added
          const methodsWithRules = enhancedMethods.filter(m => m.rewardRules && m.rewardRules.length > 0);
          console.log(`${methodsWithRules.length} out of ${enhancedMethods.length} methods have rules`);
          
          // If rules were added, save the updated payment methods
          const hasRulesAdded = enhancedMethods.some((method, index) => 
            method.rewardRules && method.rewardRules.length > 0 && 
            (!methods[index].rewardRules || methods[index].rewardRules.length === 0)
          );
          
          if (hasRulesAdded) {
            console.log('Saving payment methods with updated reward rules');
            await savePaymentMethods(enhancedMethods);
          }
        }
      } catch (error) {
        console.error('Error loading payment methods:', error);
        toast({
          title: 'Error',
          description: 'Failed to load payment methods',
          variant: 'destructive',
        });
      } finally {
        setIsLoading(false);
      }
    };
    
    loadData();
  }, [toast]);

  return { paymentMethods, isLoading };
};

================
File: hooks/useSupabaseConnectionCheck.ts
================
import { useState, useEffect } from 'react';
import { supabase, USE_LOCAL_STORAGE_DEFAULT } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';

export const useSupabaseConnectionCheck = () => {
  const [supabaseConnected, setSupabaseConnected] = useState<boolean | null>(null);
  const [useLocalStorage, setUseLocalStorage] = useState<boolean>(USE_LOCAL_STORAGE_DEFAULT);
  const { toast } = useToast();

  useEffect(() => {
    if (!USE_LOCAL_STORAGE_DEFAULT) {
      const checkSupabaseConnection = async () => {
        try {
          console.log('Checking Supabase connection...');
          const { data, error } = await supabase.from('payment_methods').select('id').limit(1);
          
          if (error) {
            console.error('Supabase connection error:', error);
            setSupabaseConnected(false);
            setUseLocalStorage(true);
            toast({
              title: 'Warning',
              description: 'Supabase connection failed. Using local storage fallback.',
              variant: 'destructive',
            });
          } else {
            console.log('Supabase connection successful');
            setSupabaseConnected(true);
            setUseLocalStorage(false);
          }
        } catch (error) {
          console.error('Error checking Supabase connection:', error);
          setSupabaseConnected(false);
          setUseLocalStorage(true);
          toast({
            title: 'Warning',
            description: 'Supabase connection failed. Using local storage fallback.',
            variant: 'destructive',
          });
        }
      };
      
      checkSupabaseConnection();
    } else {
      // Default to local storage without checking Supabase
      setSupabaseConnected(false);
      setUseLocalStorage(true);
      console.log('Using local storage by default.');
    }
  }, [toast]);

  return { supabaseConnected, useLocalStorage };
};

================
File: hooks/useTransactionActions.ts
================
import { useState } from 'react';
import { Transaction } from '@/types';
import { deleteTransaction, editTransaction } from '@/utils/storageUtils';
import { useToast } from '@/hooks/use-toast';

export const useTransactionActions = (transactions: Transaction[], setTransactions: React.Dispatch<React.SetStateAction<Transaction[]>>) => {
  const { toast } = useToast();
  const [selectedTransaction, setSelectedTransaction] = useState<Transaction | null>(null);
  const [isTransactionDialogOpen, setIsTransactionDialogOpen] = useState(false);
  const [dialogMode, setDialogMode] = useState<'view' | 'edit'>('view');
  const [deleteConfirmOpen, setDeleteConfirmOpen] = useState(false);
  const [transactionToDelete, setTransactionToDelete] = useState<Transaction | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const handleViewTransaction = (transaction: Transaction) => {
    setSelectedTransaction(transaction);
    setDialogMode('view');
    setIsTransactionDialogOpen(true);
  };
  
  const handleEditTransaction = (transaction: Transaction) => {
    setSelectedTransaction(transaction);
    setDialogMode('edit');
    setIsTransactionDialogOpen(true);
  };
  
  const handleDeleteTransaction = (transaction: Transaction) => {
    setTransactionToDelete(transaction);
    setDeleteConfirmOpen(true);
  };
  
  const confirmDeleteTransaction = async () => {
    if (!transactionToDelete) return;
    
    try {
      setIsLoading(true);
      
      // Optimistically update the UI first for better user experience
      setTransactions(prev => prev.filter(tx => tx.id !== transactionToDelete.id));
      
      const success = await deleteTransaction(transactionToDelete.id);
      
      if (success) {
        toast({
          title: "Transaction deleted",
          description: "The transaction has been successfully deleted.",
        });
      } else {
        // If there was a problem, revert the optimistic update
        toast({
          title: "Warning",
          description: "Delete operation may not have synced with remote database.",
        });
        // No need to revert transactions state since we're already assuming it was deleted locally
      }
      
      setDeleteConfirmOpen(false);
      setIsTransactionDialogOpen(false);
    } catch (error) {
      console.error('Error deleting transaction:', error);
      
      // Revert the optimistic update if there was an exception
      const originalTransaction = transactionToDelete;
      if (originalTransaction) {
        setTransactions(prev => [...prev, originalTransaction]);
      }
      
      toast({
        title: "Error",
        description: "Failed to delete the transaction. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleSaveEdit = async (updatedTransaction: Omit<Transaction, 'id'>) => {
    if (!selectedTransaction) return;
    
    try {
      setIsLoading(true);
      const result = await editTransaction(selectedTransaction.id, updatedTransaction);
      
      if (result) {
        // Update local state immediately for better UX
        setTransactions(prev => 
          prev.map(tx => tx.id === selectedTransaction.id ? result : tx)
        );
        
        toast({
          title: "Transaction updated",
          description: "The transaction has been successfully updated.",
        });
        
        setIsTransactionDialogOpen(false);
      } else {
        toast({
          title: "Error",
          description: "Failed to update the transaction.",
          variant: "destructive",
        });
      }
    } catch (error) {
      console.error('Error updating transaction:', error);
      toast({
        title: "Error",
        description: "Failed to update the transaction.",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };

  return {
    selectedTransaction,
    isTransactionDialogOpen,
    setIsTransactionDialogOpen,
    dialogMode,
    deleteConfirmOpen,
    setDeleteConfirmOpen,
    transactionToDelete,
    isLoading,
    handleViewTransaction,
    handleEditTransaction,
    handleDeleteTransaction,
    confirmDeleteTransaction,
    handleSaveEdit
  };
};

================
File: hooks/useTransactionList.ts
================
import { useTransactionData } from './transaction-list/useTransactionData';
import { useTransactionFilters } from './transaction-list/useTransactionFilters';
import { FilterOptions, SortOption } from './transaction-list/types';

export type { FilterOptions, SortOption };

export const useTransactionList = () => {
  // Get transaction data
  const { 
    transactions, 
    setTransactions, 
    paymentMethods, 
    isLoading,
    refreshTransactions
  } = useTransactionData();

  // Apply filters and sorting
  const {
    filteredTransactions,
    sortOption,
    setSortOption,
    searchQuery,
    setSearchQuery,
    filterOptions,
    handleFilterChange,
    activeFilters,
    resetFilters
  } = useTransactionFilters(transactions, isLoading);

  return {
    transactions,
    setTransactions,
    paymentMethods,
    filteredTransactions,
    sortOption,
    setSortOption,
    searchQuery,
    setSearchQuery,
    filterOptions,
    handleFilterChange,
    activeFilters,
    resetFilters,
    isLoading,
    refreshTransactions
  };
};

================
File: hooks/useTransactionSubmit.ts
================
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Transaction } from '@/types';
import { addTransaction } from '@/utils/storage/transactions';
import { useToast } from '@/hooks/use-toast';

export const useTransactionSubmit = (useLocalStorage: boolean) => {
  const [isLoading, setIsLoading] = useState(false);
  const [saveError, setSaveError] = useState<string | null>(null);
  const navigate = useNavigate();
  const { toast } = useToast();

  const handleSubmit = async (transactionData: Omit<Transaction, 'id'>) => {
    try {
      console.log('Starting transaction save process...');
      console.log('Initial transaction data:', JSON.stringify(transactionData, null, 2));
      console.log('Using local storage flag:', useLocalStorage);
      
      setSaveError(null);
      setIsLoading(true);
      
      // Validate merchant information
      if (!transactionData.merchant || !transactionData.merchant.name) {
        console.error('Merchant validation failed:', transactionData.merchant);
        throw new Error('Merchant information is missing');
      }
      
      // Validate payment method
      if (!transactionData.paymentMethod || !transactionData.paymentMethod.id) {
        console.error('Payment method validation failed:', transactionData.paymentMethod);
        throw new Error('Payment method is missing or invalid');
      }
      
      // Validate payment amount
      if (isNaN(transactionData.paymentAmount) || transactionData.paymentAmount <= 0) {
        console.error('Payment amount validation failed:', transactionData.paymentAmount);
        throw new Error('Invalid payment amount');
      }
      
      console.log('Validated transaction data:', {
        merchant: transactionData.merchant.name,
        merchantId: transactionData.merchant.id,
        amount: transactionData.amount,
        currency: transactionData.currency,
        paymentMethod: transactionData.paymentMethod.name,
        paymentMethodId: transactionData.paymentMethod.id,
        date: transactionData.date
      });
      
      // Save the transaction, with explicit useLocalStorage parameter
      const result = await addTransaction(transactionData, useLocalStorage);
      
      console.log('Transaction saved successfully:', result);
      
      toast({
        title: 'Success',
        description: 'Transaction saved successfully to ' + (useLocalStorage ? 'local storage' : 'Supabase'),
      });
      
      // Navigate back to the dashboard to see updated metrics
      navigate('/');
      return result;
    } catch (error) {
      console.error('Error saving transaction:', error);
      
      let errorMessage = 'Failed to save transaction';
      
      // Detailed error information for debugging
      if (error instanceof Error) {
        errorMessage = error.message;
        console.error('Error instance details:', {
          message: error.message,
          stack: error.stack
        });
        
        // Check for specific errors
        if (error.message.includes('duplicate key') || error.message.includes('constraint')) {
          errorMessage = 'A merchant with this name already exists';
        } else if (error.message.includes('network')) {
          errorMessage = 'Network error - please check your connection';
        }
      }
      
      setSaveError(errorMessage);
      
      toast({
        title: 'Error',
        description: errorMessage,
        variant: 'destructive',
      });
      
      // Don't navigate when there's an error, let user fix and try again
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  return { handleSubmit, isLoading, saveError };
};

================
File: pages/AddExpense.tsx
================
import { useSupabaseConnectionCheck } from '@/hooks/useSupabaseConnectionCheck';
import { usePaymentMethods } from '@/hooks/usePaymentMethods';
import { useTransactionSubmit } from '@/hooks/useTransactionSubmit';
import ExpenseForm from '@/components/expense/ExpenseForm';
import StorageModeAlert from '@/components/expense/StorageModeAlert';
import ErrorAlert from '@/components/expense/ErrorAlert';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { useState } from 'react';
import { useIsMobile } from '@/hooks/use-mobile';

const AddExpense = () => {
  const { useLocalStorage } = useSupabaseConnectionCheck();
  const { paymentMethods, isLoading } = usePaymentMethods();
  const { handleSubmit, isLoading: isSaving, saveError } = useTransactionSubmit(useLocalStorage);
  const isMobile = useIsMobile();
  const [activeTab, setActiveTab] = useState("expense");
  
  return (
    <div className="min-h-screen">
      <div className="container max-w-7xl mx-auto pb-16">
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-10 mt-4">
          <div>
            <h1 className="text-3xl font-bold tracking-tight text-gradient">Add Expense</h1>
            <p className="text-muted-foreground mt-1.5 text-sm">
              Record a new expense transaction
            </p>
          </div>
        </div>
        
        <StorageModeAlert useLocalStorage={useLocalStorage} />
        <ErrorAlert error={saveError} />
        
        {isLoading && paymentMethods.length === 0 ? (
          <div className="animate-pulse text-center py-10">Loading...</div>
        ) : (
          <ExpenseForm
            paymentMethods={paymentMethods}
            onSubmit={handleSubmit}
          />
        )}
      </div>
    </div>
  );
};

export default AddExpense;

================
File: pages/Index.tsx
================
// src/pages/Index.tsx
import React from 'react';
import { DashboardProvider } from '@/components/dashboard/DashboardProvider';
import { Dashboard } from '@/components/dashboard/Dashboard';

const Index = () => {
  return (
    <DashboardProvider 
      config={{
        defaultCurrency: 'SGD',
        defaultTimeframe: 'thisMonth',
        defaultStatementDay: 15,
        defaultUseStatementMonth: false
      }}
    >
      <Dashboard />
    </DashboardProvider>
  );
};

export default Index;

================
File: pages/NotFound.tsx
================
import { useLocation, Link } from "react-router-dom";
import { useEffect } from "react";
import { Button } from "@/components/ui/button";
import { HomeIcon } from "lucide-react";
import Navbar from "@/components/layout/Navbar";

const NotFound = () => {
  const location = useLocation();

  useEffect(() => {
    console.error(
      "404 Error: User attempted to access non-existent route:",
      location.pathname
    );
  }, [location.pathname]);

  return (
    <div className="min-h-screen bg-background">
      <Navbar />
      
      <div className="container mx-auto h-screen flex flex-col items-center justify-center px-4 md:px-6 py-8 -mt-20">
        <div className="glass-card-elevated p-8 md:p-12 rounded-2xl text-center max-w-md mx-auto animate-fade-in">
          <h1 className="text-9xl font-bold text-primary mb-4">404</h1>
          <p className="text-xl text-gray-600 dark:text-gray-300 mb-8">
            Oops! The page you're looking for doesn't exist.
          </p>
          <Link to="/">
            <Button className="gap-2">
              <HomeIcon className="h-4 w-4" />
              Return to Dashboard
            </Button>
          </Link>
        </div>
      </div>
    </div>
  );
};

export default NotFound;

================
File: pages/PaymentMethods.tsx
================
import { useState, useEffect } from 'react';
import { PaymentMethod } from '@/types';
import { getPaymentMethods, savePaymentMethods } from '@/utils/storageUtils';
import { useToast } from '@/hooks/use-toast';
import { Plus } from 'lucide-react';
import { Button } from '@/components/ui/button';
import PaymentMethodForm from '@/components/payment-method/PaymentMethodForm';
import PaymentMethodCard from '@/components/payment-method/PaymentMethodCard';
import EmptyPaymentMethodsCard from '@/components/payment-method/EmptyPaymentMethodsCard';
import ImageUploadDialog from '@/components/payment-method/ImageUploadDialog';
import { uploadCardImage } from '@/utils/storage/paymentMethods'; // Using direct import path
import { v4 as uuidv4 } from 'uuid';

const PaymentMethods = () => {
  const [paymentMethods, setPaymentMethods] = useState<PaymentMethod[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isFormOpen, setIsFormOpen] = useState(false);
  const [editingMethod, setEditingMethod] = useState<PaymentMethod | null>(null);
  const [imageUploadMethod, setImageUploadMethod] = useState<PaymentMethod | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const { toast } = useToast();

  useEffect(() => {
    const loadPaymentMethods = async () => {
      try {
        const methods = await getPaymentMethods();
        setPaymentMethods(methods);
      } catch (error) {
        console.error('Error loading payment methods:', error);
        toast({
          title: 'Error',
          description: 'Failed to load payment methods',
          variant: 'destructive',
        });
      } finally {
        setIsLoading(false);
      }
    };

    loadPaymentMethods();
  }, [toast]);

  const handleAddMethod = () => {
    setEditingMethod(null);
    setIsFormOpen(true);
  };

  const handleEditMethod = (method: PaymentMethod) => {
    setEditingMethod(method);
    setIsFormOpen(true);
  };

  const handleFormSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setIsLoading(true);
    
    try {
      const formData = new FormData(event.currentTarget);
      
      const method: PaymentMethod = {
        id: editingMethod?.id || uuidv4(),
        name: formData.get('name') as string,
        type: formData.get('type') as 'cash' | 'credit_card',
        currency: formData.get('currency') as any,
        rewardRules: editingMethod?.rewardRules || [],
        active: formData.get('active') === 'on',
        imageUrl: editingMethod?.imageUrl,
      };
      
      // Add credit card specific fields if applicable
      if (method.type === 'credit_card') {
        method.issuer = formData.get('issuer') as string || undefined;
        method.lastFourDigits = formData.get('lastFourDigits') as string || undefined;
        
        const statementDay = formData.get('statementStartDay') as string;
        if (statementDay) {
          method.statementStartDay = parseInt(statementDay, 10);
        }
        
        method.isMonthlyStatement = formData.get('isMonthlyStatement') === 'on';
      }
      
      await handleSaveMethod(method);
    } catch (error) {
      console.error('Error saving payment method:', error);
      toast({
        title: 'Error',
        description: 'Failed to save payment method',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleSaveMethod = async (method: PaymentMethod) => {
    try {
      let updatedMethods: PaymentMethod[];
      
      if (editingMethod) {
        // Update existing method
        updatedMethods = paymentMethods.map(m => 
          m.id === method.id ? method : m
        );
      } else {
        // Add new method
        updatedMethods = [...paymentMethods, method];
      }
      
      await savePaymentMethods(updatedMethods);
      setPaymentMethods(updatedMethods);
      
      toast({
        title: 'Success',
        description: `Payment method ${editingMethod ? 'updated' : 'added'} successfully`,
      });
      
      setIsFormOpen(false);
      setEditingMethod(null);
    } catch (error) {
      console.error('Error saving payment method:', error);
      toast({
        title: 'Error',
        description: 'Failed to save payment method',
        variant: 'destructive',
      });
    }
  };

  const handleToggleActive = async (id: string) => {
    try {
      const updatedMethods = paymentMethods.map(method => 
        method.id === id 
          ? { ...method, active: !method.active } 
          : method
      );
      
      await savePaymentMethods(updatedMethods);
      setPaymentMethods(updatedMethods);
      
      const method = updatedMethods.find(m => m.id === id);
      
      toast({
        title: 'Success',
        description: `${method?.name} ${method?.active ? 'activated' : 'deactivated'} successfully`,
      });
    } catch (error) {
      console.error('Error toggling payment method active state:', error);
      toast({
        title: 'Error',
        description: 'Failed to update payment method',
        variant: 'destructive',
      });
    }
  };

  const handleOpenImageUpload = (method: PaymentMethod) => {
    setImageUploadMethod(method);
  };

  const handleImageUpload = async (file: File) => {
    if (!imageUploadMethod) return;
    
    setIsUploading(true);
    
    try {
      const imageUrl = await uploadCardImage(file, imageUploadMethod.id);
      
      if (imageUrl) {
        // Update the payment method with the image URL
        const updatedMethods = paymentMethods.map(method => 
          method.id === imageUploadMethod.id 
            ? { ...method, imageUrl } 
            : method
        );
        
        await savePaymentMethods(updatedMethods);
        setPaymentMethods(updatedMethods);
        
        toast({
          title: 'Success',
          description: 'Card image uploaded successfully',
        });
      } else {
        throw new Error('Failed to upload image');
      }
    } catch (error) {
      console.error('Error uploading card image:', error);
      toast({
        title: 'Error',
        description: 'Failed to upload card image',
        variant: 'destructive',
      });
    } finally {
      setIsUploading(false);
      setImageUploadMethod(null);
    }
  };

  const creditCards = paymentMethods.filter(method => method.type === 'credit_card');
  const cashMethods = paymentMethods.filter(method => method.type === 'cash');

  return (
    <div className="min-h-screen">
      <div className="container max-w-7xl mx-auto pb-16">
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-10 mt-4">
          <div>
            <h1 className="text-3xl font-bold tracking-tight text-gradient">Payment Methods</h1>
            <p className="text-muted-foreground mt-1.5 text-sm">
              Manage your payment cards and cash payment methods
            </p>
          </div>
          
          <Button onClick={handleAddMethod} className="gap-2">
            <Plus className="h-4 w-4" />
            Add Method
          </Button>
        </div>
        
        {isLoading ? (
          <div className="animate-pulse text-center py-10">
            Loading payment methods...
          </div>
        ) : (
          <div className="space-y-10">
            {/* Credit Cards Section */}
            <div>
              <h2 className="text-xl font-semibold mb-4">Credit Cards</h2>
              
              {creditCards.length === 0 ? (
                <EmptyPaymentMethodsCard 
                  type="credit_cards"
                  onAddClick={handleAddMethod}
                />
              ) : (
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  {creditCards.map((method) => (
                    <PaymentMethodCard
                      key={method.id}
                      method={method}
                      onToggleActive={handleToggleActive}
                      onEdit={handleEditMethod}
                      onImageUpload={handleOpenImageUpload}
                    />
                  ))}
                </div>
              )}
            </div>
            
            {/* Cash Section */}
            <div>
              <h2 className="text-xl font-semibold mb-4">Cash / Debit</h2>
              
              {cashMethods.length === 0 ? (
                <EmptyPaymentMethodsCard 
                  type="cash"
                  onAddClick={handleAddMethod}
                />
              ) : (
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  {cashMethods.map((method) => (
                    <PaymentMethodCard
                      key={method.id}
                      method={method}
                      onToggleActive={handleToggleActive}
                      onEdit={handleEditMethod}
                      onImageUpload={handleOpenImageUpload}
                    />
                  ))}
                </div>
              )}
            </div>
          </div>
        )}
        
        {/* Pass isOpen prop to PaymentMethodForm */}
        <PaymentMethodForm
          currentMethod={editingMethod}
          isEditing={!!editingMethod}
          isLoading={isLoading}
          isOpen={isFormOpen}
          onClose={() => {
            setIsFormOpen(false);
            setEditingMethod(null);
          }}
          onSubmit={handleFormSubmit}
        />
        
        <ImageUploadDialog
          open={!!imageUploadMethod}
          onOpenChange={(open) => {
            if (!open) setImageUploadMethod(null);
          }}
          paymentMethod={imageUploadMethod}
          onImageUpload={handleImageUpload}
          isUploading={isUploading}
        />
      </div>
    </div>
  );
};

export default PaymentMethods;

================
File: pages/RewardPoints.tsx
================
import React, { useState } from 'react';
import { useTransactionList } from '@/hooks/useTransactionList';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { CoinsIcon } from 'lucide-react';
import PointsCurrencyAggregator from '@/components/expense/PointsCurrencyAggregator';
import { Transaction } from '@/types';
import StatementCycleFilter from '@/components/dashboard/StatementCycleFilter';
import { rewardCalculationService } from '@/services/RewardCalculationService';

// Helper component for displaying points by payment method
const PointsByPaymentMethod = ({ transactions }: { transactions: Transaction[] }) => {
  const pointsByMethod = transactions.reduce<Record<string, { points: number, currency: string }>>((acc, transaction) => {
    if (!transaction.paymentMethod || !transaction.rewardPoints) return acc;
    
    const methodName = transaction.paymentMethod.name;
    // Get the correct points currency for this payment method
    const pointsCurrency = rewardCalculationService.getPointsCurrency(transaction.paymentMethod);
    
    if (!acc[methodName]) {
      acc[methodName] = { points: 0, currency: pointsCurrency };
    }
    
    acc[methodName].points += (transaction.rewardPoints || 0);
    return acc;
  }, {});

  return (
    <div className="space-y-2">
      {Object.entries(pointsByMethod).map(([method, { points, currency }]) => (
        <div key={method} className="flex justify-between items-center p-2 border-b">
          <span>{method}</span>
          <span className="font-semibold">{points.toLocaleString()} {currency}</span>
        </div>
      ))}
    </div>
  );
};

const RewardPoints = () => {
  const { 
    transactions, 
    filteredTransactions,
  } = useTransactionList();

  // Local state for statement cycle filtering
  const [useStatementMonth, setUseStatementMonth] = useState(false);
  const [statementCycleDay, setStatementCycleDay] = useState(1);
  
  return (
    <div className="min-h-screen">
      <div className="container max-w-7xl mx-auto pb-16">
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-10 mt-4">
          <div>
            <h1 className="text-3xl font-bold tracking-tight text-gradient">
              Reward Points Analytics
            </h1>
            <p className="text-muted-foreground mt-1.5 text-sm">
              Track and analyze your reward points
            </p>
          </div>
          
          <div className="flex items-center gap-3 mt-4 sm:mt-0">
            {/* Empty div to ensure consistent layout with other pages */}
          </div>
        </div>
        
        <div className="mb-6">
          <StatementCycleFilter 
            useStatementMonth={useStatementMonth}
            setUseStatementMonth={setUseStatementMonth}
            statementCycleDay={statementCycleDay}
            setStatementCycleDay={setStatementCycleDay}
          />
        </div>
        
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <PointsCurrencyAggregator transactions={filteredTransactions} />
          
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center">
                <CoinsIcon className="mr-2" />
                Points by Payment Method
              </CardTitle>
            </CardHeader>
            <CardContent>
              {filteredTransactions.length > 0 ? (
                <PointsByPaymentMethod transactions={filteredTransactions} />
              ) : (
                <div className="text-center py-6 text-gray-500">
                  No transactions in this period
                </div>
              )}
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};

export default RewardPoints;

================
File: pages/Transactions.tsx
================
import { useState } from 'react';
import { ViewMode } from '@/components/transaction/TransactionSortAndView';
import TransactionDialog from '@/components/expense/TransactionDialog';
import TransactionDeleteDialog from '@/components/transaction/TransactionDeleteDialog';
import { useTransactionList } from '@/hooks/useTransactionList';
import { useTransactionActions } from '@/hooks/useTransactionActions';
import TransactionHeader from '@/components/transaction/TransactionHeader';
import TransactionFilterControls from '@/components/transaction/TransactionFilterControls';
import TransactionContent from '@/components/transaction/TransactionContent';

const Transactions = () => {
  const {
    transactions,
    setTransactions,
    paymentMethods,
    filteredTransactions,
    sortOption,
    setSortOption,
    searchQuery,
    setSearchQuery,
    filterOptions,
    handleFilterChange,
    activeFilters,
    resetFilters,
    isLoading
  } = useTransactionList();

  const {
    selectedTransaction,
    isTransactionDialogOpen,
    setIsTransactionDialogOpen,
    dialogMode,
    deleteConfirmOpen,
    setDeleteConfirmOpen,
    transactionToDelete,
    handleViewTransaction,
    handleEditTransaction,
    handleDeleteTransaction,
    confirmDeleteTransaction,
    handleSaveEdit
  } = useTransactionActions(transactions, setTransactions);

  const [viewMode, setViewMode] = useState<ViewMode>('grid');

  return (
    <div className="min-h-screen">
      <div className="container max-w-7xl mx-auto pb-16">
        <TransactionHeader />
        
        <TransactionFilterControls
          searchQuery={searchQuery}
          onSearchChange={setSearchQuery}
          filterOptions={filterOptions}
          activeFilters={activeFilters}
          paymentMethods={paymentMethods}
          onFilterChange={handleFilterChange}
          onResetFilters={resetFilters}
          sortOption={sortOption}
          viewMode={viewMode}
          onSortChange={setSortOption}
          onViewChange={setViewMode}
        />
        
        <TransactionContent 
          isLoading={isLoading}
          transactions={transactions}
          filteredTransactions={filteredTransactions}
          paymentMethods={paymentMethods}
          viewMode={viewMode}
          sortOption={sortOption}
          onViewChange={setViewMode}
          onResetFilters={resetFilters}
          onViewTransaction={handleViewTransaction}
          onEditTransaction={handleEditTransaction}
          onDeleteTransaction={handleDeleteTransaction}
        />
      </div>
      
      {selectedTransaction && (
        <TransactionDialog
          transaction={selectedTransaction}
          paymentMethods={paymentMethods}
          allTransactions={transactions}
          isOpen={isTransactionDialogOpen}
          mode={dialogMode}
          onClose={() => setIsTransactionDialogOpen(false)}
          onEdit={handleEditTransaction}
          onDelete={handleDeleteTransaction}
          onSave={handleSaveEdit}
        />
      )}
      
      <TransactionDeleteDialog
        isOpen={deleteConfirmOpen}
        onOpenChange={setDeleteConfirmOpen}
        onConfirmDelete={confirmDeleteTransaction}
      />
    </div>
  );
};

export default Transactions;

================
File: services/calculators/BaseCalculator.ts
================
/**
 * Base interface for card calculation inputs
 * (matches closely with BaseRewardCardProps but without React dependencies)
 */
export interface CalculationInput {
  amount: number;
  mcc?: string;
  isOnline?: boolean;
  isContactless?: boolean;
  currency?: string;
  merchantName?: string;
  
  // Tracking properties
  usedBonusPoints?: number;
  nonSgdSpendTotal?: number;
  hasSgdTransactions?: boolean;
  monthlySpendByCategory?: Record<string, number>;
  selectedCategories?: string[];
  
  // Payment method for card-specific configurations
  paymentMethod?: {
    id: string;
    type: 'cash' | 'credit_card';
    name: string;
    currency: string;
    issuer?: string;
    selectedCategories?: string[];
    [key: string]: any;
  };
}

/**
 * Interface for calculation results 
 */
export interface CalculationResult {
  totalPoints: number;
  basePoints: number;
  bonusPoints: number;
  pointsCurrency?: string;
  remainingMonthlyBonusPoints?: number;
  messageText?: string;
}

/**
 * Interface for bonus point caps
 */
export interface BonusPointsCap {
  maxBonusPoints: number;
  applyCap(calculatedBonus: number, usedBonusPoints: number): number;
  getRemainingBonusPoints(usedBonusPoints: number, newBonusPoints: number): number;
}

/**
 * Standard monthly cap implementation
 */
export class MonthlyCap implements BonusPointsCap {
  constructor(public maxBonusPoints: number) {}

  applyCap(calculatedBonus: number, usedBonusPoints: number): number {
    return Math.min(calculatedBonus, this.maxBonusPoints - (usedBonusPoints || 0));
  }

  getRemainingBonusPoints(usedBonusPoints: number, newBonusPoints: number): number {
    return Math.max(0, this.maxBonusPoints - (usedBonusPoints || 0) - newBonusPoints);
  }
}

/**
 * Abstract base class for all reward calculators
 */
export abstract class BaseCalculator {
  /**
   * Calculate rewards for a transaction
   */
  calculate(input: CalculationInput): CalculationResult {
    return this.calculateRewards(input);
  }

  /**
   * Calculates reward points for a transaction (used by RewardCalculationService)
   */
  calculateRewards(input: CalculationInput): CalculationResult {
    const { amount, usedBonusPoints = 0 } = input;
    const roundedAmount = this.calculateRoundedAmount(amount);
    const basePoints = this.calculateBasePoints(roundedAmount);
    
    const isEligible = this.getBonusPointsEligibility(input);
    const potentialBonusPoints = isEligible ? this.calculateBonusPoints(roundedAmount, input) : 0;
    
    const bonusPointsCap = this.getBonusPointsCap();
    const actualBonusPoints = bonusPointsCap.applyCap(potentialBonusPoints, usedBonusPoints);
    
    const remainingBonusPoints = bonusPointsCap.getRemainingBonusPoints(
      usedBonusPoints,
      actualBonusPoints
    );

    // Generate bonus point message if eligible but capped
    let messageText = "";
    if (potentialBonusPoints > 0 && actualBonusPoints === 0) {
      messageText = "Monthly cap reached";
    }

    return {
      basePoints,
      bonusPoints: actualBonusPoints,
      totalPoints: basePoints + actualBonusPoints,
      remainingMonthlyBonusPoints: remainingBonusPoints,
      messageText,
      pointsCurrency: this.getPointsCurrency()
    };
  }

  // Abstract methods that must be implemented by subclasses
  protected abstract calculateRoundedAmount(amount: number): number;
  protected abstract calculateBasePoints(roundedAmount: number): number;
  protected abstract getBonusPointsEligibility(input: CalculationInput): boolean;
  protected abstract calculateBonusPoints(roundedAmount: number, input: CalculationInput): number;
  protected abstract getBonusPointsCap(): BonusPointsCap;
  protected abstract getPointsCurrency(): string;
  
  /**
   * Public accessor for the points currency
   */
  public getPointsCurrencyPublic(): string {
    return this.getPointsCurrency();
  }
}

================
File: services/calculators/CalculatorRegistry.ts
================
// src/services/calculators/CalculatorRegistry.ts
import { BaseCalculator } from './BaseCalculator';
import { RuleBasedCalculator } from './RuleBasedCalculator';
import { PaymentMethod } from '@/types';

/**
 * Registry of available calculators for different payment methods
 */
export class calculatorRegistry {
  private static calculators: Map<string, BaseCalculator> = new Map();
  
  /**
   * Initialize predefined calculators
   */
  private static initializeCalculators() {
    if (this.calculators.size > 0) return;
    
    // Add specific calculators for different card types
    this.addCalculator('uob-platinum', new RuleBasedCalculator('uob-platinum'));
    this.addCalculator('uob-signature', new RuleBasedCalculator('uob-signature'));
    this.addCalculator('uob-ladys-solitaire', new RuleBasedCalculator('uob-ladys-solitaire'));
    this.addCalculator('citibank-rewards', new RuleBasedCalculator('citibank-rewards'));
    this.addCalculator('ocbc-rewards', new RuleBasedCalculator('ocbc-rewards'));
    this.addCalculator('amex-platinum-sg', new RuleBasedCalculator('amex-platinum-sg'));
    this.addCalculator('amex-platinum-credit', new RuleBasedCalculator('amex-platinum-credit'));
    this.addCalculator('amex-cobalt', new RuleBasedCalculator('amex-cobalt'));
    this.addCalculator('amex-platinum-canada', new RuleBasedCalculator('amex-platinum-canada'));
    this.addCalculator('td-aeroplan', new RuleBasedCalculator('td-aeroplan'));
  }
  
  /**
   * Add a calculator for a specific card type
   */
  static addCalculator(cardType: string, calculator: BaseCalculator) {
    this.calculators.set(cardType, calculator);
  }
  
  /**
   * Get a calculator by card type
   */
  static getCalculator(cardType: string): BaseCalculator | null {
    this.initializeCalculators();
    return this.calculators.get(cardType) || null;
  }
  
  /**
   * Get calculator for a payment method based on issuer and name
   */
  static getCalculatorForPaymentMethod(paymentMethod: PaymentMethod): BaseCalculator {
    this.initializeCalculators();
    
    const { issuer, name } = paymentMethod;
    let calculatorKey = '';
    
    // Map the payment method to the appropriate calculator key
    if (issuer === 'UOB') {
      if (name === 'Preferred Visa Platinum') calculatorKey = 'uob-platinum';
      else if (name === 'Visa Signature') calculatorKey = 'uob-signature';
      else if (name === 'Lady\'s Solitaire') calculatorKey = 'uob-ladys-solitaire';
    } 
    else if (issuer === 'Citibank' && name === 'Rewards Visa Signature') {
      calculatorKey = 'citibank-rewards';
    }
    else if (issuer === 'OCBC' && name === 'Rewards World Mastercard') {
      calculatorKey = 'ocbc-rewards';
    }
    else if (issuer === 'American Express') {
      if (name === 'Platinum Singapore') calculatorKey = 'amex-platinum-sg';
      else if (name === 'Platinum Credit') calculatorKey = 'amex-platinum-credit';
      else if (name === 'Cobalt') calculatorKey = 'amex-cobalt';
      else if (name === 'Platinum Canada') calculatorKey = 'amex-platinum-canada';
    }
    else if (issuer === 'TD' && name === 'Aeroplan Visa Infinite') {
      calculatorKey = 'td-aeroplan';
    }
    
    // Try to get the calculator for this payment method
    let calculator = this.getCalculator(calculatorKey);
    
    // Fallback to a generic calculator if no specific one is found
    if (!calculator) {
      calculator = new RuleBasedCalculator('generic');
      console.log(`No specific calculator found for ${issuer} ${name}, using generic calculator`);
    }
    
    return calculator;
  }
}

================
File: services/calculators/RuleBasedCalculator.ts
================
import { BaseCalculator, CalculationInput, BonusPointsCap, MonthlyCap } from './BaseCalculator';
import { cardRuleService, RuleConfiguration } from '@/components/expense/cards/CardRuleService';
import { RewardRule, RewardRuleFactory } from '@/components/expense/cards/BaseRewardCard';

/**
 * A calculator implementation that uses rules from CardRuleService
 * to perform calculations based on user-defined card configurations.
 */
export class RuleBasedCalculator extends BaseCalculator {
  private cardType: string;
  private rules: RuleConfiguration[] = [];
  private mainRule: RuleConfiguration | null = null;
  private eligibilityRules: RewardRule[] = [];
  
  /**
   * Create a calculator for a specific card type
   */
  constructor(cardType: string) {
    super();
    this.cardType = cardType;
    this.loadRules();
  }
  
  /**
   * Load rules from the CardRuleService
   */
  private async loadRules() {
    try {
      // Load all rules for this card type
      this.rules = await cardRuleService.getRulesForCardType(this.cardType);
      
      // Set the main rule (first enabled rule or null if none)
      this.mainRule = this.rules.find(rule => rule.enabled) || null;
      
      // Convert rule configurations to RewardRule objects for eligibility checks
      if (this.mainRule) {
        this.eligibilityRules = this.convertRuleToEligibilityRules(this.mainRule);
      }
    } catch (error) {
      console.error(`Error loading rules for card type ${this.cardType}:`, error);
    }
  }
  
  /**
   * Convert a rule configuration to a list of RewardRule objects
   */
  private convertRuleToEligibilityRules(rule: RuleConfiguration): RewardRule[] {
    const rules: RewardRule[] = [];
    
    // Add rules based on configuration
    if (rule.isOnlineOnly) {
      rules.push(RewardRuleFactory.createOnlineTransactionRule());
    }
    
    if (rule.isContactlessOnly) {
      rules.push(RewardRuleFactory.createContactlessTransactionRule());
    }
    
    if (rule.includedMCCs && rule.includedMCCs.length > 0) {
      rules.push(RewardRuleFactory.createMCCInclusionRule(rule.includedMCCs));
    }
    
    if (rule.excludedMCCs && rule.excludedMCCs.length > 0) {
      rules.push(RewardRuleFactory.createMCCExclusionRule(rule.excludedMCCs));
    }
    
    if (rule.currencyRestrictions && rule.currencyRestrictions.length > 0) {
      // Handle special case for negated currency restrictions (!SGD)
      const negatedCurrencies = rule.currencyRestrictions
        .filter(c => c.startsWith('!'))
        .map(c => c.substring(1));
      
      const includedCurrencies = rule.currencyRestrictions
        .filter(c => !c.startsWith('!'));
      
      const currencyRule = {
        isEligible: (input: CalculationInput) => {
          if (!input.currency) return false;
          
          // Check negated currencies
          if (negatedCurrencies.length > 0 && negatedCurrencies.includes(input.currency)) {
            return false;
          }
          
          // Check included currencies
          if (includedCurrencies.length > 0) {
            return includedCurrencies.includes(input.currency);
          }
          
          return true;
        },
        calculatePoints: () => 0
      };
      
      rules.push(currencyRule);
    }
    
    // Create a compound rule if we have multiple rules
    if (rules.length > 1) {
      return [RewardRuleFactory.createAnyRule(rules)];
    }
    
    return rules.length > 0 ? rules : [];
  }
  
  /**
   * Get the current active rule
   */
  private getActiveRule(): RuleConfiguration | null {
    // Reload rules if they haven't been loaded yet
    if (this.rules.length === 0) {
      // This is a synchronous method but loadRules is async,
      // we should at least trigger the load and return a basic rule
      this.loadRules();
      
      // For UOB cards, return a basic placeholder rule to avoid returning null
      if (this.cardType.startsWith('uob-')) {
        return {
          id: 'temp-rule',
          name: 'Basic UOB Rule',
          description: 'Temporary rule',
          cardType: this.cardType,
          enabled: true,
          rounding: 'nearest5', // UOB uses nearest5 rounding
          basePointRate: 0.2,   // Default UOB base rate
          bonusPointRate: 1.8,  // Default UOB bonus rate
          monthlyCap: this.cardType.includes('platinum') ? 4000 : 3600, // UOB caps
          isOnlineOnly: false,
          isContactlessOnly: false,
          includedMCCs: [],
          excludedMCCs: [],
          pointsCurrency: 'UNI$'
        };
      }
      
      // For Citibank cards, ensure we have a basic rule
      if (this.cardType.startsWith('citibank-')) {
        return {
          id: 'temp-citibank-rule',
          name: 'Basic Citibank Rule',
          description: 'Temporary rule',
          cardType: this.cardType,
          enabled: true,
          rounding: 'floor', // Citibank uses floor rounding
          basePointRate: 1.0, // Citibank base rate
          bonusPointRate: 9.0, // Citibank bonus rate
          monthlyCap: 9000,  // Citibank cap
          isOnlineOnly: false,
          isContactlessOnly: false,
          includedMCCs: [], 
          excludedMCCs: [],
          pointsCurrency: 'ThankYou Points'
        };
      }
    }
    
    return this.mainRule;
  }
  
  /**
   * Apply the specified rounding method to the amount
   */
  calculateRoundedAmount(amount: number): number {
    const rule = this.getActiveRule();
    
    // Special handling for TD Aeroplan Visa Infinite
    if (this.cardType === 'td-aeroplan-visa-infinite') {
      return Math.round(amount); // Always round to nearest integer for TD Aeroplan
    }
    
    if (!rule) return Math.floor(amount); // Default to floor rounding
    
    switch (rule.rounding) {
      case 'floor':
        return Math.floor(amount);
      case 'ceiling':
        return Math.ceil(amount);
      case 'nearest5':
        return Math.floor(amount / 5) * 5; // Round down to nearest $5
      case 'nearest':
        return Math.round(amount);
      default:
        return Math.floor(amount);
    }
  }
  
  /**
   * Calculate base points according to the rule's base point rate
   */
  calculateBasePoints(roundedAmount: number): number {
    const rule = this.getActiveRule();
    if (!rule) return Math.floor(roundedAmount); // Default to 1 point per dollar
    
    return Math.round(roundedAmount * rule.basePointRate);
  }
  
  /**
   * Check if a transaction is eligible for bonus points
   */
  getBonusPointsEligibility(input: CalculationInput): boolean {
    // Special case for UOB Lady's Solitaire card
    if (this.cardType === 'uob-ladys-solitaire') {
      return this.isUOBLadysCategoryEligible(input);
    }
    
    // Special case for Citibank Rewards card
    if (this.cardType === 'citibank-rewards') {
      return this.isCitibankRewardsEligible(input);
    }
    
    // Handle UOB Platinum and Signature cards with default rules if no specific rules loaded
    if (this.cardType.startsWith('uob-') && 
        (this.mainRule === null || this.eligibilityRules.length === 0)) {
      
      // UOB Platinum/Signature are eligible for online OR contactless
      if (this.cardType.includes('platinum') || this.cardType.includes('signature')) {
        return (input.isOnline === true) || (input.isContactless === true);
      }
    }
    
    // If no rules or eligibility rules, not eligible
    if (!this.mainRule || this.eligibilityRules.length === 0) {
      console.log('No rules found for card type:', this.cardType);
      return false;
    }
    
    // Check each rule for eligibility
    const isEligible = this.eligibilityRules.some(rule => rule.isEligible(input));
    console.log(`Card ${this.cardType} eligibility check: ${isEligible ? 'ELIGIBLE' : 'NOT ELIGIBLE'}`);
    return isEligible;
  }
  
  /**
   * Determine if a transaction is eligible for Citibank Rewards bonus
   */
  private isCitibankRewardsEligible(input: CalculationInput): boolean {
    // Citibank Rewards has two main eligibility paths:
    
    // 1. Online transaction that isn't an airline or excluded service
    const excludedMCCs = [
      // Airlines (3000-3999)
      ...[...Array(1000)].map((_:any, i:number) => `${3000 + i}`),
      // Other exclusions
      '4511', '7512', '7011', '4111', '4112', '4789', '4411', '4722', '4723', '5962', '7012'
    ];
    
    // Check if MCC is excluded
    const mccExcluded = input.mcc && excludedMCCs.includes(input.mcc);
    
    // Check if it's an online transaction not in excluded MCCs
    const onlineEligible = input.isOnline && !mccExcluded;
    
    // 2. Department store or clothing/apparel purchase
    const includedMCCs = [
      '5311', '5611', '5621', '5631', '5641', '5651', '5655', '5661', '5691', '5699', '5948'
    ];
    
    // Check if MCC is in included list
    const mccIncluded = input.mcc && includedMCCs.includes(input.mcc);
    
    // Eligible if either condition is met
    const isEligible = onlineEligible || mccIncluded;
    
    console.log('Citibank Rewards eligibility check:', {
      mcc: input.mcc,
      isOnline: input.isOnline,
      mccExcluded,
      onlineEligible,
      mccIncluded,
      result: isEligible
    });
    
    return isEligible;
  }
  
  /**
   * Determine if a transaction is eligible for UOB Lady's bonus
   * based on selected categories in payment method
   */
  private isUOBLadysCategoryEligible(input: CalculationInput): boolean {
    // Enhanced Category MCCs for UOB Lady's card with more comprehensive Dining codes
    const categoryMCCs: Record<string, string[]> = {
      'Beauty & Wellness': ['5912', '5977', '7230', '7231', '7298', '7297'],
      'Dining': [
        // Standard dining MCCs
        '5811', '5812', '5813', '5814',
        // Food stores and grocery (some grocery stores have restaurants)
        '5411', '5499',
        // Bakeries, fast food
        '5441', '5462', '5814',
        // Caterers and food service
        '5811', '5812',
        // Cafes and restaurants
        '5813'
      ],
      'Entertainment': ['5813', '7832', '7922', '7929', '7932', '7933', '7941', '7991', '7992', '7996', '7999'],
      'Family': ['5411', '5641', '5651', '5912', '8011', '8021', '8031', '8041', '8042', '8043', '8049', '8050', '8062', '8071', '8099'],
      'Fashion': ['5311', '5611', '5621', '5631', '5651', '5655', '5661', '5691', '5699', '5948', '5944', '5950'],
      'Transport': ['4111', '4121', '4131', '4457', '4468', '4511', '4582', '4722', '4784', '4789', '5541', '5542', '7523'],
      'Travel': [
        // Properly generate travel MCCs from 3000-3299
        '3000', '3001', '3002', '3003', '3004', '3005', '3006', '3007', '3008', '3009',
        '3010', '3011', '3012', '3013', '3014', '3015', '3016', '3017', '3018', '3019',
        '3020', '3021', '3022', '3023', '3024', '3025', '3026', '3027', '3028', '3029',
        '3030', '3031', '3032', '3033', '3034', '3035', '3036', '3037', '3038', '3039',
        '3040', '3041', '3042', '3043', '3044', '3045', '3046', '3047', '3048', '3049',
        // Only showing a subset for brevity, actual implementation includes all 3000-3299
        '7011', '7512', '4411', '4511'
      ]
    };
    
    // Try to get selectedCategories from various sources
    const selectedCategories = 
      // First try paymentMethod from input
      input.paymentMethod?.selectedCategories || 
      // Then try input's own selectedCategories
      input.selectedCategories ||
      // Default to empty array if none found
      [];
    
    // Enhanced debug logging
    console.log('UOB Lady\'s card category eligibility check:', {
      mcc: input.mcc,
      selectedCategories: selectedCategories,
      paymentMethodId: input.paymentMethod?.id,
      dining_mccs: categoryMCCs['Dining']
    });
    
    // If no MCC, no eligibility check possible
    if (!input.mcc) {
      console.log('No MCC provided, not eligible for UOB Lady\'s category bonus');
      return false;
    }
    
    // If no selected categories, not eligible
    if (selectedCategories.length === 0) {
      console.log('No categories selected for UOB Lady\'s card');
      return false;
    }
    
    // Normalize MCC for comparison (remove leading zeros)
    const normalizedInputMCC = input.mcc.replace(/^0+/, '').trim();
    console.log(`Normalized transaction MCC: ${normalizedInputMCC}`);
    
    // Check if transaction MCC falls into any selected category
    for (const category of selectedCategories) {
      console.log(`Checking category: ${category}`);
      const categoryMCCList = categoryMCCs[category] || [];
      
      // Check if MCC matches any in category (with normalization)
      const matchFound = categoryMCCList.some(mcc => {
        // Normalize MCC code (remove leading zeros)
        const normalizedMCC = mcc.replace(/^0+/, '').trim();
        
        // Check for match with both original and normalized formats
        const match = normalizedMCC === normalizedInputMCC || 
                     mcc === input.mcc || 
                     mcc === '0' + normalizedInputMCC ||  // Try with leading zero
                     normalizedMCC === '0' + input.mcc;   // Try another variation
                     
        if (match) {
          console.log(`Match found! Category MCC ${mcc} matches transaction MCC ${input.mcc}`);
        }
        
        return match;
      });
      
      if (matchFound) {
        console.log(`✅ MCC ${input.mcc} found in selected category ${category}`);
        return true;
      } else {
        console.log(`❌ MCC ${input.mcc} not found in category ${category}`);
      }
    }
    
    console.log(`MCC ${input.mcc} not found in any selected categories`);
    return false;
  }
  
  /**
   * Calculate bonus points according to the rule's bonus point rate
   */
  calculateBonusPoints(roundedAmount: number): number {
    const rule = this.getActiveRule();
    if (!rule) return 0; // Default to no bonus points
    
    return Math.round(roundedAmount * rule.bonusPointRate);
  }
  
  /**
   * Get the bonus points cap from the rule
   */
  getBonusPointsCap(): BonusPointsCap {
    const rule = this.getActiveRule();
    if (!rule) return new MonthlyCap(0); // Default to no cap
    
    return new MonthlyCap(rule.monthlyCap);
  }
  
  /**
   * Get the points currency from the rule
   */
  getPointsCurrency(): string {
    const rule = this.getActiveRule();
    return rule?.pointsCurrency || 'Points';
  }
}

================
File: services/BonusPointsTrackingService.ts
================
// src/services/BonusPointsTrackingService.ts
import { Transaction, PaymentMethod } from '@/types';
import { supabase } from '@/integrations/supabase/client';
import { rewardCalculationService } from '@/services/RewardCalculationService';

/**
 * Service for tracking used bonus points per payment method and month
 */
export class BonusPointsTrackingService {
  private static instance: BonusPointsTrackingService;
  
  // In-memory cache for performance
  private bonusPointsCache: Map<string, number> = new Map();
  
  private constructor() {}
  
  /**
   * Get the singleton instance of the BonusPointsTrackingService
   */
  public static getInstance(): BonusPointsTrackingService {
    if (!BonusPointsTrackingService.instance) {
      BonusPointsTrackingService.instance = new BonusPointsTrackingService();
    }
    return BonusPointsTrackingService.instance;
  }
  
  /**
   * Get used bonus points for a payment method in the current month
   */
  public async getUsedBonusPoints(
    paymentMethodId: string,
    year: number = new Date().getFullYear(),
    month: number = new Date().getMonth()
  ): Promise<number> {
    // Check cache first
    const cacheKey = `${paymentMethodId}-${year}-${month}`;
    if (this.bonusPointsCache.has(cacheKey)) {
      return this.bonusPointsCache.get(cacheKey) || 0;
    }
    
    try {
      // Query the database for used bonus points
      const { data, error } = await supabase
        .from('bonus_points_movements')
        .select('bonus_points')
        .eq('payment_method_id', paymentMethodId)
        .gte('created_at', new Date(year, month, 1).toISOString())
        .lt('created_at', new Date(year, month + 1, 1).toISOString());
        
      if (error) {
        console.error('Error fetching bonus points:', error);
        return 0;
      }
      
      // Sum up the bonus points
      const totalBonusPoints = data.reduce((sum, record) => sum + record.bonus_points, 0);
      
      // Update cache
      this.bonusPointsCache.set(cacheKey, totalBonusPoints);
      
      return totalBonusPoints;
    } catch (error) {
      console.error('Exception in getUsedBonusPoints:', error);
      return 0;
    }
  }
  
  /**
   * Record a bonus points movement
   */
  public async recordBonusPointsMovement(
    transactionId: string,
    paymentMethodId: string,
    bonusPoints: number
  ): Promise<boolean> {
    try {
      // Skip recording if bonus points is zero
      if (bonusPoints === 0) return true;
      
      // Record the movement in the database
      const { error } = await supabase
        .from('bonus_points_movements')
        .insert({
          transaction_id: transactionId,
          payment_method_id: paymentMethodId,
          bonus_points: bonusPoints
        });
        
      if (error) {
        console.error('Error recording bonus points movement:', error);
        return false;
      }
      
      // Invalidate cache
      const now = new Date();
      const cacheKey = `${paymentMethodId}-${now.getFullYear()}-${now.getMonth()}`;
      this.bonusPointsCache.delete(cacheKey);
      
      return true;
    } catch (error) {
      console.error('Exception in recordBonusPointsMovement:', error);
      return false;
    }
  }
  
  /**
   * Calculate used bonus points from a set of transactions
   * Useful when we don't have direct access to the bonus_points_movements table
   */
  public calculateUsedBonusPointsFromTransactions(
    transactions: Transaction[],
    paymentMethodId: string,
    year: number = new Date().getFullYear(),
    month: number = new Date().getMonth()
  ): number {
    // Filter transactions by payment method and month
    const relevantTransactions = transactions.filter(tx => {
      const txDate = new Date(tx.date);
      return tx.paymentMethod.id === paymentMethodId &&
             txDate.getFullYear() === year &&
             txDate.getMonth() === month;
    });
    
    // Calculate total bonus points used
    let totalBonusPoints = 0;
    
    for (const tx of relevantTransactions) {
      // Calculate the bonus points for this transaction
      const result = rewardCalculationService.calculatePoints(tx, 0); // Assuming no cap applied yet
      totalBonusPoints += result.bonusPoints;
    }
    
    return totalBonusPoints;
  }
  
  /**
   * Get remaining bonus points for a payment method
   */
  public async getRemainingBonusPoints(
    paymentMethod: PaymentMethod,
    usedBonusPoints?: number
  ): Promise<number> {
    // Get the card info to determine the monthly cap
    // This should ideally be fetched from a centralized configuration or card registry
    const monthlyCapByCard: Record<string, number> = {
      'UOB Preferred Visa Platinum': 4000,
      'Citibank Rewards Visa Signature': 4000,
      'UOB Visa Signature': 8000,
      'UOB Lady\'s Solitaire': 7200
    };
    
    // Safely access card name
    const cardName = paymentMethod.name || '';
    const defaultCap = 0; // No cap by default
    const cap = monthlyCapByCard[cardName] || defaultCap;
    
    // If cap is 0 (unlimited), return a large number
    if (cap === 0) return Number.MAX_SAFE_INTEGER;
    
    // If usedBonusPoints is provided, use it directly
    if (usedBonusPoints !== undefined) {
      return Math.max(0, cap - usedBonusPoints);
    }
    
    // Otherwise, fetch from database
    const actualUsedPoints = await this.getUsedBonusPoints(paymentMethod.id);
    return Math.max(0, cap - actualUsedPoints);
  }
  
  /**
   * Clear the bonus points cache
   */
  public clearCache(): void {
    this.bonusPointsCache.clear();
  }
}

// Export a singleton instance for easy access
export const bonusPointsTrackingService = BonusPointsTrackingService.getInstance();

================
File: services/CurrencyService.ts
================
import { Currency, PaymentMethod } from "@/types";

/**
 * Service for handling all currency-related operations including
 * formatting, conversion, and currency information.
 */
export class CurrencyService {
  /**
   * List of currencies that don't use decimal places
   */
  private static readonly NO_DECIMAL_CURRENCIES = ["JPY", "VND", "IDR", "TWD"];

  /**
   * Currency symbols mapping
   */
  private static readonly CURRENCY_SYMBOLS: Record<Currency, string> = {
    USD: "$",
    EUR: "€",
    GBP: "£",
    JPY: "¥",
    AUD: "A$",
    CAD: "C$",
    CNY: "¥",
    INR: "₹",
    TWD: "NT$",
    SGD: "S$",
    VND: "₫",
    IDR: "Rp",
    THB: "฿",
    MYR: "RM",
  };

  /**
   * Default exchange rates - in a real app, these would come from an API
   */
  private static readonly DEFAULT_EXCHANGE_RATES: Record<
    Currency,
    Record<Currency, number>
  > = {
    USD: {
      USD: 1,
      EUR: 0.93,
      GBP: 0.79,
      JPY: 151.77,
      AUD: 1.53,
      CAD: 1.37,
      CNY: 7.26,
      INR: 83.42,
      TWD: 32.27,
      SGD: 1.35,
      VND: 25305,
      IDR: 16158,
      THB: 36.17,
      MYR: 4.72,
    },
    EUR: {
      USD: 1.08,
      EUR: 1,
      GBP: 0.85,
      JPY: 163.59,
      AUD: 1.65,
      CAD: 1.47,
      CNY: 7.83,
      INR: 89.93,
      TWD: 34.78,
      SGD: 1.45,
      VND: 27276,
      IDR: 17416,
      THB: 38.99,
      MYR: 5.09,
    },
    GBP: {
      USD: 1.27,
      EUR: 1.18,
      GBP: 1,
      JPY: 192.96,
      AUD: 1.94,
      CAD: 1.74,
      CNY: 9.24,
      INR: 106.06,
      TWD: 41.04,
      SGD: 1.71,
      VND: 32179,
      IDR: 20548,
      THB: 46.0,
      MYR: 6.0,
    },
    JPY: {
      USD: 0.0066,
      EUR: 0.0061,
      GBP: 0.0052,
      JPY: 1,
      AUD: 0.01,
      CAD: 0.009,
      CNY: 0.048,
      INR: 0.55,
      TWD: 0.21,
      SGD: 0.0089,
      VND: 166.73,
      IDR: 106.43,
      THB: 0.24,
      MYR: 0.031,
    },
    AUD: {
      USD: 0.65,
      EUR: 0.61,
      GBP: 0.52,
      JPY: 99.06,
      AUD: 1,
      CAD: 0.89,
      CNY: 4.74,
      INR: 54.47,
      TWD: 21.08,
      SGD: 0.88,
      VND: 16524,
      IDR: 10551,
      THB: 23.61,
      MYR: 3.08,
    },
    CAD: {
      USD: 0.73,
      EUR: 0.68,
      GBP: 0.58,
      JPY: 111.31,
      AUD: 1.12,
      CAD: 1,
      CNY: 5.32,
      INR: 61.2,
      TWD: 23.68,
      SGD: 0.99,
      VND: 18564,
      IDR: 11854,
      THB: 26.53,
      MYR: 3.46,
    },
    CNY: {
      USD: 0.14,
      EUR: 0.13,
      GBP: 0.11,
      JPY: 20.9,
      AUD: 0.21,
      CAD: 0.19,
      CNY: 1,
      INR: 11.49,
      TWD: 4.45,
      SGD: 0.19,
      VND: 3486,
      IDR: 2225,
      THB: 4.98,
      MYR: 0.65,
    },
    INR: {
      USD: 0.012,
      EUR: 0.011,
      GBP: 0.0094,
      JPY: 1.82,
      AUD: 0.018,
      CAD: 0.016,
      CNY: 0.087,
      INR: 1,
      TWD: 0.39,
      SGD: 0.016,
      VND: 303.33,
      IDR: 193.69,
      THB: 0.43,
      MYR: 0.057,
    },
    TWD: {
      USD: 0.031,
      EUR: 0.029,
      GBP: 0.024,
      JPY: 4.71,
      AUD: 0.047,
      CAD: 0.042,
      CNY: 0.22,
      INR: 2.59,
      TWD: 1,
      SGD: 0.042,
      VND: 784.16,
      IDR: 500.71,
      THB: 1.12,
      MYR: 0.15,
    },
    SGD: {
      USD: 0.74,
      EUR: 0.69,
      GBP: 0.58,
      JPY: 112.8,
      AUD: 1.14,
      CAD: 1.01,
      CNY: 5.39,
      INR: 61.97,
      TWD: 23.98,
      SGD: 1,
      VND: 18796,
      IDR: 12005,
      THB: 26.88,
      MYR: 3.51,
    },
    VND: {
      USD: 0.00004,
      EUR: 0.000037,
      GBP: 0.000031,
      JPY: 0.006,
      AUD: 0.000061,
      CAD: 0.000054,
      CNY: 0.00029,
      INR: 0.0033,
      TWD: 0.0013,
      SGD: 0.000053,
      VND: 1,
      IDR: 0.64,
      THB: 0.0014,
      MYR: 0.00019,
    },
    IDR: {
      USD: 0.000062,
      EUR: 0.000057,
      GBP: 0.000049,
      JPY: 0.0094,
      AUD: 0.000095,
      CAD: 0.000084,
      CNY: 0.00045,
      INR: 0.0052,
      TWD: 0.002,
      SGD: 0.000083,
      VND: 1.57,
      IDR: 1,
      THB: 0.0022,
      MYR: 0.00029,
    },
    THB: {
      USD: 0.028,
      EUR: 0.026,
      GBP: 0.022,
      JPY: 4.2,
      AUD: 0.042,
      CAD: 0.038,
      CNY: 0.2,
      INR: 2.31,
      TWD: 0.89,
      SGD: 0.037,
      VND: 699.81,
      IDR: 446.86,
      THB: 1,
      MYR: 0.13,
    },
    MYR: {
      USD: 0.21,
      EUR: 0.2,
      GBP: 0.17,
      JPY: 32.15,
      AUD: 0.32,
      CAD: 0.29,
      CNY: 1.54,
      INR: 17.67,
      TWD: 6.84,
      SGD: 0.29,
      VND: 5360,
      IDR: 3423,
      THB: 7.66,
      MYR: 1,
    },
  };

  /**
   * Currency options for dropdown selects
   */
  private static readonly CURRENCY_OPTIONS: {
    value: Currency;
    label: string;
  }[] = [
    { value: "USD", label: "USD - US Dollar ($)" },
    { value: "EUR", label: "EUR - Euro (€)" },
    { value: "GBP", label: "GBP - British Pound (£)" },
    { value: "JPY", label: "JPY - Japanese Yen (¥)" },
    { value: "AUD", label: "AUD - Australian Dollar (A$)" },
    { value: "CAD", label: "CAD - Canadian Dollar (C$)" },
    { value: "CNY", label: "CNY - Chinese Yuan (¥)" },
    { value: "INR", label: "INR - Indian Rupee (₹)" },
    { value: "TWD", label: "TWD - New Taiwan Dollar (NT$)" },
    { value: "SGD", label: "SGD - Singapore Dollar (S$)" },
    { value: "VND", label: "VND - Vietnamese Dong (₫)" },
    { value: "IDR", label: "IDR - Indonesian Rupiah (Rp)" },
    { value: "THB", label: "THB - Thai Baht (฿)" },
    { value: "MYR", label: "MYR - Malaysian Ringgit (RM)" },
  ];

  /**
   * Formats a currency amount with the appropriate symbol and formatting rules
   *
   * @param amount - Amount to format
   * @param currency - Currency code
   * @returns Formatted currency string (e.g., "$123.45")
   */
  static format(amount: number, currency: Currency): string {
    // Handle edge cases where currency might be undefined or invalid
    if (!currency || !Object.keys(this.CURRENCY_SYMBOLS).includes(currency)) {
      console.warn(
        `Invalid currency provided: ${currency}, using USD as fallback`
      );
      currency = "USD" as Currency;
    }

    // Get decimal places based on currency type
    const decimalPlaces = this.NO_DECIMAL_CURRENCIES.includes(currency) ? 0 : 2;

    // Format the number part with appropriate decimal places
    const formatter = new Intl.NumberFormat("en-US", {
      style: "decimal", // Use decimal style to avoid built-in currency symbols
      minimumFractionDigits: decimalPlaces,
      maximumFractionDigits: decimalPlaces,
    });

    // Get the correct currency symbol from our mapping
    const symbol = this.CURRENCY_SYMBOLS[currency];

    // Return the formatted string with our custom symbol
    return `${symbol}${formatter.format(amount)}`;
  }

  /**
   * Converts an amount from one currency to another
   *
   * @param amount - Amount to convert
   * @param fromCurrency - Source currency code
   * @param toCurrency - Target currency code
   * @param paymentMethod - Optional payment method with custom conversion rates
   * @returns Converted amount in the target currency
   */
  static convert(
    amount: number,
    fromCurrency: Currency,
    toCurrency: Currency,
    paymentMethod?: PaymentMethod
  ): number {
    if (fromCurrency === toCurrency) return amount;

    // Check if payment method exists before trying to access its properties
    if (
      paymentMethod?.conversionRate &&
      paymentMethod.conversionRate[toCurrency] !== undefined
    ) {
      return amount * paymentMethod.conversionRate[toCurrency];
    }

    // Add validation for currency codes to prevent accessing undefined rates
    if (!this.DEFAULT_EXCHANGE_RATES[fromCurrency]) {
      console.error(`Invalid source currency: ${fromCurrency}`);
      return amount; // Return original amount if conversion not possible
    }

    if (!this.DEFAULT_EXCHANGE_RATES[fromCurrency][toCurrency]) {
      console.error(
        `Invalid target currency or exchange rate not available: ${fromCurrency} to ${toCurrency}`
      );
      return amount; // Return original amount if conversion not possible
    }

    // Now we can safely access the exchange rate
    return amount * this.DEFAULT_EXCHANGE_RATES[fromCurrency][toCurrency];
  }

  /**
   * Gets the symbol for a given currency
   *
   * @param currency - Currency code
   * @returns Currency symbol (e.g., "$" for USD)
   */
  static getSymbol(currency: Currency): string {
    return this.CURRENCY_SYMBOLS[currency] || currency;
  }

  /**
   * Gets the list of currency options for dropdown menus
   *
   * @returns Array of currency options with value and label
   */
  static getCurrencyOptions(): { value: Currency; label: string }[] {
    return [...this.CURRENCY_OPTIONS];
  }

  /**
   * Gets the exchange rate between two currencies
   *
   * @param fromCurrency - Source currency code
   * @param toCurrency - Target currency code
   * @returns Exchange rate or 1 if conversion not possible
   */
  static getExchangeRate(fromCurrency: Currency, toCurrency: Currency): number {
    if (fromCurrency === toCurrency) return 1;

    if (
      !this.DEFAULT_EXCHANGE_RATES[fromCurrency] ||
      !this.DEFAULT_EXCHANGE_RATES[fromCurrency][toCurrency]
    ) {
      console.error(
        `Exchange rate not available: ${fromCurrency} to ${toCurrency}`
      );
      return 1;
    }

    return this.DEFAULT_EXCHANGE_RATES[fromCurrency][toCurrency];
  }
}

================
File: services/RewardCalculationService.ts
================
// src/services/RewardCalculationService.ts
import { Transaction, PaymentMethod } from '@/types';
import { CardRegistry } from '@/components/expense/cards/CardRegistry';
import { calculatorRegistry } from './calculators/CalculatorRegistry';
import { BaseCalculator, CalculationInput, CalculationResult } from './calculators/BaseCalculator';

// Define a transaction type that has more relaxed requirements for simulation
interface SimulatedTransaction {
  id: string;
  date: string;
  merchant: {
    id: string;
    name: string;
    mcc?: { code: string; description: string };
    isOnline?: boolean;
  };
  amount: number;
  currency: any; // Using any to avoid Currency type issues
  paymentMethod: PaymentMethod;
  paymentAmount: number;
  paymentCurrency: any; // Using any to avoid Currency type issues
  isContactless?: boolean;
  rewardPoints?: number;
}

// Define fixed return type for calculations (same as previous interface for API compatibility)
interface PointsCalculation {
  totalPoints: number;
  basePoints: number;
  bonusPoints: number;
  pointsCurrency?: string;
  remainingMonthlyBonusPoints?: number;
}

/**
 * Centralized service that handles all reward point calculations
 * using the calculator architecture as the single source of truth.
 */
export class RewardCalculationService {
  private static instance: RewardCalculationService;
  
  private constructor() {}
  
  /**
   * Get the singleton instance of the RewardCalculationService
   */
  public static getInstance(): RewardCalculationService {
    if (!RewardCalculationService.instance) {
      RewardCalculationService.instance = new RewardCalculationService();
    }
    return RewardCalculationService.instance;
  }

  /**
   * Get the appropriate calculator for a payment method
   */
  private getCalculator(paymentMethod: PaymentMethod): BaseCalculator {
    return calculatorRegistry.getCalculatorForPaymentMethod(paymentMethod);
  }
  
  /**
   * Convert a transaction to a calculator input
   */
  private transactionToCalculationInput(
    transaction: Transaction | SimulatedTransaction, 
    usedBonusPoints: number = 0
  ): CalculationInput {
    // Determine if we should use paymentAmount (for currency conversion scenarios)
    const amountToUse = transaction.currency !== transaction.paymentCurrency 
      ? transaction.paymentAmount 
      : transaction.amount;
      
    return {
      amount: amountToUse,
      currency: transaction.paymentCurrency, // Use payment currency for calculation
      mcc: transaction.merchant?.mcc?.code,
      merchantName: transaction.merchant?.name,
      isOnline: transaction.merchant?.isOnline,
      isContactless: transaction.isContactless,
      usedBonusPoints,
      paymentMethod: transaction.paymentMethod, // Include full paymentMethod for selectedCategories
      // Additional fields could be added here for specialized card calculators
    };
  }
  
  /**
   * Calculate reward points for a transaction
   */
  public calculatePoints(transactionInput: Transaction | SimulatedTransaction, usedBonusPoints: number = 0): PointsCalculation {
    const { paymentMethod } = transactionInput;
    
    // Skip calculation for cash payments
    if (!paymentMethod || paymentMethod.type === 'cash') {
      return {
        totalPoints: 0,
        basePoints: 0,
        bonusPoints: 0
      };
    }
    
    try {
      // Get the appropriate calculator for this payment method
      const calculator = this.getCalculator(paymentMethod);
      
      // Convert transaction to calculator input
      const input = this.transactionToCalculationInput(transactionInput, usedBonusPoints);
      
      // Use the calculator to calculate rewards
      const result = calculator.calculateRewards(input);
      
      return {
        totalPoints: result.totalPoints,
        basePoints: result.basePoints,
        bonusPoints: result.bonusPoints,
        pointsCurrency: result.pointsCurrency,
        remainingMonthlyBonusPoints: result.remainingMonthlyBonusPoints
      };
    } catch (error) {
      console.error('Error calculating rewards:', error);
      // Fallback to basic calculation - using Math.round for proper rounding
      const basePoints = Math.round(transactionInput.amount);
      return {
        totalPoints: basePoints,
        basePoints,
        bonusPoints: 0
      };
    }
  }
  
  /**
   * Simulate reward points for a hypothetical transaction
   */
  public simulatePoints(
    amount: number,
    currency: string,
    paymentMethod: PaymentMethod,
    mcc?: string,
    merchantName?: string,
    isOnline?: boolean,
    isContactless?: boolean,
    usedBonusPoints: number = 0
  ): PointsCalculation {
    try {
      // Determine if currency conversion is needed
      const isCurrencyDifferent = currency !== paymentMethod.currency;
      
      // Create a simulated transaction
      const simulatedTransaction: SimulatedTransaction = {
        id: 'simulated',
        date: new Date().toISOString(),
        merchant: {
          id: 'simulated',
          name: merchantName || 'Simulated Merchant',
          mcc: mcc ? { code: mcc, description: '' } : undefined,
          isOnline: !!isOnline
        },
        amount: isCurrencyDifferent ? amount : amount, // Original amount
        currency: isCurrencyDifferent ? currency : currency, // Original currency
        paymentMethod,
        paymentAmount: amount, // For consistency, this is the amount in payment currency
        paymentCurrency: isCurrencyDifferent ? paymentMethod.currency : currency, // Payment currency
        isContactless: !!isContactless
      };
      
      // Use the main calculation method with the simulated transaction
      return this.calculatePoints(simulatedTransaction, usedBonusPoints);
    } catch (error) {
      console.error('Error in simulatePoints:', error);
      // Fallback to basic calculation - using Math.round for proper rounding
      return {
        totalPoints: Math.round(amount),
        basePoints: Math.round(amount),
        bonusPoints: 0
      };
    }
  }
  
  /**
   * Get the points currency for a payment method
   */
  public getPointsCurrency(paymentMethod: PaymentMethod): string {
    if (!paymentMethod) return 'Points';
    
    try {
      // Map specific issuers and card types to their points currencies
      if (paymentMethod.issuer === 'UOB') {
        return 'UNI$';
      } 
      else if (paymentMethod.issuer === 'Citibank') {
        return 'ThankYou Points';
      }
      else if (paymentMethod.issuer === 'OCBC') {
        return 'OCBC$';
      }
      else if (paymentMethod.issuer === 'American Express') {
        if (paymentMethod.name === 'Platinum Singapore' || paymentMethod.name === 'Platinum Credit') {
          return 'SG MR Points';
        }
        else if (paymentMethod.name === 'Cobalt' || paymentMethod.name === 'Platinum Canada') {
          return 'CA MR Points';
        }
        // Default for other Amex cards
        return 'Membership Rewards';
      }
      else if (paymentMethod.issuer === 'TD' && paymentMethod.name === 'Aeroplan Visa Infinite') {
        return 'Aeroplan Points';
      }
      
      // Try to get from calculator as a fallback
      try {
        const calculator = this.getCalculator(paymentMethod);
        return calculator.getPointsCurrencyPublic();
      } catch (error) {
        // Ignore and continue to further fallback options
      }
      
      // Fallback to CardRegistry if calculator is unavailable
      const cardInfo = CardRegistry.findCard(
        paymentMethod.issuer || '',
        paymentMethod.name || ''
      );
      
      return cardInfo?.pointsCurrency || 
        (paymentMethod.issuer ? `${paymentMethod.issuer} Points` : 'Points');
    } catch (error) {
      console.error('Error getting points currency:', error);
      return paymentMethod.issuer ? `${paymentMethod.issuer} Points` : 'Points';
    }
  }
}

// Export a singleton instance for easy access
export const rewardCalculationService = RewardCalculationService.getInstance();

================
File: types/dashboard.ts
================
// src/types/dashboard.ts
import { Transaction, Currency } from '@/types';
import { TimeframeTab } from '@/utils/transactionProcessor';

/**
 * Dashboard metrics
 */
export interface DashboardMetrics {
  totalExpenses: number;
  transactionCount: number;
  averageAmount: number;
  totalRewardPoints: number;
  percentageChange: number;
  transactionVelocity?: number;
  hasEnoughData?: boolean;
  totalReimbursed?: number;
}

/**
 * Chart data structure
 */
export interface ChartDataItem {
  name: string;
  value: number;
  color: string;
}

export interface DashboardChartData {
  paymentMethods: ChartDataItem[];
  categories: ChartDataItem[];
  dayOfWeekSpending?: Record<string, number>;
  spendingTrends: {
    labels: string[];
    datasets: {
      label: string;
      data: number[];
    }[];
  };
}

/**
 * Top values structure
 */
export interface DashboardTopValues {
  paymentMethod?: { name: string; value: number };
  category?: { name: string; value: number };
}

/**
 * Complete dashboard data structure
 */
export interface DashboardData {
  filteredTransactions: Transaction[];
  metrics: DashboardMetrics;
  top: DashboardTopValues;
  charts: DashboardChartData;
}

/**
 * Options for dashboard data processing
 */
export interface DashboardOptions {
  transactions: Transaction[];
  displayCurrency: Currency;
  timeframe: TimeframeTab;
  useStatementMonth: boolean;
  statementCycleDay: number;
  previousPeriodTransactions?: Transaction[];
  calculateDayOfWeekMetrics?: boolean;
  calculateVelocity?: boolean;
  lastUpdate?: number;
}

export interface DashboardConfig {
  defaultCurrency: Currency;
  defaultTimeframe: TimeframeTab;
  defaultStatementDay: number;
  defaultUseStatementMonth: boolean;
}

================
File: types/dashboardTypes.ts
================
// src/types/dashboardTypes.ts
import { Transaction, Currency, PaymentMethod } from '@/types';
import { TimeframeTab } from '@/utils/transactionProcessor';
import { ChartDataItem } from '@/utils/dashboardUtils';

/**
 * Dashboard metrics
 */
export interface DashboardMetrics {
  totalExpenses: number;
  transactionCount: number;
  averageAmount: number;
  totalRewardPoints: number;
  percentageChange: number;
  transactionVelocity?: number;
  hasEnoughData?: boolean;
  totalReimbursed?: number; // New: Total reimbursed amount
}

/**
 * Chart data structure
 */
export interface DashboardChartData {
  paymentMethods: ChartDataItem[];
  categories: ChartDataItem[];
  dayOfWeekSpending?: Record<string, number>;
  spendingTrends: {
    labels: string[];
    datasets: {
      label: string;
      data: number[];
    }[];
  };
}

/**
 * Top values structure
 */
export interface DashboardTopValues {
  paymentMethod?: { name: string; value: number };
  category?: { name: string; value: number };
}

/**
 * Complete dashboard data structure
 */
export interface DashboardData {
  filteredTransactions: Transaction[];
  metrics: DashboardMetrics;
  top: DashboardTopValues;
  charts: DashboardChartData;
}

/**
 * Options for dashboard data processing
 */
export interface DashboardOptions {
  transactions: Transaction[];
  displayCurrency: Currency;
  timeframe: TimeframeTab;
  useStatementMonth: boolean;
  statementCycleDay: number;
  previousPeriodTransactions?: Transaction[];
  calculateDayOfWeekMetrics?: boolean;
  calculateVelocity?: boolean;
  lastUpdate?: number;
}

================
File: types/index.ts
================
export type Currency = 'USD' | 'EUR' | 'GBP' | 'JPY' | 'AUD' | 'CAD' | 'CNY' | 'INR' | 'TWD' | 'SGD' | 'VND' | 'IDR' | 'THB' | 'MYR';

export type MerchantCategoryCode = {
  code: string;
  description: string;
};

export type PaymentMethodType = 'cash' | 'credit_card';

export interface RewardRule {
  id: string;
  name: string;
  description: string;
  type: 'mcc' | 'merchant' | 'currency' | 'spend_threshold' | 'online' | 'contactless' | 'generic';
  condition: string | string[]; // MCC code, merchant name, currency, threshold, or special conditions
  pointsMultiplier: number;
  minSpend?: number;
  maxSpend?: number;
  pointsCurrency?: string; // Added this property to fix the TypeScript error
}

export interface PaymentMethod {
  id: string;
  name: string;
  type: PaymentMethodType;
  currency: Currency;
  rewardRules: RewardRule[];
  statementStartDay?: number; // 1-31, day of month when statement begins
  isMonthlyStatement?: boolean; // true = statement month, false = calendar month
  active: boolean;
  lastFourDigits?: string; // For credit cards
  issuer?: string; // For credit cards
  icon?: string; // Icon identifier
  color?: string; // Color for the card
  imageUrl?: string; // URL to custom card image
  conversionRate?: Record<Currency, number>; // Exchange rates for currency conversion
  selectedCategories?: string[]; // Selected categories for category-based cards like UOB Lady's
}

export interface Merchant {
  id: string;
  name: string;
  address?: string;
  coordinates?: {
    latitude: number;
    longitude: number;
  };
  mcc?: MerchantCategoryCode;
  isOnline: boolean;
}

export interface Transaction {
  id: string;
  date: string;
  merchant: Merchant;
  amount: number;
  currency: Currency;
  paymentMethod: PaymentMethod;
  paymentAmount: number;
  paymentCurrency: Currency;
  rewardPoints: number;
  basePoints?: number; 
  notes?: string;
  category?: string;
  tags?: string[];
  isContactless?: boolean;
  is_deleted?: boolean; // Add this field to match the backend schema
  reimbursementAmount?: number; // Add reimbursement amount to track expense reimbursements
}

export interface ExpenseSummary {
  totalExpenses: number;
  byCategory: Record<string, number>;
  byPaymentMethod: Record<string, number>;
  byCurrency: Record<Currency, number>;
  rewardPointsEarned: number;
}

================
File: utils/constants/mcc.ts
================
// MCC codes for merchant category classification
export const MCC_CODES = (() => {
  // Original list of codes
  const originalCodes = [
    { code: '1520', description: 'General Contractors–Residential and Commercial' },    
    { code: '5411', description: 'Grocery Stores & Supermarkets' },
    { code: '5812', description: 'Restaurants & Eating Places' },
    { code: '5814', description: 'Fast Food Restaurants' },
    { code: '5912', description: 'Drug Stores & Pharmacies' },
    { code: '5311', description: 'Department Stores' },
    { code: '5541', description: 'Gas Stations' },
    { code: '4121', description: 'Taxi & Limousines' },
    { code: '4112', description: 'Passenger Railways' },
    { code: '3000', description: 'Airlines' },
    { code: '7011', description: 'Hotels & Motels' },
    { code: '4814', description: 'Telecommunication Services' },
    { code: '4899', description: 'Cable & Streaming Services' },
    { code: '5699', description: 'Apparel & Accessories' },
    { code: '5945', description: 'Hobby, Toy & Game Shops' },
    { code: '7832', description: 'Movie Theaters' },
    { code: '5732', description: 'Electronics & Appliances' },
    
    { code: '5422', description: 'Freezer and Locker Meat Provisioners' },
    { code: '5441', description: 'Candy, Nut and Confectionery Stores' },
    { code: '5451', description: 'Dairy Products Stores' },
    { code: '5462', description: 'Bakeries' },
    { code: '5499', description: 'Miscellaneous Food Stores–Convenience Stores, Markets, Specialty Stores' },
    { code: '5811', description: 'Caterers' },
    { code: '5813', description: 'Bars, Cocktail Lounges, Discotheques, Nightclubs and Taverns' },
    { code: '5921', description: 'Package Stores–Beer, Wine and Liquor' },
    
    { code: '4225', description: 'Public Warehousing–Farm Products, Refrigerated Goods, Household Goods Storage' },
    { code: '5021', description: 'Office and Commercial Furniture' },
    { code: '5039', description: 'Construction Materials Not Elsewhere Classified' },
    { code: '5044', description: 'Office, Photographic, Photocopy and Microfilm Equipment' },
    { code: '5045', description: 'Computers, Computer Peripheral Equipment, Software' },
    { code: '5046', description: 'Commercial Equipment Not Elsewhere Classified' },
    { code: '5065', description: 'Electrical Parts and Equipment' },
    { code: '5072', description: 'Hardware Equipment and Supplies' },
    { code: '5074', description: 'Plumbing and Heating Equipment' },
    { code: '5094', description: 'Precious Stones and Metals, Watches and Jewelry' },
    { code: '5111', description: 'Stationery, Office Supplies, Printing and Writing Paper' },
    { code: '5137', description: 'Men\'s, Women\'s and Children\'s Uniforms and Commercial Clothing' },
    { code: '5139', description: 'Commercial Footware' },
    { code: '5192', description: 'Books, Periodicals and Newspapers' },
    { code: '5193', description: 'Florists Supplies, Nursery Stock and Flowers' },
    { code: '5200', description: 'Home Supply Warehouse Stores' },
    { code: '5211', description: 'Building Materials, Lumber Stores' },
    { code: '5231', description: 'Glass, Paint, Wallpaper Stores' },
    { code: '5251', description: 'Hardware Stores' },
    { code: '5261', description: 'Lawn and Garden Supply Stores' },
    { code: '5262', description: 'Marketplaces' },
    { code: '5271', description: 'Mobile Home Dealers' },
    { code: '5300', description: 'Wholesale Clubs' },
    { code: '5309', description: 'Duty Free Stores' },
    { code: '5310', description: 'Discount Stores' },
    { code: '5331', description: 'Variety Stores' },
    { code: '5399', description: 'Miscellaneous General Merchandise Stores' },
    { code: '5531', description: 'Automobile Supply Stores Or Home Supply Stores' },
    { code: '5611', description: 'Men\'s and Boys\' Clothing and Accessories Stores' },
    { code: '5621', description: 'Women\'s Ready to Wear Stores' },
    { code: '5631', description: 'Women\'s Accessory and Specialty Stores' },
    { code: '5641', description: 'Children\'s and Infants\' Wear Stores' },
    { code: '5651', description: 'Family Clothing Stores' },
    { code: '5655', description: 'Sports Apparel, and Riding Apparel Stores' },
    { code: '5661', description: 'Shoe Stores' },
    { code: '5681', description: 'Furriers and Fur Shops' },
    { code: '5691', description: 'Men\'s and Women\'s Clothing Stores' },
    { code: '5697', description: 'Alterations, Mending, Seamstresses, Tailors' },
    { code: '5698', description: 'Wig and Toupee Shops' },
    { code: '5699', description: 'Accessory and Apparel Stores–Miscellaneous' },
    { code: '5712', description: 'Equipment, Furniture and Home Furnishings Stores' },
    { code: '5713', description: 'Floor Covering Stores' },
    { code: '5714', description: 'Drapery, Upholstery and Window Coverings Stores' },
    { code: '5718', description: 'Fireplace, Fireplace Screens and Accessories Stores' },
    { code: '5719', description: 'Miscellaneous House Furnishing Specialty Shops' },
    { code: '5722', description: 'Household Appliance Stores' },
    { code: '5732', description: 'Electronics Sales' },
    { code: '5733', description: 'Music Stores–Musical Instruments, Pianos and Sheet Music' },
    { code: '5734', description: 'Computer Software Stores' },
    { code: '5735', description: 'Record Shops' },
    { code: '5815', description: 'Digital Goods: Books, Movies, Music' },
    { code: '5816', description: 'Digital Goods: Games' },
    { code: '5817', description: 'Digital Goods: Applications (Excludes Games)' },
    { code: '5818', description: 'Digital Goods: Large Digital Goods Merchant' },
    { code: '5931', description: 'Second Hand Stores, Used Merchandise Stores' },
    { code: '5932', description: 'Antique Shops–Sales, Repairs and Restoration Services' },
    { code: '5933', description: 'Pawn Shops' },
    { code: '5937', description: 'Antique Reproduction Stores' },
    { code: '5940', description: 'Bicycle Shops–Sales and Service' },
    { code: '5941', description: 'Sporting Goods Stores' },
    { code: '5942', description: 'Book Stores' },
    { code: '5943', description: 'Office, School Supply and Stationery Stores' },
    { code: '5944', description: 'Clock, Jewelry, Watch and Silverware Stores' },
    { code: '5946', description: 'Camera and Photographic Supply Stores' },
    { code: '5947', description: 'Card, Gift, Novelty and Souvenir Shops' },
    { code: '5948', description: 'Leather Goods and Luggage Stores' },
    { code: '5949', description: 'Fabric, Needlework, Piece Goods and Sewing Stores' },
    { code: '5950', description: 'Crystal and Glassware Stores' },
    { code: '5963', description: 'Door-to-Door Sales' },
    { code: '5964', description: 'Direct Marketing–Catalog Merchants' },
    { code: '5970', description: 'Artist Supply Stores, Craft Shops' },
    { code: '5971', description: 'Art Dealers and Galleries' },
    { code: '5972', description: 'Stamp and Coin Stores–Philatelic and Numismatic Supplies' },
    { code: '5973', description: 'Religious Goods Stores' },
    { code: '5977', description: 'Cosmetic Stores' },
    { code: '5978', description: 'Typewriter Stores–Rentals, Sales, Service' },
    { code: '5992', description: 'Florists' },
    { code: '5993', description: 'Cigar Stores and Stands' },
    { code: '5994', description: 'News Dealers and Newsstands' },
    { code: '5995', description: 'Pet Shops, Pet Food and Supplies' },
    { code: '5996', description: 'Swimming Pools–Sales and Supplies' },
    { code: '5997', description: 'Electric Razor Stores–Sales and Service' },
    { code: '5998', description: 'Tent and Awning Shops' },
    { code: '5999', description: 'Miscellaneous and Specialty Retail Stores' },
    { code: '6513', description: 'Real Estate Agents and Managers–Rentals' },
    
    { code: '7230', description: 'Barber and Beauty Shops' },
    { code: '7251', description: 'Hat Cleaning Shops, Shoe Repair Shops, Shoe Shine Parlors' },
    { code: '7273', description: 'Funeral Service and Crematories' },
    { code: '7277', description: 'Dating Services' },
    { code: '7278', description: 'Tax Preparation Service' },
    { code: '7296', description: 'Debt, Marriage, Personal–Counseling Services' },
    { code: '7297', description: 'Buying/Shopping Clubs, Services' },
    { code: '7298', description: 'Health and Beauty Spas' },
    { code: '7299', description: 'Other Services–Not Elsewhere Classified' },
    { code: '7321', description: 'Consumer Credit Reporting Agencies' },
    { code: '7361', description: 'Employment Agencies and Temporary Help Services' },
    { code: '7379', description: 'Computer Maintenance, Repair And Services–Not Elsewhere Classified' },
    { code: '7392', description: 'Consulting, Management and Public Relations Services' },
    { code: '7622', description: 'Electronic Repair Shops' },
    { code: '7623', description: 'Air Conditioning and Refrigeration Repair Shops' },
    { code: '7629', description: 'Appliance Repair Shops, Electrical and Small' },
    { code: '7631', description: 'Clock, Jewelry and Watch Repair Shops' },
    { code: '7641', description: 'Furniture–Reupholstery, Repair and Refinishing' },
    { code: '7993', description: 'Video Amusement Game Supplies' },
    { code: '8351', description: 'Organizations, Political' },
    { code: '9751', description: 'UK Supermarkets, Electronic Hot File' },
    
    // Educational
    { code: '8211', description: 'Elementary and Secondary Schools' },
    { code: '8220', description: 'Colleges, Universities' },
    { code: '8241', description: 'Correspondence Schools' },
    { code: '8244', description: 'Business and Secretarial Schools' },
    { code: '8249', description: 'Vocational and Trade Schools' },
    { code: '8299', description: 'Schools and Educational Services' },
    
    // Government Services
    { code: '9211', description: 'Court Costs, Including Alimony and Child Support' },
    { code: '9222', description: 'Fines, Government Administrative Entities' },
    { code: '9223', description: 'Bail and Bond Payments' },
    { code: '9311', description: 'Tax Payments, Government Agencies' },
    { code: '9399', description: 'Government Services' },
    { code: '9402', description: 'Postal Services' },
    
    // Financial Services
    { code: '6010', description: 'Financial Institutions - Manual Cash Disbursements' },
    { code: '6011', description: 'Financial Institutions - Automated Cash Disbursements' },
    { code: '6012', description: 'Financial Institutions - Merchandise and Services' },
    { code: '6051', description: 'Non-Financial Institutions - Foreign Currency, Money Orders' },
    { code: '6211', description: 'Securities Brokers/Dealers' },
    { code: '6300', description: 'Insurance Sales, Underwriting, and Premiums' },
    
    // Charitable & Social Service
    { code: '8398', description: 'Charitable and Social Service Organizations' },
    { code: '8641', description: 'Civic, Social, and Fraternal Associations' },
    { code: '8651', description: 'Political Organizations' },
    { code: '8661', description: 'Religious Organizations' },
    
    // Medical & Healthcare
    { code: '4119', description: 'Ambulance Services' },
    { code: '5122', description: 'Drugs, Drug Proprietaries, and Druggist Sundries' },
    { code: '5975', description: 'Hearing Aids Sales, Service, and Supplies' },
    { code: '5976', description: 'Orthopedic Goods - Prosthetic Devices' },
    { code: '7339', description: 'Stenographic and Secretarial Support Services' },
    { code: '8011', description: 'Doctors and Physicians' },
    { code: '8021', description: 'Dentists and Orthodontists' },
    { code: '8031', description: 'Osteopaths' },
    { code: '8041', description: 'Chiropractors' },
    { code: '8042', description: 'Optometrists and Ophthalmologists' },
    { code: '8043', description: 'Opticians, Optical Goods, and Eyeglasses' },
    { code: '8049', description: 'Podiatrists and Chiropodists' },
    { code: '8050', description: 'Nursing and Personal Care Facilities' },
    { code: '8062', description: 'Hospitals' },
    { code: '8071', description: 'Medical and Dental Laboratories' },
    { code: '8099', description: 'Medical Services and Health Practitioners' }
  ];
  
  // Create a Map to track unique codes
  const uniqueCodesMap = new Map();
  
  // Filter out duplicates by keeping only the first occurrence of each code
  originalCodes.forEach(mcc => {
    if (!uniqueCodesMap.has(mcc.code)) {
      uniqueCodesMap.set(mcc.code, mcc);
    }
  });
  
  // Convert the Map values back to an array
  const uniqueCodes = Array.from(uniqueCodesMap.values());
  
  // Sort by code in ascending order
  return uniqueCodes.sort((a, b) => a.code.localeCompare(b.code));
})();

================
File: utils/defaults/paymentMethods.ts
================
import { PaymentMethod } from '@/types';

// Default payment methods with proper UUID format
export const defaultPaymentMethods: PaymentMethod[] = [
  // Cash options for different currencies
  {
    id: 'c81d6e04-79bd-44da-8293-d951c35a8501',
    name: 'Cash (USD)',
    type: 'cash',
    currency: 'USD',
    rewardRules: [],
    active: true,
    icon: 'banknote',
    color: '#22c55e',
  },
  {
    id: 'c81d6e04-79bd-44da-8293-d951c35a8502',
    name: 'Cash (SGD)',
    type: 'cash',
    currency: 'SGD',
    rewardRules: [],
    active: true,
    icon: 'banknote',
    color: '#22c55e',
  },
  {
    id: 'c81d6e04-79bd-44da-8293-d951c35a8503',
    name: 'Cash (TWD)',
    type: 'cash',
    currency: 'TWD',
    rewardRules: [],
    active: true,
    icon: 'banknote',
    color: '#22c55e',
  },
  {
    id: 'c81d6e04-79bd-44da-8293-d951c35a8504',
    name: 'Cash (CAD)',
    type: 'cash',
    currency: 'CAD',
    rewardRules: [],
    active: true,
    icon: 'banknote',
    color: '#22c55e',
  },
  {
    id: 'c81d6e04-79bd-44da-8293-d951c35a8505',
    name: 'Cash (VND)',
    type: 'cash',
    currency: 'VND',
    rewardRules: [],
    active: true,
    icon: 'banknote',
    color: '#22c55e',
  },
  {
    id: 'c81d6e04-79bd-44da-8293-d951c35a8506',
    name: 'Cash (THB)',
    type: 'cash',
    currency: 'THB',
    rewardRules: [],
    active: true,
    icon: 'banknote',
    color: '#22c55e',
  },
  // Credit cards
  {
    id: 'b5ea3301-a599-47b9-9943-13410d48cdd6',
    name: 'Blue Cash Preferred',
    type: 'credit_card',
    currency: 'USD',
    issuer: 'American Express',
    lastFourDigits: '1234',
    statementStartDay: 15,
    isMonthlyStatement: true,
    active: true,
    icon: 'credit-card',
    color: '#3b82f6',
    rewardRules: [
      {
        id: 'b5ea3301-a599-47b9-9943-13410d48cdd7',
        name: 'Grocery Bonus',
        description: '6% back at U.S. supermarkets',
        type: 'mcc',
        condition: '5411',
        pointsMultiplier: 6,
        maxSpend: 6000,
      },
      {
        id: 'b5ea3301-a599-47b9-9943-13410d48cdd8',
        name: 'Streaming Bonus',
        description: '6% back on select U.S. streaming',
        type: 'merchant',
        condition: ['Netflix', 'Spotify', 'Disney', 'Hulu', 'HBO'],
        pointsMultiplier: 6,
      },
      {
        id: 'b5ea3301-a599-47b9-9943-13410d48cdd9',
        name: 'Gas Bonus',
        description: '3% back at U.S. gas stations',
        type: 'mcc',
        condition: '5541',
        pointsMultiplier: 3,
      },
    ],
  },
  {
    id: '2f6b1a24-7e3c-40b4-8582-97357f384612',
    name: 'Chase Sapphire Reserve',
    type: 'credit_card',
    currency: 'USD',
    issuer: 'Chase',
    lastFourDigits: '5678',
    statementStartDay: 1,
    isMonthlyStatement: false,
    active: true,
    icon: 'credit-card',
    color: '#6366f1',
    rewardRules: [
      {
        id: '2f6b1a24-7e3c-40b4-8582-97357f384613',
        name: 'Travel Bonus',
        description: '3x points on travel',
        type: 'mcc',
        condition: '3000',
        pointsMultiplier: 3,
      },
      {
        id: '2f6b1a24-7e3c-40b4-8582-97357f384614',
        name: 'Dining Bonus',
        description: '3x points on dining',
        type: 'mcc',
        condition: '5812',
        pointsMultiplier: 3,
      },
    ],
  },
  {
    id: '9c5a3e87-1de4-4d1a-9ea3-ce8d932fe728',
    name: 'Preferred Visa Platinum',
    type: 'credit_card',
    currency: 'SGD',
    issuer: 'UOB',
    lastFourDigits: '9012',
    statementStartDay: 1,
    isMonthlyStatement: false,
    active: true,
    icon: 'credit-card',
    color: '#1e3a8a',
    rewardRules: [], // Special handling in rewardPoints.ts
  },
  {
    id: '7e8c1909-7cca-48e0-84c0-118a9d8fedf1',
    name: 'Visa Signature',
    type: 'credit_card',
    currency: 'SGD',
    issuer: 'UOB',
    lastFourDigits: '3456',
    statementStartDay: 1,
    isMonthlyStatement: true,
    active: true,
    icon: 'credit-card',
    color: '#7e22ce',
    rewardRules: [], // Special handling in rewardPoints.ts
    conversionRate: {
      USD: 1.35,
      EUR: 1.47,
      GBP: 1.73,
      SGD: 1,
      JPY: 0.0091,
      AUD: 0.89,
      CAD: 0.99,
      CNY: 0.19,
      INR: 0.016,
      TWD: 0.042,
      VND: 0.000054,
      IDR: 0.000086,
      THB: 0.038,
      MYR: 0.31
    }
  },
  {
    id: 'd4b9c8a7-3f6e-42d1-b590-584f5e682ab3',
    name: 'Rewards Visa Signature',
    type: 'credit_card',
    currency: 'SGD',
    issuer: 'Citibank',
    lastFourDigits: '7890',
    statementStartDay: 1,
    isMonthlyStatement: true,
    active: true,
    icon: 'credit-card',
    color: '#0891b2',
    rewardRules: [], // Special handling in rewardPoints.ts
    conversionRate: {
      USD: 1.35,
      EUR: 1.47,
      GBP: 1.73,
      SGD: 1,
      JPY: 0.0091,
      AUD: 0.89,
      CAD: 0.99,
      CNY: 0.19,
      INR: 0.016,
      TWD: 0.042,
      VND: 0.000054,
      IDR: 0.000086,
      THB: 0.038,
      MYR: 0.31
    }
  },
  {
    id: 'e5f7a9c2-1b3d-4e8f-a6c9-7d8e2f1b3a4c',
    name: 'Cobalt',
    type: 'credit_card',
    currency: 'CAD',
    issuer: 'American Express',
    lastFourDigits: '1234',
    statementStartDay: 1,
    isMonthlyStatement: true,
    active: true,
    icon: 'credit-card',
    color: '#6b21a8',
    rewardRules: [], // Special handling in rewards logic
  },
  {
    id: 'f6e8d7c5-a4b3-2c1d-e9f8-7d6e5f4a3b2c',
    name: 'Platinum Canada',
    type: 'credit_card',
    currency: 'CAD',
    issuer: 'American Express',
    lastFourDigits: '2345',
    statementStartDay: 1,
    isMonthlyStatement: true,
    active: true,
    icon: 'credit-card',
    color: '#7c3aed',
    rewardRules: [], // Special handling in rewards logic
  },
  {
    id: 'a1b2c3d4-e5f6-a7b8-c9d0-e1f2a3b4c5d6',
    name: 'Platinum Credit',
    type: 'credit_card',
    currency: 'USD',
    issuer: 'American Express',
    lastFourDigits: '3456',
    statementStartDay: 1,
    isMonthlyStatement: true,
    active: true,
    icon: 'credit-card',
    color: '#8b5cf6',
    rewardRules: [], // Special handling in rewards logic
  },
  {
    id: 'c5d6e7f8-a9b0-c1d2-e3f4-a5b6c7d8e9f0',
    name: 'Platinum Singapore',
    type: 'credit_card',
    currency: 'SGD',
    issuer: 'American Express',
    lastFourDigits: '4567',
    statementStartDay: 1,
    isMonthlyStatement: true,
    active: true,
    icon: 'credit-card',
    color: '#a78bfa',
    rewardRules: [], // Special handling in rewards logic
  },
  {
    id: 'd7e8f9a0-b1c2-d3e4-f5a6-b7c8d9e0f1a2',
    name: 'Aeroplan Visa Infinite',
    type: 'credit_card',
    currency: 'CAD',
    issuer: 'TD',
    lastFourDigits: '5678',
    statementStartDay: 1,
    isMonthlyStatement: true,
    active: true,
    icon: 'credit-card',
    color: '#c4b5fd',
    rewardRules: [], // Special handling in rewards logic
  },
  {
    id: 'b3c4d5e6-f7a8-b9c0-d1e2-f3a4b5c6d7e8',
    name: 'Lady\'s Solitaire',
    type: 'credit_card',
    currency: 'SGD',
    issuer: 'UOB',
    lastFourDigits: '6789',
    statementStartDay: 1,
    isMonthlyStatement: true,
    active: true,
    icon: 'credit-card',
    color: '#ddd6fe',
    rewardRules: [], // Special handling in rewards logic
  },
  // Add OCBC Rewards World Mastercard
  {
    id: 'e9f0a1b2-c3d4-e5f6-a7b8-c9d0e1f2a3b4',
    name: 'Rewards World Mastercard',
    type: 'credit_card',
    currency: 'SGD',
    issuer: 'OCBC',
    lastFourDigits: '8901',
    statementStartDay: 1,
    isMonthlyStatement: true,
    active: true,
    icon: 'credit-card',
    color: '#eb6e1f', // OCBC orange color
    rewardRules: [], // Special handling in RewardCalculationService
  },
];

// Helper function to find cash payment method for a specific currency
export const findCashPaymentMethodForCurrency = (currency: string): PaymentMethod | undefined => {
  return defaultPaymentMethods.find(method => 
    method.type === 'cash' && method.currency === currency
  );
};

================
File: utils/expense/submitExpense.ts
================
import { FormValues } from '@/hooks/useExpenseForm';
import { Transaction, Merchant, PaymentMethod, Currency, MerchantCategoryCode } from '@/types';
import { addOrUpdateMerchant } from '@/utils/storageUtils';
import { getCategoryFromMCC, getCategoryFromMerchantName } from '@/utils/categoryMapping';
import { format } from 'date-fns';

export const prepareTransactionData = async (
  values: FormValues,
  paymentMethods: PaymentMethod[],
  selectedMCC: MerchantCategoryCode | undefined,
  estimatedPoints: number | {
    totalPoints: number;
    basePoints?: number;
    bonusPoints?: number;
    remainingMonthlyBonusPoints?: number;
    messageText?: string;
  }
): Promise<Omit<Transaction, 'id'>> => {
  // Find the selected payment method
  const paymentMethod = paymentMethods.find(pm => pm.id === values.paymentMethodId);
  if (!paymentMethod) {
    throw new Error('Selected payment method not found');
  }
  
  // Prepare merchant data
  const merchant: Merchant = {
    id: '',
    name: values.merchantName.trim(),
    address: values.merchantAddress?.trim(),
    isOnline: values.isOnline,
    mcc: selectedMCC,
  };
  
  // Save/update merchant in storage
  const savedMerchant = await addOrUpdateMerchant(merchant);
  
  // Determine category
  let category = 'Uncategorized';
  if (selectedMCC?.code) {
    category = getCategoryFromMCC(selectedMCC.code);
  } else {
    category = getCategoryFromMerchantName(values.merchantName) || 'Uncategorized';
  }
  
  // Prepare transaction data
  const transaction: Omit<Transaction, 'id'> = {
    date: format(values.date, 'yyyy-MM-dd'),
    merchant: savedMerchant,
    amount: Number(values.amount),
    currency: values.currency as Currency,
    paymentMethod: paymentMethod,
    paymentAmount: values.paymentAmount && values.paymentAmount !== values.amount
      ? Number(values.paymentAmount) 
      : Number(values.amount),
    paymentCurrency: paymentMethod.currency,
    rewardPoints: typeof estimatedPoints === 'object' 
      ? estimatedPoints.totalPoints 
      : (typeof estimatedPoints === 'number' ? estimatedPoints : 0),
    notes: values.notes,
    isContactless: !values.isOnline ? values.isContactless : false,
    category,
    // Add reimbursement amount to the transaction
    reimbursementAmount: values.reimbursementAmount ? Number(values.reimbursementAmount) : 0,
  };
  
  return transaction;
};

================
File: utils/rewards/rewardCalculationAdapter.ts
================
// src/utils/rewards/rewardCalculationAdapter.ts
import { Transaction, PaymentMethod } from '@/types';
import { rewardCalculationService } from '@/services/RewardCalculationService';
import { bonusPointsTrackingService } from '@/services/BonusPointsTrackingService';

/**
 * Adapter for the calculatePoints function in storage/transactions/calculations.ts
 * Replaces the existing switch statement with a call to the centralized service
 */
export async function calculatePoints(transaction: Transaction): Promise<{
  basePoints: number;
  bonusPoints: number;
  totalPoints: number;
}> {
  // Skip calculation for cash payments
  if (transaction.paymentMethod.type === 'cash') {
    return {
      basePoints: 0,
      bonusPoints: 0,
      totalPoints: 0
    };
  }
  
  // Get transaction date components
  const txDate = new Date(transaction.date);
  const year = txDate.getFullYear();
  const month = txDate.getMonth();
  
  // Get used bonus points for this month for the payment method
  const usedBonusPoints = await bonusPointsTrackingService.getUsedBonusPoints(
    transaction.paymentMethod.id,
    year,
    month
  );
  
  // Use the centralized service to calculate points
  return rewardCalculationService.calculatePoints(transaction, usedBonusPoints);
}

/**
 * Synchronous version for immediate calculations
 * Uses a default of 0 for usedBonusPoints when tracking service can't be used synchronously
 */
export function calculatePointsSync(transaction: Transaction): {
  basePoints: number;
  bonusPoints: number;
  totalPoints: number;
} {
  // Skip calculation for cash payments
  if (transaction.paymentMethod.type === 'cash') {
    return {
      basePoints: 0,
      bonusPoints: 0,
      totalPoints: 0
    };
  }
  
  // Use 0 as default for usedBonusPoints in synchronous context
  // This is a simplified approach for when we need immediate results
  const usedBonusPoints = 0;
  
  // Use the centralized service to calculate points
  return rewardCalculationService.calculatePoints(transaction, usedBonusPoints);
}

/**
 * Adapter for simulateRewardPoints in utils/rewards/rewardPoints.ts
 * Replaces all the separate simulation functions with a call to the centralized service
 */
export async function simulateRewardPoints(
  amount: number,
  currency: string,
  paymentMethod: PaymentMethod,
  mcc?: string,
  merchantName?: string,
  isOnline?: boolean,
  isContactless?: boolean,
  currentDate: Date = new Date()
): Promise<{
  totalPoints: number;
  basePoints?: number;
  bonusPoints?: number;
  remainingMonthlyBonusPoints?: number;
  messageText?: string;
  pointsCurrency?: string;
}> {
  if (paymentMethod.type === 'cash') {
    return { totalPoints: 0 };
  }
  
  // Extract year and month from date
  const year = currentDate.getFullYear();
  const month = currentDate.getMonth();
  
  // Get used bonus points for the current month from the tracking service
  const usedBonusPoints = await bonusPointsTrackingService.getUsedBonusPoints(
    paymentMethod.id,
    year,
    month
  );
  
  try {
    // Use the centralized service to simulate points
    const result = rewardCalculationService.simulatePoints(
      amount,
      currency,
      paymentMethod,
      mcc,
      merchantName,
      isOnline,
      isContactless,
      usedBonusPoints
    );
    
    // Format a message text based on calculation results
    let messageText;
    if (result.bonusPoints === 0 && result.remainingMonthlyBonusPoints === 0) {
      messageText = "Monthly bonus points cap reached";
    } else if (result.bonusPoints === 0 && result.remainingMonthlyBonusPoints > 0) {
      messageText = "Not eligible for bonus points";
    } else if (result.remainingMonthlyBonusPoints !== undefined) {
      messageText = `${result.remainingMonthlyBonusPoints.toLocaleString()} bonus points remaining this month`;
    }
    
    return {
      ...result,
      messageText
    };
  } catch (error) {
    console.error('Error simulating reward points:', error);
    // Provide a fallback response in case of errors - using Math.round for proper rounding
    return { 
      totalPoints: Math.round(amount), 
      basePoints: Math.round(amount),
      bonusPoints: 0,
      messageText: 'Error calculating points' 
    };
  }
}

/**
 * Adapter for calculateTransactionPoints in utils/rewards/rewardPoints.ts
 * Replaces all the separate transaction calculation functions
 */
export async function calculateTransactionPoints(
  transaction: Transaction,
  allTransactions: Transaction[]
): Promise<number> {
  // Extract date components
  const txDate = new Date(transaction.date);
  const year = txDate.getFullYear();
  const month = txDate.getMonth();
  
  // Get used bonus points from previous transactions in the same month
  // using the BonusPointsTrackingService
  const relevantTransactions = allTransactions.filter(tx => tx.id !== transaction.id); // Exclude current transaction
  const usedBonusPoints = bonusPointsTrackingService.calculateUsedBonusPointsFromTransactions(
    relevantTransactions,
    transaction.paymentMethod.id,
    year,
    month
  );
  
  // Use the centralized service to calculate points
  const calculatedPoints = rewardCalculationService.calculatePoints(
    transaction,
    usedBonusPoints
  );
  
  return calculatedPoints.totalPoints;
}

/**
 * Adapter for calculateTotalRewardPoints in utils/rewards/rewardPoints.ts
 */
export function calculateTotalRewardPoints(transactions: Transaction[]): number {
  return transactions.reduce((total, transaction) => {
    // Ensure reward points is a number
    const points = typeof transaction.rewardPoints === 'number' 
      ? transaction.rewardPoints 
      : 0;
    return total + points;
  }, 0);
}

================
File: utils/storage/transactions/add.ts
================
// src/utils/storage/transactions/add.ts
import { v4 as uuidv4 } from 'uuid';
import { Transaction } from '@/types';
import { supabase } from '@/integrations/supabase/client';
import { saveTransactionToLocalStorage } from './local-storage';
import { getTransactions } from './get';
import { addOrUpdateMerchant } from '../merchants';
import { incrementMerchantOccurrence } from '../merchantTracking';
import { rewardCalculationService } from '@/services/RewardCalculationService';
import { bonusPointsTrackingService } from '@/services/BonusPointsTrackingService';

export const addTransaction = async (
  transaction: Omit<Transaction, 'id'>, 
  forceLocalStorage: boolean = false
): Promise<Transaction | null> => {
  try {
    // Validate transaction data
    if (!transaction.merchant || !transaction.paymentMethod) {
      console.error('Invalid transaction data: missing merchant or payment method');
      return null;
    }
    
    // Get used bonus points for this month for the payment method
    const paymentMethod = transaction.paymentMethod;
    const usedBonusPoints = await bonusPointsTrackingService.getUsedBonusPoints(
      paymentMethod.id
    );
    
    // Calculate reward points using our centralized service
    const pointsBreakdown = rewardCalculationService.calculatePoints(
      transaction as Transaction, 
      usedBonusPoints
    );
    
    console.log('Points breakdown calculated:', JSON.stringify(pointsBreakdown, null, 2));
    
    // Prepare complete transaction data with points
    const completeTransaction: Transaction = {
      id: uuidv4(),
      ...transaction,
      rewardPoints: pointsBreakdown.totalPoints
    };
    
    console.log('Using local storage flag:', forceLocalStorage);
    
    if (!forceLocalStorage) {
      try {
        // First save or update the merchant
        if (transaction.merchant) {
          await addOrUpdateMerchant(transaction.merchant);
        }
        
        // Then save the transaction to Supabase
        const { data, error } = await supabase
          .from('transactions')
          .insert({
            id: completeTransaction.id,
            amount: completeTransaction.amount,
            currency: completeTransaction.currency,
            category: completeTransaction.category || '',
            date: completeTransaction.date,
            merchant_id: completeTransaction.merchant?.id,
            payment_method_id: completeTransaction.paymentMethod?.id,
            is_contactless: completeTransaction.isContactless || false,
            payment_amount: completeTransaction.paymentAmount,
            payment_currency: completeTransaction.paymentCurrency,
            notes: completeTransaction.notes || '',
            reward_points: completeTransaction.rewardPoints,
            base_points: pointsBreakdown.basePoints,
            bonus_points: pointsBreakdown.bonusPoints
          })
          .select()
          .single();
        
        if (error) {
          console.error('Error saving transaction to Supabase:', error);
          throw error;
        }
        
        console.log('Transaction saved to Supabase with ID:', data.id);
        
        // Record bonus points movement if any
        if (pointsBreakdown.bonusPoints > 0) {
          await bonusPointsTrackingService.recordBonusPointsMovement(
            completeTransaction.id,
            completeTransaction.paymentMethod.id,
            pointsBreakdown.bonusPoints
          );
        }
        
        // Update merchant category mapping for improved suggestions
        if (transaction.merchant && transaction.merchant.mcc) {
          await incrementMerchantOccurrence(transaction.merchant.name, transaction.merchant.mcc);
          console.log('Updated merchant category mapping for', transaction.merchant.name);
        }
        
        return completeTransaction;
      } catch (err) {
        console.error('Failed to save to Supabase, falling back to localStorage:', err);
        // Fall back to localStorage if Supabase fails
      }
    }
    
    // Save to localStorage as fallback or if forced
    const transactions = await getTransactions(true); // Force local storage
    const localId = (transactions.length + 1).toString();
    
    const localTransaction: Transaction = {
      ...completeTransaction,
      id: localId
    };
    
    const saved = await saveTransactionToLocalStorage(localTransaction);
    if (!saved) {
      console.error('Failed to save transaction to localStorage');
      return null;
    }
    
    console.log('Transaction saved to local storage with data:', JSON.stringify(localTransaction, null, 2));
    return localTransaction;
  } catch (error) {
    console.error('Error in addTransaction:', error);
    return null;
  }
};

================
File: utils/storage/transactions/bonus-points.ts
================
import { supabase } from '@/integrations/supabase/client';

interface BonusPointsMovement {
  transactionId: string;
  paymentMethodId: string;
  bonusPoints: number;
}

export const addBonusPointsMovement = async (movement: BonusPointsMovement) => {
  try {
    console.log('Recording bonus points movement:', JSON.stringify(movement, null, 2));
    
    const bonusData = {
      transaction_id: movement.transactionId,
      payment_method_id: movement.paymentMethodId,
      bonus_points: movement.bonusPoints
    };
    
    // Only try to save to Supabase if we have a valid transaction ID format
    // (local storage transactions might use a different ID format than Supabase UUIDs)
    const isValidUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(movement.transactionId);
    
    if (!isValidUUID) {
      console.log('Skipping bonus points recording for local storage transaction (non-UUID format)');
      return null;
    }
    
    console.log('Sending bonus points data to Supabase:', JSON.stringify(bonusData, null, 2));
    
    const { data, error } = await supabase
      .from('bonus_points_movements')
      .insert(bonusData)
      .select();
      
    if (error) {
      console.error('Error recording bonus points movement:', error);
      console.error('Error details:', error.message, error.details, error.hint);
      // Don't throw here, we'll still consider the transaction a success
      // even if bonus points recording fails
      return null;
    }
    
    console.log('Bonus points movement recorded successfully:', data);
    
    // Trigger background task to update monthly totals
    // Using setTimeout as a background task since we're in browser context
    setTimeout(() => {
      updateMonthlyBonusPointsTotals(movement.paymentMethodId)
        .catch(err => console.error('Error in background task:', err));
    }, 0);
    
    return data ? data[0] : null;
  } catch (error) {
    console.error('Exception in addBonusPointsMovement:', error);
    // Don't throw here, we'll still consider the transaction a success
    // even if bonus points recording fails
    return null;
  }
};

const updateMonthlyBonusPointsTotals = async (paymentMethodId: string) => {
  try {
    console.log('Updating monthly bonus points totals for payment method:', paymentMethodId);
    
    const currentDate = new Date();
    const firstDayOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
    
    console.log('Fetching bonus points movements since:', firstDayOfMonth.toISOString());
    
    const { data: movements, error } = await supabase
      .from('bonus_points_movements')
      .select('bonus_points')
      .eq('payment_method_id', paymentMethodId)
      .gte('created_at', firstDayOfMonth.toISOString());
      
    if (error) {
      console.error('Error fetching bonus points movements:', error);
      console.error('Error details:', error.message, error.details, error.hint);
      return;
    }
    
    console.log('Fetched bonus points movements:', movements);
    
    const totalBonusPoints = movements.reduce((sum, movement) => sum + movement.bonus_points, 0);
    const remainingPoints = Math.max(0, 4000 - totalBonusPoints);
    
    console.log('Total bonus points used this month:', totalBonusPoints);
    console.log('Remaining bonus points available:', remainingPoints);
    
    // We don't use the toast hook here as it's a non-component context
    // Information about remaining points will be logged for debugging
  } catch (error) {
    console.error('Error in background task:', error);
  }
};

================
File: utils/storage/transactions/calculations.ts
================
// src/utils/storage/transactions/calculations.ts
import { Transaction } from '@/types';
import { rewardCalculationService } from '@/services/RewardCalculationService';

interface PointsBreakdown {
  basePoints: number;
  bonusPoints: number;
  totalPoints: number;
}

export const calculatePoints = (transaction: Omit<Transaction, 'id'>): PointsBreakdown => {
  if (transaction.paymentMethod.type === 'cash') {
    return {
      basePoints: 0,
      bonusPoints: 0,
      totalPoints: 0
    };
  }
  
  // This function is now a thin wrapper around the RewardCalculationService
  // Note: In a real implementation, we would fetch the used bonus points for the month
  // For now, we'll assume 0 used points
  const usedBonusPoints = 0; // Replace with actual bonus points tracking
  
  // Use the centralized service to calculate points
  return rewardCalculationService.calculatePoints(transaction as Transaction, usedBonusPoints);
};

================
File: utils/storage/transactions/delete.ts
================
import { supabase } from '@/integrations/supabase/client';
import { addBonusPointsMovement } from './bonus-points';
import { getTransactionsFromLocalStorage, saveTransactionsToLocalStorage } from './local-storage';

export const deleteTransaction = async (id: string): Promise<boolean> => {
  try {
    // First, check if we need to handle local storage
    const localStorageTransactions = await getTransactionsFromLocalStorage();
    const isInLocalStorage = localStorageTransactions.some(t => t.id === id);
    
    // Check if transaction exists in Supabase
    const { data: transaction, error: fetchError } = await supabase
      .from('transactions')
      .select(`
        *,
        merchant:merchant_id(*)
      `)
      .eq('id', id)
      .single();
      
    if (fetchError) {
      console.log('Transaction not found in Supabase, checking local storage');
      
      // If it's in local storage, handle locally
      if (isInLocalStorage) {
        console.log('Deleting transaction from local storage');
        const updatedTransactions = localStorageTransactions.filter(t => t.id !== id);
        await saveTransactionsToLocalStorage(updatedTransactions);
        return true;
      }
      
      console.error('Transaction not found in Supabase or local storage');
      return false;
    }
    
    // If we reached here, transaction exists in Supabase
    // Soft delete the transaction
    const { error: updateError } = await supabase
      .from('transactions')
      .update({
        is_deleted: true,
        deleted_at: new Date().toISOString()
      })
      .eq('id', id);
      
    if (updateError) {
      console.error('Error soft deleting transaction:', updateError);
      
      // If it's in local storage as fallback, handle locally
      if (isInLocalStorage) {
        console.log('Falling back to local storage deletion');
        const updatedTransactions = localStorageTransactions.filter(t => t.id !== id);
        await saveTransactionsToLocalStorage(updatedTransactions);
        return true;
      }
      
      return false;
    }
    
    // Record negative bonus points movement if needed
    if (transaction.reward_points > transaction.base_points) {
      const bonusPoints = transaction.reward_points - transaction.base_points;
      await addBonusPointsMovement({
        transactionId: transaction.id,
        paymentMethodId: transaction.payment_method_id,
        bonusPoints: -bonusPoints // Negative to offset the original bonus points
      });
    }
    
    // Update merchant occurrence count
    if (transaction.merchant) {
      try {
        const { decrementMerchantOccurrence } = await import('../merchantTracking');
        await decrementMerchantOccurrence(transaction.merchant.name);
      } catch (error) {
        console.error('Error updating merchant mapping after delete:', error);
      }
    }
    
    // Also remove from local storage if it exists there
    if (isInLocalStorage) {
      const updatedTransactions = localStorageTransactions.filter(t => t.id !== id);
      await saveTransactionsToLocalStorage(updatedTransactions);
    }
    
    return true;
  } catch (error) {
    console.error('Error in deleteTransaction:', error);
    return false;
  }
};

================
File: utils/storage/transactions/edit.ts
================
import { Transaction } from '@/types';
import { supabase } from '@/integrations/supabase/client';
import { addOrUpdateMerchant } from '../merchants';
import { getCategoryFromMCC } from '../../categoryMapping';
import { getTransactionsFromLocalStorage, saveTransactionsToLocalStorage } from './local-storage';

export const editTransaction = async (id: string, updatedTransaction: Omit<Transaction, 'id'>): Promise<Transaction | null> => {
  const existingTransactions = getTransactionsFromLocalStorage();
  const transaction = existingTransactions.find(t => t.id === id);
  
  if (transaction) {
    try {
      const updatedTransactions = existingTransactions.map(t => {
        if (t.id === id) {
          return {
            id,
            ...updatedTransaction,
          };
        }
        return t;
      });
      
      saveTransactionsToLocalStorage(updatedTransactions);
      
      const updated = updatedTransactions.find(t => t.id === id);
      return updated || null;
    } catch (error) {
      console.error('Error updating transaction in local storage:', error);
      return null;
    }
  }
  
  try {
    const savedMerchant = await addOrUpdateMerchant(updatedTransaction.merchant);
    
    // Log the reimbursement amount to debug
    console.log('Updating transaction with reimbursement amount:', updatedTransaction.reimbursementAmount);
    
    const { data, error } = await supabase
      .from('transactions')
      .update({
        date: updatedTransaction.date,
        merchant_id: savedMerchant.id,
        amount: updatedTransaction.amount,
        currency: updatedTransaction.currency,
        payment_method_id: updatedTransaction.paymentMethod.id,
        payment_amount: updatedTransaction.paymentAmount,
        payment_currency: updatedTransaction.paymentCurrency,
        reward_points: updatedTransaction.rewardPoints,
        notes: updatedTransaction.notes,
        category: updatedTransaction.category || getCategoryFromMCC(updatedTransaction.merchant.mcc?.code),
        is_contactless: updatedTransaction.isContactless,
        reimbursement_amount: updatedTransaction.reimbursementAmount || 0, // Add this field to ensure it's saved
      })
      .eq('id', id)
      .select()
      .single();
      
    if (error) {
      console.error('Error updating transaction:', error);
      return null;
    }
    
    return {
      id: data.id,
      date: data.date,
      merchant: savedMerchant,
      amount: Number(data.amount),
      currency: data.currency as any,
      paymentMethod: updatedTransaction.paymentMethod,
      paymentAmount: Number(data.payment_amount),
      paymentCurrency: data.payment_currency as any,
      rewardPoints: data.reward_points,
      notes: data.notes,
      category: data.category,
      isContactless: data.is_contactless,
      reimbursementAmount: Number(data.reimbursement_amount) || 0, // Make sure to include this in the returned data
    };
  } catch (error) {
    console.error('Error in editTransaction:', error);
    return null;
  }
};

================
File: utils/storage/transactions/export.ts
================
import { Transaction } from '@/types';

export const exportTransactionsToCSV = (transactions: Transaction[]): string => {
  if (transactions.length === 0) {
    return '';
  }
  
  const headers = [
    'ID',
    'Date',
    'Merchant',
    'Category',
    'Amount',
    'Currency',
    'Payment Method',
    'Payment Amount',
    'Payment Currency',
    'Reward Points',
    'Notes',
    'Contactless',
  ].join(',');
  
  const rows = transactions.map(tx => [
    tx.id,
    tx.date,
    tx.merchant.name,
    tx.category || tx.merchant.mcc?.description || 'Uncategorized',
    tx.amount,
    tx.currency,
    tx.paymentMethod.name,
    tx.paymentAmount,
    tx.paymentCurrency,
    tx.rewardPoints,
    tx.notes ? `"${tx.notes.replace(/"/g, '""')}"` : '',
    tx.isContactless ? 'Yes' : 'No',
  ].join(','));
  
  return [headers, ...rows].join('\n');
};

================
File: utils/storage/transactions/get.ts
================
import { Transaction, Currency, PaymentMethod } from '@/types';
import { supabase } from '@/integrations/supabase/client';
import { getTransactionsFromLocalStorage } from './local-storage';
import { getPaymentMethods } from '../paymentMethods';

export const getTransactions = async (forceLocalStorage = false): Promise<Transaction[]> => {
  if (forceLocalStorage) {
    console.log('Forcing local storage for transactions');
    return getTransactionsFromLocalStorage();
  }
  
  try {
    const { data, error } = await supabase
      .from('transactions')
      .select(`
        *,
        merchant:merchant_id(*),
        payment_method:payment_method_id(*)
      `)
      .eq('is_deleted', false); // Filter out deleted transactions
      
    if (error) {
      console.error('Error fetching transactions from Supabase:', error);
      console.log('Falling back to local storage for transactions');
      return getTransactionsFromLocalStorage();
    }
    
    const paymentMethods = await getPaymentMethods();
    
    const transformedData = data.map(tx => {
      const merchant = tx.merchant as any;
      const paymentMethod = tx.payment_method as any;
      
      const matchedPaymentMethod = paymentMethods.find(pm => pm.id === paymentMethod.id) || {
        id: paymentMethod.id,
        name: paymentMethod.name,
        type: paymentMethod.type,
        currency: paymentMethod.currency as Currency,
        rewardRules: paymentMethod.reward_rules || [],
        active: paymentMethod.active,
        lastFourDigits: paymentMethod.last_four_digits,
        issuer: paymentMethod.issuer,
        statementStartDay: paymentMethod.statement_start_day,
        isMonthlyStatement: paymentMethod.is_monthly_statement,
        icon: paymentMethod.icon,
        color: paymentMethod.color,
      };
      
      let mcc = undefined;
      if (merchant.mcc) {
        try {
          if (typeof merchant.mcc === 'object') {
            mcc = merchant.mcc;
          }
        } catch (e) {
          console.error('Error parsing MCC:', e);
        }
      }
      
      let coordinates = undefined;
      if (merchant.coordinates) {
        try {
          if (typeof merchant.coordinates === 'object') {
            coordinates = merchant.coordinates as { latitude: number; longitude: number };
          }
        } catch (e) {
          console.error('Error parsing coordinates:', e);
        }
      }
      
      // Ensure currency is converted to Currency type correctly, including NTD
      const txCurrency = tx.currency as Currency;
      const paymentCurrency = tx.payment_currency as Currency;
      
      return {
        id: tx.id,
        date: tx.date,
        merchant: {
          id: merchant.id,
          name: merchant.name,
          address: merchant.address,
          mcc,
          coordinates,
          isOnline: merchant.is_online,
        },
        amount: Number(tx.amount),
        currency: txCurrency,
        paymentMethod: matchedPaymentMethod,
        paymentAmount: Number(tx.payment_amount),
        paymentCurrency: paymentCurrency,
        rewardPoints: tx.reward_points,
        notes: tx.notes,
        category: tx.category,
        isContactless: tx.is_contactless,
        reimbursementAmount: tx.reimbursement_amount ? Number(tx.reimbursement_amount) : 0, // Properly include reimbursement amount
      };
    });
    
    console.log('Transactions loaded:', transformedData.length);
    console.log('Currencies present:', [...new Set(transformedData.map(tx => tx.currency))]);
    
    return transformedData;
  } catch (error) {
    console.error('Exception in getTransactions:', error);
    console.log('Falling back to local storage due to exception');
    return getTransactionsFromLocalStorage();
  }
};

================
File: utils/storage/transactions/local-storage.ts
================
import { Transaction } from '@/types';

const STORAGE_KEY = 'lovable_expense_tracker_transactions';

export const getTransactionsFromLocalStorage = (): Transaction[] => {
  try {
    const storedTransactions = localStorage.getItem(STORAGE_KEY);
    if (!storedTransactions) {
      return [];
    }
    
    const parsedTransactions = JSON.parse(storedTransactions) as Transaction[];
    
    // Filter out deleted transactions using is_deleted property from backend
    // or a deleted flag that might be set when working locally
    return parsedTransactions.filter(tx => tx.is_deleted !== true);
  } catch (error) {
    console.error('Error retrieving transactions from localStorage:', error);
    return [];
  }
};

export const saveTransactionsToLocalStorage = (transactions: Transaction[]): void => {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(transactions));
  } catch (error) {
    console.error('Error saving transactions to localStorage:', error);
  }
};

// Add a function to save a single transaction to localStorage
export const saveTransactionToLocalStorage = async (transaction: Transaction): Promise<boolean> => {
  try {
    // Get existing transactions
    const existingTransactions = getTransactionsFromLocalStorage();
    
    // Add new transaction or replace existing one
    const updatedTransactions = existingTransactions.some(tx => tx.id === transaction.id)
      ? existingTransactions.map(tx => tx.id === transaction.id ? transaction : tx)
      : [...existingTransactions, transaction];
    
    // Save updated array
    saveTransactionsToLocalStorage(updatedTransactions);
    return true;
  } catch (error) {
    console.error('Error saving transaction to localStorage:', error);
    return false;
  }
};

================
File: utils/storage/transactions/save.ts
================
import { Transaction } from '@/types';
import { addTransaction } from './add';

export const saveTransactions = async (transactions: Transaction[]): Promise<void> => {
  // Process transactions in batches to avoid blocking the main thread
  const batchSize = 10;
  const totalBatches = Math.ceil(transactions.length / batchSize);
  
  console.log(`Saving ${transactions.length} transactions in ${totalBatches} batches`);
  
  for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
    const start = batchIndex * batchSize;
    const end = Math.min(start + batchSize, transactions.length);
    const batch = transactions.slice(start, end);
    
    console.log(`Processing batch ${batchIndex + 1}/${totalBatches}, size: ${batch.length}`);
    
    // Process batch
    await Promise.all(batch.map(transaction => 
      addTransaction({
        date: transaction.date,
        merchant: transaction.merchant,
        amount: transaction.amount,
        currency: transaction.currency,
        paymentMethod: transaction.paymentMethod,
        paymentAmount: transaction.paymentAmount,
        paymentCurrency: transaction.paymentCurrency,
        rewardPoints: transaction.rewardPoints,
        notes: transaction.notes,
        category: transaction.category,
        isContactless: transaction.isContactless,
      })
    ));
    
    // Small delay between batches to allow UI to breathe
    if (batchIndex < totalBatches - 1) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }
  
  console.log('All transactions saved successfully');
};

================
File: utils/storage/index.ts
================
// Centralized exports from storage modules
export * from './merchants';
export * from './paymentMethods';
export * from './transactions';

================
File: utils/storage/merchants.ts
================
import { Merchant, MerchantCategoryCode } from '@/types';
import { supabase } from '@/integrations/supabase/client';

// Get merchants from Supabase
export const getMerchants = async (): Promise<Merchant[]> => {
  const { data, error } = await supabase
    .from('merchants')
    .select('*');
    
  if (error) {
    console.error('Error fetching merchants:', error);
    return [];
  }
  
  // Transform data to match our Merchant type
  return data.map(merchant => {
    // Process coordinates to ensure correct type
    let coordinates = undefined;
    if (merchant.coordinates) {
      try {
        if (typeof merchant.coordinates === 'object') {
          coordinates = merchant.coordinates as { latitude: number; longitude: number };
        }
      } catch (e) {
        console.error('Error parsing coordinates:', e);
      }
    }
    
    // Process MCC code to ensure correct type
    let mcc = undefined;
    if (merchant.mcc) {
      try {
        if (typeof merchant.mcc === 'object') {
          mcc = merchant.mcc as MerchantCategoryCode;
        }
      } catch (e) {
        console.error('Error parsing MCC:', e);
      }
    }
    
    return {
      id: merchant.id,
      name: merchant.name,
      address: merchant.address || undefined,
      coordinates,
      mcc,
      isOnline: merchant.is_online,
    };
  });
};

// Get merchant by name (case insensitive) or return undefined
export const getMerchantByName = async (name: string): Promise<Merchant | undefined> => {
  console.log('Looking for merchant by name:', name);
  
  const { data, error } = await supabase
    .from('merchants')
    .select('*')
    .ilike('name', name)
    .maybeSingle();
    
  if (error) {
    console.error('Error fetching merchant by name:', error);
    return undefined;
  }
  
  if (!data) {
    console.log('No merchant found with name:', name);
    return undefined;
  }
  
  console.log('Merchant found:', data);
  
  // Process coordinates to ensure correct type
  let coordinates = undefined;
  if (data.coordinates) {
    try {
      if (typeof data.coordinates === 'object') {
        coordinates = data.coordinates as { latitude: number; longitude: number };
      }
    } catch (e) {
      console.error('Error parsing coordinates:', e);
    }
  }
  
  // Process MCC code to ensure correct type
  let mcc = undefined;
  if (data.mcc) {
    try {
      if (typeof data.mcc === 'object') {
        mcc = data.mcc as MerchantCategoryCode;
      }
    } catch (e) {
      console.error('Error parsing MCC:', e);
    }
  }
  
  // Transform data to match our Merchant type
  return {
    id: data.id,
    name: data.name,
    address: data.address || undefined,
    coordinates,
    mcc,
    isOnline: data.is_online,
  };
};

// Add a new merchant or update if already exists
export const addOrUpdateMerchant = async (merchant: Merchant): Promise<Merchant> => {
  console.log('Adding or updating merchant:', JSON.stringify(merchant, null, 2));
  
  // Check if merchant with same name exists
  const existingMerchant = await getMerchantByName(merchant.name);
  
  if (existingMerchant) {
    console.log('Merchant already exists, updating:', existingMerchant.id);
    
    // Update existing merchant
    const { data, error } = await supabase
      .from('merchants')
      .update({
        address: merchant.address,
        coordinates: merchant.coordinates,
        mcc: merchant.mcc,
        is_online: merchant.isOnline,
      })
      .eq('id', existingMerchant.id)
      .select()
      .single();
      
    if (error) {
      console.error('Error updating merchant:', error);
      console.error('Error details:', error.message, error.details, error.hint);
      throw error;
    }
    
    console.log('Merchant updated successfully:', data);
    
    // Process coordinates to ensure correct type
    let coordinates = undefined;
    if (data.coordinates) {
      try {
        if (typeof data.coordinates === 'object') {
          coordinates = data.coordinates as { latitude: number; longitude: number };
        }
      } catch (e) {
        console.error('Error parsing coordinates:', e);
      }
    }
    
    // Process MCC code to ensure correct type
    let mcc = undefined;
    if (data.mcc) {
      try {
        if (typeof data.mcc === 'object') {
          mcc = data.mcc as MerchantCategoryCode;
        }
      } catch (e) {
        console.error('Error parsing MCC:', e);
      }
    }
    
    return {
      id: data.id,
      name: data.name,
      address: data.address || undefined,
      coordinates,
      mcc,
      isOnline: data.is_online,
    };
  } else {
    console.log('Adding new merchant:', merchant.name);
    
    // Add new merchant
    const { data, error } = await supabase
      .from('merchants')
      .insert({
        name: merchant.name,
        address: merchant.address,
        coordinates: merchant.coordinates,
        mcc: merchant.mcc,
        is_online: merchant.isOnline,
      })
      .select()
      .single();
      
    if (error) {
      console.error('Error adding merchant:', error);
      console.error('Error details:', error.message, error.details, error.hint);
      throw error;
    }
    
    console.log('New merchant added successfully:', data);
    
    // Process coordinates to ensure correct type
    let coordinates = undefined;
    if (data.coordinates) {
      try {
        if (typeof data.coordinates === 'object') {
          coordinates = data.coordinates as { latitude: number; longitude: number };
        }
      } catch (e) {
        console.error('Error parsing coordinates:', e);
      }
    }
    
    // Process MCC code to ensure correct type
    let mcc = undefined;
    if (data.mcc) {
      try {
        if (typeof data.mcc === 'object') {
          mcc = data.mcc as MerchantCategoryCode;
        }
      } catch (e) {
        console.error('Error parsing MCC:', e);
      }
    }
    
    return {
      id: data.id,
      name: data.name,
      address: data.address || undefined,
      coordinates,
      mcc,
      isOnline: data.is_online,
    };
  }
};

================
File: utils/storage/merchantTracking.ts
================
import { MerchantCategoryCode } from '@/types';
import { supabase } from '@/integrations/supabase/client';

// Interface for merchant occurrence tracking
interface MerchantCategoryMapping {
  merchantName: string;
  occurrenceCount: number;
  mostCommonMCC?: MerchantCategoryCode;
  isDeleted: boolean;
}

// Get current merchant category mapping
export const getMerchantCategoryMappings = async (): Promise<MerchantCategoryMapping[]> => {
  try {
    const { data, error } = await supabase
      .from('merchant_category_mappings')
      .select('*')
      .eq('is_deleted', false);
      
    if (error) {
      console.error('Error fetching merchant category mappings:', error);
      return [];
    }
    
    return data.map(item => ({
      merchantName: item.merchant_name,
      occurrenceCount: item.occurrence_count,
      mostCommonMCC: item.most_common_mcc ? item.most_common_mcc as MerchantCategoryCode : undefined,
      isDeleted: item.is_deleted
    }));
  } catch (error) {
    console.error('Exception fetching merchant category mappings:', error);
    return [];
  }
};

// Get merchant mapping by name
export const getMerchantCategoryMappingByName = async (merchantName: string): Promise<MerchantCategoryMapping | null> => {
  try {
    const { data, error } = await supabase
      .from('merchant_category_mappings')
      .select('*')
      .ilike('merchant_name', merchantName)
      .maybeSingle();
    
    if (error || !data) {
      console.error('Error fetching merchant mapping by name:', error);
      return null;
    }
    
    return {
      merchantName: data.merchant_name,
      occurrenceCount: data.occurrence_count,
      mostCommonMCC: data.most_common_mcc ? data.most_common_mcc as MerchantCategoryCode : undefined,
      isDeleted: data.is_deleted
    };
  } catch (error) {
    console.error('Exception fetching merchant mapping by name:', error);
    return null;
  }
};

// Increment the merchant occurrence count and update most common MCC
export const incrementMerchantOccurrence = async (
  merchantName: string, 
  mcc: MerchantCategoryCode
): Promise<void> => {
  try {
    // Check if mapping exists
    const mapping = await getMerchantCategoryMappingByName(merchantName);
    
    if (mapping) {
      const updateData: any = {
        occurrence_count: mapping.occurrenceCount + 1,
        most_common_mcc: mcc,
        updated_at: new Date().toISOString(),
        is_deleted: false // Ensure the entry is marked as not deleted
      };
      
      // Update existing mapping
      const { error } = await supabase
        .from('merchant_category_mappings')
        .update(updateData)
        .eq('merchant_name', merchantName);
        
      if (error) {
        console.error('Error updating merchant mapping:', error);
      }
    } else {
      // Create new mapping
      const { error } = await supabase
        .from('merchant_category_mappings')
        .insert({
          merchant_name: merchantName,
          occurrence_count: 1,
          most_common_mcc: mcc,
          is_deleted: false // New entries are not deleted
        });
        
      if (error) {
        console.error('Error creating merchant mapping:', error);
      }
    }
  } catch (error) {
    console.error('Exception in incrementMerchantOccurrence:', error);
  }
};

// Decrement merchant occurrence count when a transaction is deleted
export const decrementMerchantOccurrence = async (merchantName: string): Promise<void> => {
  try {
    const mapping = await getMerchantCategoryMappingByName(merchantName);
    
    if (!mapping) {
      console.warn(`No mapping found for merchant: ${merchantName}`);
      return;
    }
    
    if (mapping.occurrenceCount <= 1) {
      // If count will become zero, mark the mapping as deleted
      const { error } = await supabase
        .from('merchant_category_mappings')
        .update({
          occurrence_count: 0,
          is_deleted: true,
          updated_at: new Date().toISOString()
        })
        .eq('merchant_name', merchantName);
        
      if (error) {
        console.error('Error marking merchant mapping as deleted:', error);
      }
    } else {
      // Decrement the count
      const { error } = await supabase
        .from('merchant_category_mappings')
        .update({
          occurrence_count: mapping.occurrenceCount - 1,
          updated_at: new Date().toISOString()
        })
        .eq('merchant_name', merchantName);
        
      if (error) {
        console.error('Error decrementing merchant count:', error);
      }
    }
  } catch (error) {
    console.error('Exception in decrementMerchantOccurrence:', error);
  }
};

// Check if a merchant has suggestions enabled
export const hasMerchantCategorySuggestions = async (merchantName: string): Promise<boolean> => {
  try {
    const mapping = await getMerchantCategoryMappingByName(merchantName);
    return !!mapping && mapping.occurrenceCount > 0 && !!mapping.mostCommonMCC && !mapping.isDeleted;
  } catch (error) {
    console.error('Error checking merchant suggestions:', error);
    return false;
  }
};

// Get suggested MCC for a merchant
export const getSuggestedMerchantCategory = async (merchantName: string): Promise<MerchantCategoryCode | null> => {
  try {
    const mapping = await getMerchantCategoryMappingByName(merchantName);
    
    if (mapping && mapping.occurrenceCount > 0 && mapping.mostCommonMCC && !mapping.isDeleted) {
      return mapping.mostCommonMCC;
    }
    
    return null;
  } catch (error) {
    console.error('Error getting suggested merchant category:', error);
    return null;
  }
};

================
File: utils/storage/paymentMethods.ts
================
import { PaymentMethod, Currency, RewardRule } from '@/types';
import { defaultPaymentMethods } from '../defaults/paymentMethods';
import { supabase } from '@/integrations/supabase/client';
import { Json } from '@/integrations/supabase/types';

// LocalStorage key for fallback
const PAYMENT_METHODS_KEY = 'expenseTracker_paymentMethods';

// Helper function to convert RewardRule[] to Json for Supabase
const convertRewardRulesToJson = (rules: RewardRule[]): Json => {
  return rules as unknown as Json;
};

// Helper function to convert Json back to RewardRule[]
const convertJsonToRewardRules = (json: Json | null): RewardRule[] => {
  if (!json) return [];
  return json as unknown as RewardRule[];
};

// Helper function to convert conversionRate Record to Json
const convertConversionRateToJson = (rate: Record<Currency, number> | undefined): Json | null => {
  if (!rate) return null;
  return rate as unknown as Json;
};

// Save payment methods to Supabase
export const savePaymentMethods = async (paymentMethods: PaymentMethod[]): Promise<void> => {
  try {
    // First, get current payment methods to identify what needs to be updated or deleted
    const { data: currentMethods, error: fetchError } = await supabase
      .from('payment_methods')
      .select('id');
      
    if (fetchError) {
      console.error('Error fetching current payment methods:', fetchError);
      // Fallback to localStorage
      localStorage.setItem(PAYMENT_METHODS_KEY, JSON.stringify(paymentMethods));
      return;
    }
    
    // Get array of existing IDs
    const existingIds = currentMethods.map(method => method.id);
    
    // Get array of new IDs
    const newIds = paymentMethods.map(method => method.id);
    
    // Find IDs to delete (exist in DB but not in new array)
    const idsToDelete = existingIds.filter(id => !newIds.includes(id));
    
    // Delete methods that are no longer needed
    if (idsToDelete.length > 0) {
      const { error: deleteError } = await supabase
        .from('payment_methods')
        .delete()
        .in('id', idsToDelete);
        
      if (deleteError) {
        console.error('Error deleting payment methods:', deleteError);
      }
    }
    
    // Upsert all methods
    for (const method of paymentMethods) {
      const { error: upsertError } = await supabase
        .from('payment_methods')
        .upsert({
          id: method.id,
          name: method.name,
          type: method.type,
          currency: method.currency,
          reward_rules: convertRewardRulesToJson(method.rewardRules),
          statement_start_day: method.statementStartDay,
          is_monthly_statement: method.isMonthlyStatement,
          active: method.active,
          last_four_digits: method.lastFourDigits,
          issuer: method.issuer,
          icon: method.icon,
          color: method.color,
          image_url: method.imageUrl,
          conversion_rate: convertConversionRateToJson(method.conversionRate),
          selected_categories: method.selectedCategories || [], // Explicitly store selected categories
        }, { onConflict: 'id' });
        
      if (upsertError) {
        console.error('Error upserting payment method:', upsertError);
        // Fallback to localStorage
        localStorage.setItem(PAYMENT_METHODS_KEY, JSON.stringify(paymentMethods));
        return;
      }
    }
  } catch (error) {
    console.error('Error in savePaymentMethods:', error);
    // Fallback to localStorage
    localStorage.setItem(PAYMENT_METHODS_KEY, JSON.stringify(paymentMethods));
  }
};

// Get payment methods from Supabase or return defaults
export const getPaymentMethods = async (): Promise<PaymentMethod[]> => {
  const { data, error } = await supabase
    .from('payment_methods')
    .select('*');
    
  if (error) {
    console.error('Error fetching payment methods:', error);
    // Fallback to localStorage
    const stored = localStorage.getItem(PAYMENT_METHODS_KEY);
    return stored ? JSON.parse(stored) : defaultPaymentMethods;
  }
  
  if (data.length === 0) {
    // No payment methods in database, initialize with defaults
    await initializePaymentMethods();
    return defaultPaymentMethods;
  }
  
  // Transform data to match our PaymentMethod type
  return data.map(method => ({
    id: method.id,
    name: method.name,
    type: method.type as 'cash' | 'credit_card',
    currency: method.currency as Currency,
    rewardRules: convertJsonToRewardRules(method.reward_rules),
    statementStartDay: method.statement_start_day,
    isMonthlyStatement: method.is_monthly_statement,
    active: method.active,
    lastFourDigits: method.last_four_digits,
    issuer: method.issuer,
    icon: method.icon,
    color: method.color,
    imageUrl: method.image_url,
    conversionRate: method.conversion_rate as unknown as Record<Currency, number>,
    selectedCategories: Array.isArray((method as any).selected_categories) ? (method as any).selected_categories : 
                      typeof (method as any).selected_categories === 'string' ? JSON.parse((method as any).selected_categories) : [], // Safely retrieve categories
  }));
};

// Initialize payment methods with defaults
export const initializePaymentMethods = async (): Promise<void> => {
  await savePaymentMethods(defaultPaymentMethods);
};

// Upload card image to storage and get a public URL
export const uploadCardImage = async (file: File, paymentMethodId: string): Promise<string | null> => {
  try {
    // Generate a unique file path
    const filePath = `card-images/${paymentMethodId}/${Date.now()}-${file.name}`;
    
    // Upload the file to supabase storage
    const { data, error } = await supabase.storage
      .from('payment-methods')
      .upload(filePath, file, {
        cacheControl: '3600',
        upsert: true,
      });
      
    if (error) {
      console.error('Error uploading card image:', error);
      return null;
    }
    
    // Get the public URL
    const { data: urlData } = supabase.storage
      .from('payment-methods')
      .getPublicUrl(filePath);
      
    return urlData.publicUrl;
  } catch (error) {
    console.error('Error in uploadCardImage:', error);
    return null;
  }
};

================
File: utils/storage/transactions.ts
================
import { Transaction, Currency } from '@/types';
import { addTransaction } from './transactions/add';
import { editTransaction } from './transactions/edit';
import { deleteTransaction } from './transactions/delete';
import { getTransactions } from './transactions/get';
import { exportTransactionsToCSV } from './transactions/export';
import { saveTransactions } from './transactions/save';
import { 
  getTransactionsFromLocalStorage, 
  saveTransactionsToLocalStorage 
} from './transactions/local-storage';

// Export all transaction-related functions
export {
  getTransactions,
  saveTransactions,
  addTransaction,
  editTransaction,
  deleteTransaction,
  exportTransactionsToCSV,
  getTransactionsFromLocalStorage,
  saveTransactionsToLocalStorage
};

================
File: utils/cardOptimization.ts
================
import { Transaction, PaymentMethod } from '@/types';

/**
 * Calculate the optimal payment method for a given transaction
 * based on reward points, merchant category codes, and other factors
 */
export const calculateOptimalCard = (
  transaction: Transaction,
  paymentMethods: PaymentMethod[]
): PaymentMethod | null => {
  // Only consider credit cards
  const creditCards = paymentMethods.filter(
    method => method.type === 'credit_card' && method.active
  );
  
  if (creditCards.length === 0) return null;
  
  // Calculate estimated points for each card
  const cardScores = creditCards.map(card => {
    let pointsEstimate = 0;
    
    // Basic points (1 point per dollar is standard)
    pointsEstimate += transaction.amount;
    
    // Check for bonus categories based on reward rules
    if (card.rewardRules && card.rewardRules.length > 0) {
      for (const rule of card.rewardRules) {
        let ruleApplies = false;
        
        // Check if rule applies based on type
        if (rule.type === 'mcc' && transaction.merchant.mcc?.code === rule.condition) {
          ruleApplies = true;
        } else if (rule.type === 'merchant' && Array.isArray(rule.condition)) {
          // Check if merchant name contains any of the keywords
          ruleApplies = rule.condition.some(keyword => 
            transaction.merchant.name.toLowerCase().includes(keyword.toLowerCase())
          );
        } else if (transaction.category && rule.condition === transaction.category) {
          // Generic condition match against transaction category
          ruleApplies = true;
        }
        
        // Apply bonus multiplier if rule applies
        if (ruleApplies) {
          // Calculate bonus points (multiplier - 1 because base points are already counted)
          const bonusMultiplier = rule.pointsMultiplier - 1;
          const bonusPoints = transaction.amount * bonusMultiplier;
          
          // Check for spending caps
          if (rule.maxSpend) {
            // This is a simplified check - in a real implementation, 
            // you'd need to track year-to-date spend in each category
            pointsEstimate += Math.min(bonusPoints, rule.maxSpend * bonusMultiplier);
          } else {
            pointsEstimate += bonusPoints;
          }
          
          // Once we find a matching rule, no need to check others
          // (assuming rules don't stack - modify if they do)
          break;
        }
      }
    }
    
    return {
      card,
      pointsEstimate
    };
  });
  
  // Sort by estimated points (highest first)
  cardScores.sort((a, b) => b.pointsEstimate - a.pointsEstimate);
  
  // Return the card with the highest score
  return cardScores.length > 0 ? cardScores[0].card : null;
};

/**
 * Calculate the total missed optimization opportunities in a set of transactions
 */
export const calculateMissedOptimization = (
  transactions: Transaction[],
  paymentMethods: PaymentMethod[]
): {
  missedPoints: number;
  suboptimalTransactions: Transaction[];
  optimizationScore: number;
} => {
  let totalMissedPoints = 0;
  let totalPotentialPoints = 0;
  let totalActualPoints = 0;
  const suboptimalTransactions: Transaction[] = [];
  
  transactions.forEach(transaction => {
    const optimalCard = calculateOptimalCard(transaction, paymentMethods);
    const actualPoints = transaction.rewardPoints || 0;
    totalActualPoints += actualPoints;
    
    if (optimalCard && optimalCard.id !== transaction.paymentMethod.id) {
      // Calculate estimated potential points
      // In a real implementation, you'd use your reward calculation logic
      
      // For now, use a simplified estimate (30% better)
      const estimatedOptimalPoints = actualPoints * 1.3;
      const missedPoints = estimatedOptimalPoints - actualPoints;
      
      totalMissedPoints += missedPoints;
      totalPotentialPoints += estimatedOptimalPoints;
      suboptimalTransactions.push(transaction);
    } else {
      totalPotentialPoints += actualPoints;
    }
  });
  
  // Calculate optimization score (0-100)
  const optimizationScore = totalPotentialPoints > 0 
    ? Math.round((totalActualPoints / totalPotentialPoints) * 100) 
    : 100;
  
  return {
    missedPoints: Math.round(totalMissedPoints),
    suboptimalTransactions,
    optimizationScore
  };
};

/**
 * Get the best card recommendation for future purchases
 */
export const getBestCardRecommendation = (
  transactions: Transaction[],
  paymentMethods: PaymentMethod[]
): { card: PaymentMethod; category: string } | null => {
  // Get active cards
  const activeCards = paymentMethods.filter(
    method => method.type === 'credit_card' && method.active
  );
  
  if (activeCards.length === 0 || transactions.length === 0) return null;
  
  // Find the most frequent category
  const categoryCounts = transactions.reduce((acc, tx) => {
    const category = tx.category;
    acc[category] = (acc[category] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
  
  // Find the most common category
  const mostCommonCategory = Object.entries(categoryCounts)
    .sort((a, b) => b[1] - a[1])[0][0];
  
  // Create a dummy transaction with this category
  const dummyTransaction: Transaction = {
    id: 'dummy',
    date: new Date().toISOString(),
    amount: 100, // Arbitrary amount
    currency: 'USD',
    category: mostCommonCategory,
    merchant: {
      id: 'dummy-merchant',
      name: mostCommonCategory, // Using category as merchant name
      isOnline: false
    },
    paymentAmount: 100,
    paymentCurrency: 'USD',
    paymentMethod: activeCards[0], // Placeholder
    rewardPoints: 0
  };
  
  // Find the best card for this category
  const bestCard = calculateOptimalCard(dummyTransaction, paymentMethods);
  
  if (!bestCard) return null;
  
  return {
    card: bestCard,
    category: mostCommonCategory
  };
};

================
File: utils/CardOptimizationAnalyzer.ts
================
import { Transaction, PaymentMethod, Currency } from '@/types';
import { convertCurrency } from './currencyConversion';

// Define CardSuggestion interface that was missing
export interface CardSuggestion {
  category: string;
  currentMethod: string;
  suggestedMethod: string;
  potentialSavings: number;
  transactionCount: number;
}

interface OptimizedPaymentMethodResult {
  paymentMethod: PaymentMethod;
  potentialPoints: number;
  potentialSavings: number;
  actualPoints: number;
  actualSavings: number;
  difference: number;
}

/**
 * Analyzes transactions to determine if better payment methods could have been used
 */
export class CardOptimizationAnalyzer {
  private transactions: Transaction[];
  private paymentMethods: PaymentMethod[];
  
  constructor(transactions: Transaction[], paymentMethods: PaymentMethod[]) {
    this.transactions = transactions;
    this.paymentMethods = paymentMethods;
  }
  
  /**
   * Calculate the cash value of reward points based on payment method
   */
  private calculateRewardValue(points: number, paymentMethod: PaymentMethod): number {
    // Default value is 0.01 USD per point (1%)
    const defaultValue = 0.01;
    
    // In a real implementation, this would check the payment method's reward program
    // and return the appropriate value per point
    
    // Check if the payment method has categoryRewards defined in rewardRules
    const rewardRules = paymentMethod.rewardRules || [];
    // Use a default value if categoryRewards is not available
    const basePointValue = rewardRules.length > 0 ? 0.01 : defaultValue; 
    
    return points * basePointValue;
  }
  
  /**
   * Analyzes a single transaction to find the best payment method
   */
  private analyzeTransaction(transaction: Transaction): OptimizedPaymentMethodResult[] {
    const { amount, currency, paymentMethod } = transaction;
    
    // Filter payment methods to only include active ones
    const activePaymentMethods = this.paymentMethods.filter(pm => pm.active);
    
    // Sort payment methods by potential points in descending order
    const sortedPaymentMethods = [...activePaymentMethods].sort((a, b) => {
      const potentialPointsA = this.calculatePotentialPoints(transaction, a);
      const potentialPointsB = this.calculatePotentialPoints(transaction, b);
      return potentialPointsB - potentialPointsA;
    });
    
    return sortedPaymentMethods.map(pm => {
      const potentialPoints = this.calculatePotentialPoints(transaction, pm);
      const actualPoints = transaction.rewardPoints;
      
      const potentialSavings = this.calculateRewardValue(potentialPoints, pm);
      const actualSavings = this.calculateRewardValue(actualPoints, paymentMethod);
      
      const difference = potentialSavings - actualSavings;
      
      return {
        paymentMethod: pm,
        potentialPoints,
        potentialSavings,
        actualPoints,
        actualSavings,
        difference
      };
    });
  }
  
  /**
   * Calculate potential reward points for a transaction with a given payment method
   */
  private calculatePotentialPoints(transaction: Transaction, paymentMethod: PaymentMethod): number {
    let points = 0;
    const { amount, currency, merchant } = transaction;
    
    // Check each reward rule for the payment method
    paymentMethod.rewardRules.forEach(rule => {
      let multiplier = 0;
      
      switch (rule.type) {
        case 'mcc':
          if (merchant.mcc && rule.condition === merchant.mcc.code) {
            multiplier = rule.pointsMultiplier;
          }
          break;
          
        case 'merchant':
          if (merchant.name === rule.condition) {
            multiplier = rule.pointsMultiplier;
          }
          break;
          
        case 'currency':
          if (currency === rule.condition) {
            multiplier = rule.pointsMultiplier;
          }
          break;
          
        case 'spend_threshold':
          if (amount >= Number(rule.condition)) {
            multiplier = rule.pointsMultiplier;
          }
          break;
          
        case 'online':
          if (merchant.isOnline && rule.condition === 'true') {
            multiplier = rule.pointsMultiplier;
          } else if (!merchant.isOnline && rule.condition === 'false') {
            multiplier = rule.pointsMultiplier;
          }
          break;
          
        case 'contactless':
          if (transaction.isContactless && rule.condition === 'true') {
            multiplier = rule.pointsMultiplier;
          } else if (!transaction.isContactless && rule.condition === 'false') {
            multiplier = rule.pointsMultiplier;
          }
          break;
      }
      
      // Apply the multiplier
      if (multiplier > 0) {
        points += amount * multiplier;
      }
    });
    
    return points;
  }
  
  /**
   * Run the card optimization analysis
   */
  runAnalysis(): OptimizedPaymentMethodResult[][] {
    return this.transactions.map(transaction => this.analyzeTransaction(transaction));
  }
  
  /**
   * Generate card optimization suggestions based on transaction analysis
   */
  analyzeCardOptimizations(): CardSuggestion[] {
    if (!this.transactions.length || !this.paymentMethods.length) {
      return [];
    }
    
    const analysisResults = this.runAnalysis();
    
    // Group transactions by category
    const categories = new Map<string, Transaction[]>();
    this.transactions.forEach(tx => {
      const category = tx.category || 'Uncategorized';
      if (!categories.has(category)) {
        categories.set(category, []);
      }
      categories.get(category)?.push(tx);
    });
    
    // Create optimization suggestions
    const suggestions: CardSuggestion[] = [];
    
    categories.forEach((categoryTransactions, category) => {
      // Only create suggestions if we have multiple transactions in a category
      if (categoryTransactions.length < 2) return;
      
      // Find the best payment method for this category
      let bestMethod: PaymentMethod | null = null;
      let highestSavings = 0;
      let currentMethodName = '';
      
      // Analyze first transaction as a representative for the category
      const sampleTx = categoryTransactions[0];
      const results = this.analyzeTransaction(sampleTx);
      
      // Find payment method with highest potential savings
      for (const result of results) {
        if (result.difference > highestSavings) {
          highestSavings = result.difference;
          bestMethod = result.paymentMethod;
          currentMethodName = sampleTx.paymentMethod.name;
        }
      }
      
      // If we found a better method with meaningful savings, add to suggestions
      if (bestMethod && highestSavings > 0.1) {
        suggestions.push({
          category,
          currentMethod: currentMethodName,
          suggestedMethod: bestMethod.name,
          potentialSavings: highestSavings * categoryTransactions.length, // Extrapolate to all transactions
          transactionCount: categoryTransactions.length
        });
      }
    });
    
    // Sort suggestions by potential savings (highest first)
    return suggestions.sort((a, b) => b.potentialSavings - a.potentialSavings);
  }
  
  /**
   * Static method to analyze card optimizations from external components
   */
  static analyzeCardOptimizations(
    transactions: Transaction[], 
    paymentMethods: PaymentMethod[]
  ): CardSuggestion[] {
    if (!transactions.length || !paymentMethods.length) {
      return [];
    }
    
    const analyzer = new CardOptimizationAnalyzer(transactions, paymentMethods);
    return analyzer.analyzeCardOptimizations();
  }
}

================
File: utils/categoryMapping.ts
================
import { MerchantCategoryCode } from '@/types';

// Map MCC codes to categories
export const getCategoryFromMCC = (mccCode?: string): string => {
  if (!mccCode) return 'Uncategorized';
  
  // Grocery and Food stores
  if (['5411', '5422', '5451', '5462', '5499', '9751'].includes(mccCode)) {
    return 'Groceries';
  }
  
  // Dining & Food
  if (['5811', '5812', '5813', '5814', '5441', '5921'].includes(mccCode)) {
    return 'Food & Drinks';
  }
  
  // Hawker centers and food courts (Singapore specific)
  if (mccCode === '5814') {
    return 'Food & Drinks';
  }
  
  // Travel and Transport
  if (['4121', '4112', '3000', '7011', '4225', '4119'].includes(mccCode) || 
      (mccCode.startsWith('4') && !['4814', '4899'].includes(mccCode))) {
    return 'Travel';
  }
  
  // Utilities & Telecom
  if (['4814', '4899'].includes(mccCode)) {
    return 'Utilities';
  }
  
  // Shopping - General
  // Combining: General Shopping, Electronics, Clothing, Jewelry, Books, Specialty Retail, etc.
  if (['5300', '5310', '5311', '5331', '5399', '5262', '5309', // General Shopping
       '5045', '5732', '5734', '5815', '5816', '5817', '5818', '7622', // Electronics
       '5137', '5139', '5611', '5621', '5631', '5641', '5651', '5655', '5661', 
       '5681', '5691', '5697', '5698', '5699', // Clothing
       '5094', '5944', '5950', '7631', // Jewelry & Luxury
       '5111', '5192', '5942', '5943', '5947', '5970', '5972', // Books & Gifts
       '5193', '5945', '5946', '5948', '5949', '5963', '5964', '5971', '5973', 
       '5992', '5995', '5997', '5999', '5931', '5932', '5933', '5937', // Specialty Retail
       '5044', '5046', '5065', '5072', '5074', '5978' // Business Supplies
      ].includes(mccCode) || mccCode.startsWith('5')) {
    return 'Shopping';
  }
  
  // Entertainment
  if (['7832', '7941', '5733', '5735', '5941', '5993', '5994', '7993'].includes(mccCode)) {
    return 'Entertainment';
  }
  
  // Health & Personal Care
  if (['5912', '5977', '7230', '7298', '8011', '8021', '8031', '8041', '8042', 
       '8043', '8049', '8050', '8062', '8071', '8099', '5122', '5975', '5976'].includes(mccCode)) {
    return 'Health & Personal Care';
  }
  
  // Services & Repairs
  if (['7273', '7277', '7278', '7296', '7297', '7321', '7339', '7361', '7379', '7392', // Services
       '7623', '7629', // Repairs & Maintenance
       '8351', '8398', '8641', '8651', '8661' // Organizations
      ].includes(mccCode) || 
      (mccCode.startsWith('7') && !['7011', '7230', '7298', '7832', '7622', '7623', '7629', '7631', '7641', '7993'].includes(mccCode))) {
    return 'Services';
  }
  
  // Automotive
  if (['5541', '5940'].includes(mccCode)) {
    return 'Automotive';
  }
  
  // Education
  if (['8211', '8220', '8241', '8244', '8249', '8299'].includes(mccCode)) {
    return 'Education';
  }
  
  // Government Services
  if (['9211', '9222', '9223', '9311', '9399', '9402'].includes(mccCode)) {
    return 'Government';
  }
  
  // Financial Services
  if (['6010', '6011', '6012', '6051', '6211', '6300'].includes(mccCode)) {
    return 'Financial Services';
  }
  
  // For any other MCC code that starts with 5 and is not explicitly categorized
  if (mccCode.startsWith('5')) {
    return 'Shopping';
  }

  // For any other MCC code that starts with 5 and is not explicitly categorized
  if (['6513', '1520',
       '5021', '5039', '5200', '5211', '5231', '5251', '5261', '5271', '5531', 
       '5712', '5713', '5714', '5718', '5719', '5722', '5996', '5998', '7641'].includes(mccCode)) {
    return 'Home & Rent';
  }
  
  // For any other MCC code that starts with 7 or 8
  if (mccCode.startsWith('7') || mccCode.startsWith('8')) {
    return 'Services';
  }
  
  return 'Uncategorized';
};

// Helper function to identify food-related merchants by name for when MCC is unavailable
export const getCategoryFromMerchantName = (merchantName: string): string | null => {
  if (!merchantName) return null;
  
  const name = merchantName.toLowerCase();
  
  // Food courts, hawker centers, and common food establishments in Singapore
  if (
    name.includes('kopitiam') || 
    name.includes('hawker') || 
    name.includes('food court') || 
    name.includes('restaurant') || 
    name.includes('cafe') || 
    name.includes('coffee') || 
    name.includes('mcdonald') || 
    name.includes('kfc') || 
    name.includes('starbucks') || 
    name.includes('subway') || 
    name.includes('eatery') || 
    name.includes('kitchen') || 
    name.includes('canteen')
  ) {
    return 'Food & Drinks';
  }
  
  // Grocery stores and supermarkets
  if (
    name.includes('ntuc') || 
    name.includes('fairprice') || 
    name.includes('cold storage') || 
    name.includes('giant') || 
    name.includes('sheng siong') || 
    name.includes('prime') || 
    name.includes('supermarket') || 
    name.includes('grocery')
  ) {
    return 'Groceries';
  }
  
  return null;
};

================
File: utils/chartDataProcessor.ts
================
// src/utils/chartDataProcessor.ts
import { Transaction, Currency } from "@/types";
import { CurrencyService } from "@/services/CurrencyService";
import { CHART_COLORS } from "@/utils/dashboardCalculations";
import {
  calculatePercentageChange,
  ChartDataItem,
} from "@/utils/dashboardUtils";

/**
 * Processed data for bar chart items with additional metadata
 */
export interface ProcessedChartItem extends ChartDataItem {
  /** Period label (e.g., "Jan", "Q1", "Week 1") */
  period: string;
  /** Original date/time key before formatting */
  originalKey: string;
  /** Top spending categories for this period */
  topCategories?: Array<{ category: string; amount: number }>;
}

/**
 * Result of chart data processing with trend analysis
 */
export interface ChartProcessingResult {
  /** Formatted data ready for chart rendering */
  chartData: ProcessedChartItem[];
  /** Percentage change compared to previous period */
  trend: number;
  /** Average value across all periods */
  average: number;
  /** Top categories across all periods */
  topCategories: Array<{ category: string; amount: number }>;
}

/**
 * Options for chart data processing
 */
export interface ChartProcessingOptions {
  /** Time period grouping ('day', 'week', 'month', 'year') */
  period?: "day" | "week" | "month" | "quarter";
  /** Whether to include category breakdown for tooltip display */
  includeCategoryBreakdown?: boolean;
  /** Maximum number of top categories to include */
  maxTopCategories?: number;
  /** Whether to calculate trend percentage */
  includeTrend?: boolean;
  /** Currency for display and conversion */
  displayCurrency?: Currency;
  /** Whether to account for reimbursements in calculations */
  accountForReimbursements?: boolean;
}

/**
 * Process transaction data into pie chart format
 *
 * @param transactions - Transactions to process
 * @param groupByField - Field to group by (paymentMethod, category, etc.)
 * @param displayCurrency - Currency to convert values to
 * @param colorPalette - Color scheme to use
 * @param accountForReimbursements - Whether to subtract reimbursed amounts
 * @returns Array of formatted chart data items
 */
export function processPieChartData(
  transactions: Transaction[],
  groupByField: "paymentMethod" | "category" | string,
  displayCurrency: Currency,
  colorPalette: string[] = CHART_COLORS,
  accountForReimbursements: boolean = true
): ChartDataItem[] {
  if (!transactions || transactions.length === 0) return [];

  // Group transactions by the specified field
  const groups = new Map<string, number>();

  transactions.forEach((tx) => {
    let key = "Uncategorized";

    if (groupByField === "paymentMethod") {
      key = tx.paymentMethod?.name || "Unknown";
    } else if (groupByField === "category") {
      key = tx.category || "Uncategorized";
    } else if (tx[groupByField as keyof Transaction]) {
      // Handle other potential grouping fields
      key = String(tx[groupByField as keyof Transaction]);
    }

    // Convert amount to display currency
    const convertedAmount = CurrencyService.convert(
      tx.amount,
      tx.currency as Currency,
      displayCurrency,
      tx.paymentMethod
    );

    // Adjust for reimbursements if applicable
    let finalAmount = convertedAmount;
    if (accountForReimbursements && tx.reimbursementAmount) {
      const reimbursedAmount = CurrencyService.convert(
        tx.reimbursementAmount,
        tx.currency as Currency, // Reimbursement is in same currency as transaction
        displayCurrency,
        tx.paymentMethod
      );
      finalAmount -= reimbursedAmount;
    }

    groups.set(key, (groups.get(key) || 0) + finalAmount);
  });

  // Calculate total for percentage calculations
  const total = Array.from(groups.values()).reduce(
    (sum, value) => sum + value,
    0
  );

  // Convert to chart data array with colors
  return Array.from(groups.entries())
    .map(([name, value], index) => ({
      name,
      value,
      color: colorPalette[index % colorPalette.length],
      percentage: total > 0 ? (value / total) * 100 : 0,
    }))
    .sort((a, b) => b.value - a.value); // Sort by value descending
}

/**
 * Groups transactions by time period (day, week, month, year)
 *
 * @param transactions - Transactions to group
 * @param groupBy - Time period to group by
 * @returns Map of date keys to transaction arrays
 */
export function groupTransactionsByPeriod(
  transactions: Transaction[],
  groupBy: "day" | "week" | "month" | "year"
): Map<string, Transaction[]> {
  const grouped = new Map<string, Transaction[]>();

  transactions.forEach((transaction) => {
    const date = new Date(transaction.date);
    let key: string;

    switch (groupBy) {
      case "day":
        key = date.toISOString().split("T")[0]; // YYYY-MM-DD
        break;
      case "week": {
        // Get the start of the week (Sunday)
        const startOfWeek = new Date(date);
        startOfWeek.setDate(date.getDate() - date.getDay());
        key = startOfWeek.toISOString().split("T")[0];
        break;
      }
      case "month":
        key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`;
        break;
      case "year":
        key = `${date.getFullYear()}`;
        break;
      default:
        key = date.toISOString().split("T")[0]; // Default to day
    }

    if (!grouped.has(key)) {
      grouped.set(key, []);
    }

    grouped.get(key)?.push(transaction);
  });

  return grouped;
}

/**
 * Get top spending categories for a set of transactions
 *
 * @param transactions - Transactions to analyze
 * @param maxCategories - Maximum number of categories to return
 * @param displayCurrency - Currency to convert amounts to
 * @param accountForReimbursements - Whether to subtract reimbursed amounts
 * @returns Array of category and amount pairs
 */
export function getTopCategoriesForPeriod(
  transactions: Transaction[],
  maxCategories: number = 3,
  displayCurrency: Currency = "SGD",
  accountForReimbursements: boolean = true
): Array<{ category: string; amount: number }> {
  // Group by category
  const categoryMap = new Map<string, number>();

  transactions.forEach((tx) => {
    if (!tx.category) return;

    // Convert to display currency
    const convertedAmount = CurrencyService.convert(
      tx.amount,
      tx.currency as Currency,
      displayCurrency,
      tx.paymentMethod
    );

    // Adjust for reimbursements if applicable
    let finalAmount = convertedAmount;
    if (accountForReimbursements && tx.reimbursementAmount) {
      const reimbursedAmount = CurrencyService.convert(
        tx.reimbursementAmount,
        tx.currency as Currency,
        displayCurrency,
        tx.paymentMethod
      );
      finalAmount -= reimbursedAmount;
    }

    const existingAmount = categoryMap.get(tx.category) || 0;
    categoryMap.set(tx.category, existingAmount + finalAmount);
  });

  // Convert to array and sort by amount (descending)
  const categories = Array.from(categoryMap.entries())
    .map(([category, amount]) => ({ category, amount }))
    .sort((a, b) => b.amount - a.amount);

  return categories.slice(0, maxCategories);
}

/**
 * Process transactions for time-based chart visualization
 *
 * @param transactions - Transactions to process
 * @param options - Processing options
 * @returns Processed chart data with trends and insights
 */
export function processTransactionsForChart(
  transactions: Transaction[],
  options: ChartProcessingOptions = {}
): ChartProcessingResult {
  const {
    period = "month",
    includeCategoryBreakdown = true,
    maxTopCategories = 3,
    includeTrend = true,
    displayCurrency = "SGD",
    accountForReimbursements = true,
  } = options;

  if (transactions.length === 0) {
    return {
      chartData: [],
      trend: 0,
      average: 0,
      topCategories: [],
    };
  }

  // Determine the grouping period based on selected time frame
  const periodMapping: Record<string, "day" | "week" | "month" | "year"> = {
    week: "day",
    month: "week",
    quarter: "month",
    year: "month",
  };

  // Group transactions by date
  const groupedTransactions = groupTransactionsByPeriod(
    transactions,
    periodMapping[period] || "month"
  );

  // Get top categories for the most recent period
  const sortedKeys = Array.from(groupedTransactions.keys()).sort();
  const latestKey = sortedKeys[sortedKeys.length - 1];
  const latestTransactions = latestKey
    ? groupedTransactions.get(latestKey) || []
    : [];

  // Get top categories
  const topCats = getTopCategoriesForPeriod(
    latestTransactions,
    maxTopCategories,
    displayCurrency,
    accountForReimbursements
  );

  // Format keys for display
  const processedChartData = sortedKeys.map((key) => {
    const periodTransactions = groupedTransactions.get(key) || [];

    // Calculate total for the period with reimbursement adjustments
    const total = periodTransactions.reduce((sum, tx) => {
      // Convert to display currency
      const convertedAmount = CurrencyService.convert(
        tx.amount,
        tx.currency as Currency,
        displayCurrency,
        tx.paymentMethod
      );

      // Adjust for reimbursements if applicable
      let finalAmount = convertedAmount;
      if (accountForReimbursements && tx.reimbursementAmount) {
        const reimbursedAmount = CurrencyService.convert(
          tx.reimbursementAmount,
          tx.currency as Currency,
          displayCurrency,
          tx.paymentMethod
        );
        finalAmount -= reimbursedAmount;
      }

      return sum + finalAmount;
    }, 0);

    // Get top categories for this period if requested
    const periodTopCategories = includeCategoryBreakdown
      ? getTopCategoriesForPeriod(
          periodTransactions,
          maxTopCategories,
          displayCurrency,
          accountForReimbursements
        )
      : [];

    // Format the key for display
    let displayDate = key;
    if (periodMapping[period] === "week") {
      // For weeks, show date range
      const startDate = new Date(key);
      const endDate = new Date(startDate);
      endDate.setDate(startDate.getDate() + 6);
      displayDate = `${startDate.getDate()}/${startDate.getMonth() + 1} - ${endDate.getDate()}/${endDate.getMonth() + 1}`;
    } else if (periodMapping[period] === "month") {
      // For months, show month name
      const [year, month] = key.split("-");
      const date = new Date(parseInt(year), parseInt(month) - 1, 1);
      displayDate = date.toLocaleString("default", { month: "short" });
      if (period === "quarter") {
        displayDate += ` ${year}`;
      }
    }

    return {
      period: displayDate,
      amount: total,
      originalKey: key,
      name: displayDate, // For consistency with ChartDataItem
      value: total, // For consistency with ChartDataItem
      color: "#8884d8", // Default color
      topCategories: periodTopCategories,
    };
  });

  // Calculate trend (period-over-period change)
  let calculatedTrend = 0;
  if (includeTrend && processedChartData.length >= 2) {
    const currentAmount =
      processedChartData[processedChartData.length - 1].amount;
    const previousAmount =
      processedChartData[processedChartData.length - 2].amount;
    calculatedTrend = calculatePercentageChange(currentAmount, previousAmount);
  }

  // Calculate average
  const calculatedAverage =
    processedChartData.length > 0
      ? processedChartData.reduce((sum, item) => sum + item.amount, 0) /
        processedChartData.length
      : 0;

  return {
    chartData: processedChartData,
    trend: calculatedTrend,
    average: calculatedAverage,
    topCategories: topCats,
  };
}

================
File: utils/currencyFormatter.ts
================
import { Currency } from '@/types';

const currencySymbols: Record<Currency, string> = {
  USD: '$',
  EUR: '€',
  GBP: '£',
  JPY: '¥',
  AUD: 'A$',
  CAD: 'C$',
  CNY: '¥',
  INR: '₹',
  TWD: 'NT$',
  SGD: 'S$',  // Explicitly set to 'S$' for consistency
  VND: '₫',
  IDR: 'Rp',
  THB: '฿',
  MYR: 'RM',
};

export const formatCurrency = (amount: number, currency: Currency): string => {
  // Added debug log to check currency formatting
  console.log(`Formatting currency: ${amount} ${currency}`);
  
  // Handle edge cases where currency might be undefined or invalid
  if (!currency || !Object.keys(currencySymbols).includes(currency)) {
    console.warn(`Invalid currency provided: ${currency}, using USD as fallback`);
    currency = 'USD' as Currency;
  }
  
  // Instead of using the built-in Intl.NumberFormat currency formatting,
  // we'll use our custom currency symbols and format the number separately
  const formatter = new Intl.NumberFormat('en-US', {
    style: 'decimal', // Use decimal instead of currency to avoid built-in currency symbols
    minimumFractionDigits: ['JPY', 'VND', 'IDR', 'TWD'].includes(currency) ? 0 : 2,
    maximumFractionDigits: ['JPY', 'VND', 'IDR', 'TWD'].includes(currency) ? 0 : 2,
  });
  
  // Get the symbol from our mapping and combine with the formatted number
  const symbol = currencySymbols[currency];
  return `${symbol}${formatter.format(amount)}`;
};

export const getCurrencySymbol = (currency: Currency): string => {
  return currencySymbols[currency] || currency;
};

export const currencyOptions: { value: Currency; label: string }[] = [
  { value: 'USD', label: 'USD - US Dollar ($)' },
  { value: 'EUR', label: 'EUR - Euro (€)' },
  { value: 'GBP', label: 'GBP - British Pound (£)' },
  { value: 'JPY', label: 'JPY - Japanese Yen (¥)' },
  { value: 'AUD', label: 'AUD - Australian Dollar (A$)' },
  { value: 'CAD', label: 'CAD - Canadian Dollar (C$)' },
  { value: 'CNY', label: 'CNY - Chinese Yuan (¥)' },
  { value: 'INR', label: 'INR - Indian Rupee (₹)' },
  { value: 'TWD', label: 'TWD - New Taiwan Dollar (NT$)' },
  { value: 'SGD', label: 'SGD - Singapore Dollar (S$)' },
  { value: 'VND', label: 'VND - Vietnamese Dong (₫)' },
  { value: 'IDR', label: 'IDR - Indonesian Rupiah (Rp)' },
  { value: 'THB', label: 'THB - Thai Baht (฿)' },
  { value: 'MYR', label: 'MYR - Malaysian Ringgit (RM)' },
];

================
File: utils/dashboardCalculations.ts
================
// src/utils/dashboardCalculations.ts
import { Transaction, Currency } from "@/types";
import {
  calculateTotalExpenses,
  calculatePercentageChange,
  calculateAverageAmount,
  calculateTotalRewardPoints,
  calculateTransactionVelocity,
  calculateAverageByDayOfWeek,
  calculateTotalReimbursed,
  getTopChartItem,
  ChartDataItem,
} from "./dashboardUtils";
import { convertCurrency } from "./currencyConversion";

/**
 * Shared color palette for visualizations
 */
export const CHART_COLORS = [
  "#3B82F6", // blue
  "#10B981", // green
  "#F59E0B", // amber
  "#8B5CF6", // violet
  "#EC4899", // pink
  "#6366F1", // indigo
  "#EF4444", // red
  "#14B8A6", // teal
  "#F97316", // orange
];

/**
 * Generate payment method chart data
 * Now accounts for reimbursed amounts
 */
export function generatePaymentMethodChartData(
  transactions: Transaction[],
  displayCurrency: Currency,
  accountForReimbursements: boolean = true
): ChartDataItem[] {
  if (transactions.length === 0) return [];

  const methodTotals = new Map<string, number>();

  // Sum up amounts by payment method
  transactions.forEach((tx) => {
    try {
      const methodName = tx.paymentMethod?.name || "Unknown";
      const convertedAmount = CurrencyService.convert(
        tx.amount,
        tx.currency as Currency,
        displayCurrency,
        tx.paymentMethod
      );

      // Subtract reimbursement if enabled
      let finalAmount = convertedAmount;
      if (accountForReimbursements && tx.reimbursementAmount) {
        const convertedReimbursement = CurrencyService.convert(
          tx.reimbursementAmount,
          tx.currency as Currency,
          displayCurrency,
          tx.paymentMethod
        );
        finalAmount -= convertedReimbursement;
      }

      const current = methodTotals.get(methodName) || 0;
      methodTotals.set(methodName, current + finalAmount);
    } catch (error) {
      console.error("Error processing payment method data:", error);
    }
  });

  // Convert to chart data array with colors
  return Array.from(methodTotals.entries())
    .map(([name, value], index) => ({
      name,
      value,
      color: CHART_COLORS[index % CHART_COLORS.length],
    }))
    .sort((a, b) => b.value - a.value);
}

/**
 * Generate category chart data
 * Now accounts for reimbursed amounts
 */
export function generateCategoryChartData(
  transactions: Transaction[],
  displayCurrency: Currency,
  accountForReimbursements: boolean = true
): ChartDataItem[] {
  if (transactions.length === 0) return [];

  const categoryTotals = new Map<string, number>();

  // Sum up amounts by category
  transactions.forEach((tx) => {
    try {
      const category = tx.category || "Uncategorized";
      const convertedAmount = CurrencyService.convert(
        tx.amount,
        tx.currency as Currency,
        displayCurrency,
        tx.paymentMethod
      );

      // Subtract reimbursement if enabled
      let finalAmount = convertedAmount;
      if (accountForReimbursements && tx.reimbursementAmount) {
        const convertedReimbursement = CurrencyService.convert(
          tx.reimbursementAmount,
          tx.currency as Currency,
          displayCurrency,
          tx.paymentMethod
        );
        finalAmount -= convertedReimbursement;
      }

      const current = categoryTotals.get(category) || 0;
      categoryTotals.set(category, current + finalAmount);
    } catch (error) {
      console.error("Error processing category data:", error);
    }
  });

  // Convert to chart data array with colors
  return Array.from(categoryTotals.entries())
    .map(([name, value], index) => ({
      name,
      value,
      color: CHART_COLORS[index % CHART_COLORS.length],
    }))
    .sort((a, b) => b.value - a.value);
}

================
File: utils/dashboardUtils.ts
================
// src/utils/dashboardUtils.ts
import { Transaction, Currency, PaymentMethod } from "@/types";
import { CurrencyService } from "@/services/CurrencyService";
import { TimeframeTab } from "@/utils/transactionProcessor";

/**
 * Chart data item interface
 * Moved from dashboardCalculations.ts for centralization
 */
export interface ChartDataItem {
  name: string;
  value: number;
  color: string;
}

/**
 * Calculate total expenses with currency conversion
 *
 * @param transactions - Transactions to sum
 * @param displayCurrency - Currency to convert amounts to
 * @returns Total expense amount in the display currency
 */
export function calculateTotalExpenses(
  transactions: Transaction[],
  displayCurrency: Currency
): number {
  return transactions.reduce((total, tx) => {
    try {
      const convertedAmount = CurrencyService.convert(
        tx.amount,
        tx.currency as Currency,
        displayCurrency,
        tx.paymentMethod
      );
      return total + convertedAmount;
    } catch (error) {
      console.error("Error converting currency:", error);
      return total;
    }
  }, 0);
}

/**
 * Calculate total reimbursed amount with currency conversion
 *
 * @param transactions - Transactions to sum reimbursements from
 * @param displayCurrency - Currency to convert amounts to
 * @returns Total reimbursed amount in the display currency
 */
export function calculateTotalReimbursed(
  transactions: Transaction[],
  displayCurrency: Currency
): number {
  return transactions.reduce((total, tx) => {
    try {
      // Skip if no reimbursement amount
      if (!tx.reimbursementAmount) return total;

      const convertedAmount = CurrencyService.convert(
        tx.reimbursementAmount,
        tx.currency as Currency, // Reimbursement is in the same currency as the transaction
        displayCurrency,
        tx.paymentMethod
      );
      return total + convertedAmount;
    } catch (error) {
      console.error("Error converting reimbursement currency:", error);
      return total;
    }
  }, 0);
}

/**
 * Calculate percentage change between two values
 *
 * @param current - Current value
 * @param previous - Previous value to compare against
 * @returns Percentage change (positive for increase, negative for decrease)
 */
export function calculatePercentageChange(
  current: number,
  previous: number
): number {
  if (previous === 0) return current > 0 ? 100 : 0;
  return ((current - previous) / Math.abs(previous)) * 100;
}

/**
 * Calculate average transaction amount
 *
 * @param totalAmount - Sum of all transaction amounts
 * @param transactionCount - Number of transactions
 * @returns Average amount per transaction
 */
export function calculateAverageAmount(
  totalAmount: number,
  transactionCount: number
): number {
  return transactionCount > 0 ? totalAmount / transactionCount : 0;
}

/**
 * Calculate total reward points
 *
 * @param transactions - Transactions to sum points from
 * @returns Total reward points earned
 */
export function calculateTotalRewardPoints(
  transactions: Transaction[]
): number {
  return transactions.reduce((total, tx) => total + (tx.rewardPoints || 0), 0);
}

/**
 * Calculate transaction velocity (rate of transactions over time)
 *
 * @param transactions - Transactions to analyze
 * @param days - Number of days in the period
 * @returns Average number of transactions per day
 */
export function calculateTransactionVelocity(
  transactions: Transaction[],
  days: number
): number {
  if (transactions.length === 0 || days === 0) return 0;
  return transactions.length / days;
}

/**
 * Get the top item from chart data
 *
 * @param chartData - Chart data to analyze
 * @returns The item with the highest value, or undefined if empty
 */
export function getTopChartItem(
  chartData: ChartDataItem[]
): { name: string; value: number } | undefined {
  return chartData.length > 0
    ? { name: chartData[0].name, value: chartData[0].value }
    : undefined;
}

/**
 * Calculate average spend by day of week
 *
 * @param transactions - Transactions to analyze
 * @param displayCurrency - Currency to convert amounts to
 * @returns Object with day names as keys and average spend as values
 */
export function calculateAverageByDayOfWeek(
  transactions: Transaction[],
  displayCurrency: Currency
): Record<string, number> {
  if (transactions.length === 0) return {};

  const dayTotals = new Map<number, number>();
  const dayCounts = new Map<number, number>();
  const dayNames = [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
  ];

  transactions.forEach((tx) => {
    try {
      const txDate = new Date(tx.date);
      const dayOfWeek = txDate.getDay(); // 0-6, starting Sunday

      const convertedAmount = CurrencyService.convert(
        tx.amount,
        tx.currency as Currency,
        displayCurrency,
        tx.paymentMethod
      );

      // If there's a reimbursement, subtract it from the amount
      const netAmount =
        convertedAmount -
        (tx.reimbursementAmount
          ? CurrencyService.convert(
              tx.reimbursementAmount,
              tx.currency as Currency,
              displayCurrency,
              tx.paymentMethod
            )
          : 0);

      dayTotals.set(dayOfWeek, (dayTotals.get(dayOfWeek) || 0) + netAmount);
      dayCounts.set(dayOfWeek, (dayCounts.get(dayOfWeek) || 0) + 1);
    } catch (error) {
      console.error("Error calculating day of week average:", error);
    }
  });

  // Calculate averages
  const result: Record<string, number> = {};
  for (let i = 0; i < 7; i++) {
    const total = dayTotals.get(i) || 0;
    const count = dayCounts.get(i) || 0;
    result[dayNames[i]] = count > 0 ? total / count : 0;
  }

  return result;
}

/**
 * Get the appropriate previous timeframe for comparison
 *
 * @param currentTimeframe - Current selected timeframe
 * @returns The most logical previous timeframe for comparison
 */
export function getPreviousTimeframe(
  currentTimeframe: TimeframeTab
): TimeframeTab {
  switch (currentTimeframe) {
    case "thisMonth":
      return "lastMonth";
    case "lastMonth":
      return "thisMonth"; // Changed from lastThreeMonths to thisMonth since lastThreeMonths is not in TimeframeTab
    case "thisYear":
      return "lastMonth"; // Fallback to last month
    default:
      return "lastMonth";
  }
}

/**
 * Determines if enough data is available for meaningful trend analysis
 *
 * @param transactions - Transactions to analyze
 * @param minimumCount - Minimum number of transactions required
 * @returns Whether there's enough data for trend analysis
 */
export function hasEnoughDataForTrends(
  transactions: Transaction[],
  minimumCount: number = 5
): boolean {
  return transactions.length >= minimumCount;
}

================
File: utils/dateUtils.ts
================
import { format, parse, isWithinInterval, startOfMonth, endOfMonth, addMonths } from 'date-fns';
import { PaymentMethod } from '@/types';

export const formatDate = (dateString: string): string => {
  const date = new Date(dateString);
  return format(date, 'MMM d, yyyy');
};

export const formatDateShort = (dateString: string): string => {
  const date = new Date(dateString);
  return format(date, 'MM/dd/yy');
};

export const formatDateTime = (dateString: string): string => {
  const date = new Date(dateString);
  return format(date, 'MMM d, yyyy h:mm a');
};

export const getCurrentDateString = (): string => {
  return format(new Date(), 'yyyy-MM-dd');
};

export const getStatementPeriod = (
  paymentMethod: PaymentMethod,
  date: Date = new Date()
): { start: Date; end: Date } => {
  // If no statement configuration, default to calendar month
  if (!paymentMethod.statementStartDay || !paymentMethod.isMonthlyStatement) {
    return {
      start: startOfMonth(date),
      end: endOfMonth(date),
    };
  }

  // Get statement start day (1-31)
  const statementDay = paymentMethod.statementStartDay;
  
  // Find the start date of the current statement period
  let statementStart = new Date(date.getFullYear(), date.getMonth(), statementDay);
  
  // If the current date is before the statement start day, the statement started in the previous month
  if (date.getDate() < statementDay) {
    statementStart = new Date(date.getFullYear(), date.getMonth() - 1, statementDay);
  }
  
  // Statement end is one day before the next statement start
  const statementEnd = new Date(statementStart);
  statementEnd.setMonth(statementEnd.getMonth() + 1);
  statementEnd.setDate(statementEnd.getDate() - 1);
  
  return { start: statementStart, end: statementEnd };
};

export const isDateInStatementPeriod = (
  date: Date, 
  paymentMethod: PaymentMethod
): boolean => {
  const { start, end } = getStatementPeriod(paymentMethod, date);
  return isWithinInterval(date, { start, end });
};

================
File: utils/errorHandling.ts
================
// src/utils/errorHandling.ts

/**
 * Standard error types for the application
 */
export enum ErrorType {
    DATA_FETCH = 'data_fetch',
    DATA_PROCESSING = 'data_processing',
    USER_INPUT = 'user_input',
    NETWORK = 'network',
    UNKNOWN = 'unknown'
  }
  
  /**
   * Custom error class with additional context for better debugging and user feedback
   */
  export class AppError extends Error {
    readonly type: ErrorType;
    readonly context?: Record<string, any>;
    readonly originalError?: Error;
  
    constructor(
      message: string,
      type: ErrorType = ErrorType.UNKNOWN,
      context?: Record<string, any>,
      originalError?: Error
    ) {
      super(message);
      this.name = 'AppError';
      this.type = type;
      this.context = context;
      this.originalError = originalError;
      
      // Preserve the stack trace
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, AppError);
      }
    }
  }
  
  /**
   * Helper function to safely execute a function and handle errors
   * Provides consistent error handling throughout the application
   */
  export async function tryCatchWrapper<T>(
    fn: () => Promise<T>,
    errorType: ErrorType,
    errorContext?: Record<string, any>,
    fallbackValue?: T
  ): Promise<T> {
    try {
      return await fn();
    } catch (error) {
      console.error(`Error in tryCatchWrapper:`, error);
      
      // Create a standardized error with context
      const appError = new AppError(
        error instanceof Error ? error.message : 'Unknown error occurred',
        errorType,
        errorContext,
        error instanceof Error ? error : undefined
      );
      
      // Log the structured error for debugging
      console.error('Structured error:', {
        type: appError.type,
        message: appError.message,
        context: appError.context,
        originalError: appError.originalError
      });
      
      // If a fallback value is provided, return it
      if (fallbackValue !== undefined) {
        return fallbackValue;
      }
      
      // Otherwise re-throw the error
      throw appError;
    }
  }
  
  /**
   * Safely access nested properties without throwing
   * Useful for handling potentially undefined data
   */
  export function safelyAccessProperty<T, K extends keyof T>(
    obj: T | null | undefined,
    key: K,
    defaultValue: T[K]
  ): T[K] {
    if (obj == null) {
      return defaultValue;
    }
    return obj[key] !== undefined ? obj[key] : defaultValue;
  }
  
  /**
   * Safely parse JSON without throwing exceptions
   */
  export function safelyParseJSON<T>(jsonString: string, defaultValue: T): T {
    try {
      return JSON.parse(jsonString) as T;
    } catch (error) {
      console.error('Error parsing JSON:', error);
      return defaultValue;
    }
  }
  
  /**
   * Safely convert values to numbers
   */
  export function safelyParseNumber(value: any, defaultValue: number = 0): number {
    if (value === null || value === undefined) {
      return defaultValue;
    }
    
    const parsedValue = Number(value);
    return isNaN(parsedValue) ? defaultValue : parsedValue;
  }

================
File: utils/formatting.ts
================
// src/utils/formatting.ts

/**
 * Formats a number with thousands separators
 * @param value Number to format
 * @returns Formatted string with thousands separators
 */
export const formatNumber = (value: number): string => {
  return value.toLocaleString();
};

/**
 * Formats a percentage value with appropriate sign and decimal places
 * @param value Percentage value to format
 * @param showSign Whether to show + sign for positive values
 * @param decimalPlaces Number of decimal places to show
 * @returns Formatted percentage string
 */
export const formatPercentage = (
  value: number,
  showSign: boolean = false,
  decimalPlaces: number = 1
): string => {
  const formattedValue = value.toFixed(decimalPlaces);
  const prefix = showSign && value > 0 ? "+" : "";
  return `${prefix}${formattedValue}%`;
};

/**
 * Determines if an expense percentage change is positive (bad) or negative (good)
 * For expenses, an increase is bad (positive = true), a decrease is good (positive = false)
 * @param percentageChange Percentage change value
 * @returns Boolean indicating if change is positive (bad for expenses)
 */
export const isExpenseChangePositive = (percentageChange: number): boolean => {
  return percentageChange >= 0;
};

/**
 * Gets the appropriate color class for an expense trend
 * @param percentageChange Percentage change value
 * @returns CSS class for coloring the trend
 */
export const getExpenseTrendColor = (percentageChange: number): string => {
  const isPositive = isExpenseChangePositive(percentageChange);
  return isPositive
    ? "text-red-500 dark:text-red-400"
    : "text-green-500 dark:text-green-400";
};

/**
 * Formats a date string in a consistent way
 * @param dateString ISO date string
 * @returns Formatted date (e.g., "Jan 15, 2023")
 */
export const formatDate = (dateString: string): string => {
  const date = new Date(dateString);
  return date.toLocaleDateString(undefined, {
    month: "short",
    day: "numeric",
    year: "numeric",
  });
};

/**
 * Formats a date string in a short format
 * @param dateString ISO date string
 * @returns Formatted date (e.g., "01/15/23")
 */
export const formatDateShort = (dateString: string): string => {
  const date = new Date(dateString);
  return date.toLocaleDateString(undefined, {
    month: "2-digit",
    day: "2-digit",
    year: "2-digit",
  });
};

/**
 * Formats a date with time
 * @param dateString ISO date string
 * @returns Formatted date with time (e.g., "Jan 15, 2023 2:30 PM")
 */
export const formatDateTime = (dateString: string): string => {
  const date = new Date(dateString);
  return date.toLocaleString(undefined, {
    month: "short",
    day: "numeric",
    year: "numeric",
    hour: "numeric",
    minute: "2-digit",
  });
};

/**
 * Gets the current date as an ISO string (YYYY-MM-DD)
 * @returns Current date in YYYY-MM-DD format
 */
export const getCurrentDateString = (): string => {
  const date = new Date();
  return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}-${String(date.getDate()).padStart(2, "0")}`;
};

================
File: utils/storageUtils.ts
================
// Centralized exports from refactored modules
export { MCC_CODES } from './constants/mcc';
export { 
  getTransactions, 
  saveTransactions, 
  addTransaction,
  editTransaction,
  deleteTransaction,
  exportTransactionsToCSV
} from './storage/transactions';
export { 
  getPaymentMethods, 
  savePaymentMethods, 
  initializePaymentMethods,
  uploadCardImage
} from './storage/paymentMethods';
export { 
  getMerchants, 
  getMerchantByName, 
  addOrUpdateMerchant 
} from './storage/merchants';
export {
  getMerchantCategoryMappings,
  getMerchantCategoryMappingByName,
  incrementMerchantOccurrence,
  decrementMerchantOccurrence,
  hasMerchantCategorySuggestions,
  getSuggestedMerchantCategory
} from './storage/merchantTracking';
export { defaultPaymentMethods } from './defaults/paymentMethods';
export { getCategoryFromMCC } from './categoryMapping';

// Initialize storage with default data
export const initializeStorage = async (): Promise<void> => {
  // Import needed functions directly to avoid circular dependencies
  const { getPaymentMethods, initializePaymentMethods } = await import('./storage/paymentMethods');
  
  // Force reinitialize payment methods to include any new default methods
  await initializePaymentMethods();
};

================
File: utils/TransactionAnalyzer.ts
================
// src/utils/TransactionAnalyzer.ts
import { Transaction, PaymentMethod } from '@/types';

export class TransactionAnalyzer {
  /**
   * Group transactions by a specific attribute
   * @param transactions Array of transactions
   * @param groupBy Key to group by (e.g., 'category', 'paymentMethod')
   * @returns Map of grouped transactions
   */
  static groupTransactionsBy(
    transactions: Transaction[], 
    groupBy: keyof Transaction
  ): Map<string, Transaction[]> {
    const groups = new Map<string, Transaction[]>();
    
    transactions.forEach(transaction => {
      const key = String(transaction[groupBy] || 'Uncategorized');
      
      if (!groups.has(key)) {
        groups.set(key, []);
      }
      groups.get(key)!.push(transaction);
    });
    
    return groups;
  }

  /**
   * Calculate total spending for a group of transactions
   * @param transactions Array of transactions
   * @returns Total spending amount
   */
  static calculateTotalSpending(transactions: Transaction[]): number {
    return transactions.reduce((sum, tx) => sum + tx.amount, 0);
  }

  /**
   * Find the top payment method based on total spending
   * @param transactions Array of transactions
   * @param paymentMethods Available payment methods
   * @returns Top payment method object
   */
  static findTopPaymentMethod(
    transactions: Transaction[], 
    paymentMethods: PaymentMethod[]
  ): { name: string; value: number } {
    const methodSpending = new Map<string, number>();
    
    transactions.forEach(tx => {
      const methodId = tx.paymentMethod?.id;
      if (methodId) {
        methodSpending.set(
          methodId, 
          (methodSpending.get(methodId) || 0) + tx.amount
        );
      }
    });
    
    let topMethodId = '';
    let maxSpending = 0;
    
    methodSpending.forEach((value, key) => {
      if (value > maxSpending) {
        maxSpending = value;
        topMethodId = key;
      }
    });
    
    const topMethod = paymentMethods.find(m => m.id === topMethodId);
    
    return {
      name: topMethod?.name || 'Unknown',
      value: maxSpending
    };
  }

  /**
   * Calculate percentage change between current and previous period
   * @param currentValue Current period value
   * @param previousValue Previous period value
   * @returns Percentage change
   */
  static calculatePercentageChange(
    currentValue: number, 
    previousValue: number
  ): number {
    if (previousValue === 0) return 0;
    return ((currentValue - previousValue) / previousValue) * 100;
  }

  /**
   * Group transactions by time period
   * @param transactions Array of transactions
   * @param period Grouping period (day, week, month, year)
   * @returns Map of transactions grouped by period
   */
  static groupTransactionsByPeriod(
    transactions: Transaction[], 
    period: 'day' | 'week' | 'month' | 'year'
  ): Map<string, Transaction[]> {
    const groups = new Map<string, Transaction[]>();
    
    transactions.forEach(transaction => {
      const date = new Date(transaction.date);
      
      let key = '';
      switch (period) {
        case 'day':
          key = date.toISOString().split('T')[0]; // YYYY-MM-DD
          break;
        case 'week':
          // Get the Monday of the week
          const day = date.getDay() || 7; // Convert Sunday (0) to 7
          const mondayDate = new Date(date);
          mondayDate.setDate(date.getDate() - day + 1);
          key = mondayDate.toISOString().split('T')[0];
          break;
        case 'month':
          key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
          break;
        case 'year':
          key = `${date.getFullYear()}`;
          break;
      }
      
      if (!groups.has(key)) {
        groups.set(key, []);
      }
      groups.get(key)!.push(transaction);
    });
    
    return groups;
  }
}

================
File: utils/transactionProcessor.ts
================
// src/utils/transactionProcessor.ts
import { Transaction } from '@/types';
import { format, startOfMonth, endOfMonth, subMonths, startOfYear, endOfYear, subYears, startOfWeek, endOfWeek, eachDayOfInterval, isWithinInterval } from 'date-fns';

export type TimeframeTab =
  | 'thisMonth'
  | 'lastMonth'
  | 'thisYear'
  | 'lastYear'
  | 'thisWeek'
  | 'lastWeek'
  | 'allTime'
  | 'custom';

/**
 * Filters transactions based on the selected timeframe.
 * @param transactions An array of transactions to filter.
 * @param timeframe A string representing the timeframe to filter by.
 * @param useStatementMonth A boolean indicating whether to use the statement month for filtering.
 * @param statementCycleDay A number representing the day of the month when the statement cycle starts.
 * @returns An array of transactions filtered by the selected timeframe.
 */
export const filterTransactionsByTimeframe = (
  transactions: Transaction[],
  timeframe: TimeframeTab,
  useStatementMonth: boolean,
  statementCycleDay: number
): Transaction[] => {
  if (!transactions || transactions.length === 0) {
    return [];
  }

  let startDate: Date;
  let endDate: Date;

  if (timeframe === 'allTime') {
    return transactions;
  }

  if (useStatementMonth) {
    const today = new Date();
    const currentYear = today.getFullYear();
    const currentMonth = today.getMonth();

    // Determine the start and end dates based on the statement cycle day
    if (today.getDate() >= statementCycleDay) {
      // We are in the current statement cycle
      startDate = new Date(currentYear, currentMonth, statementCycleDay);
      endDate = new Date(currentYear, currentMonth + 1, statementCycleDay - 1);
    } else {
      // We are in the previous statement cycle
      startDate = new Date(currentYear, currentMonth - 1, statementCycleDay);
      endDate = new Date(currentYear, currentMonth, statementCycleDay - 1);
    }

    // Adjust dates based on the selected timeframe
    switch (timeframe) {
      case 'thisMonth':
        break; // Use the calculated startDate and endDate for the current statement cycle
      case 'lastMonth':
        startDate = subMonths(startDate, 1);
        endDate = subMonths(endDate, 1);
        break;
      case 'thisYear':
        startDate = startOfMonth(new Date(currentYear, currentMonth, statementCycleDay));
        endDate = endOfMonth(new Date(currentYear, currentMonth + 1, statementCycleDay - 1));
        break;
      case 'lastYear':
        startDate = startOfMonth(new Date(currentYear - 1, currentMonth, statementCycleDay));
        endDate = endOfMonth(new Date(currentYear, currentMonth, statementCycleDay - 1));
        break;
      default:
        break;
    }
  } else {
    // Use calendar month
    const today = new Date();
    const currentYear = today.getFullYear();
    const currentMonth = today.getMonth();
    const currentDay = today.getDate();

    switch (timeframe) {
      case 'thisMonth':
        startDate = startOfMonth(today);
        endDate = endOfMonth(today);
        break;
      case 'lastMonth':
        startDate = startOfMonth(subMonths(today, 1));
        endDate = endOfMonth(subMonths(today, 1));
        break;
      case 'thisYear':
        startDate = startOfYear(today);
        endDate = endOfYear(today);
        break;
      case 'lastYear':
        startDate = startOfYear(subYears(today, 1));
        endDate = endOfYear(subYears(today, 1));
        break;
      case 'thisWeek':
        startDate = startOfWeek(today, { weekStartsOn: 0 });
        endDate = endOfWeek(today, { weekStartsOn: 0 });
        break;
      case 'lastWeek':
        const lastWeekStart = subMonths(startOfWeek(today, { weekStartsOn: 0 }), 1);
        startDate = startOfWeek(lastWeekStart, { weekStartsOn: 0 });
        endDate = endOfWeek(lastWeekStart, { weekStartsOn: 0 });
        break;
      default:
        startDate = startOfMonth(today);
        endDate = endOfMonth(today);
        break;
    }
  }

  const filtered = transactions.filter((transaction) => {
    const transactionDate = new Date(transaction.date);
    return transactionDate >= startDate && transactionDate <= endDate;
  });

  return filtered;
};

/**
 * Calculates the number of days in the selected timeframe.
 * @param timeframe A string representing the timeframe.
 * @param useStatementMonth A boolean indicating whether to use the statement month.
 * @param statementCycleDay A number representing the day of the month when the statement cycle starts.
 * @returns The number of days in the selected timeframe.
 */
export const getDaysInPeriod = (
  timeframe: TimeframeTab,
  useStatementMonth: boolean,
  statementCycleDay: number
): number => {
  let startDate: Date;
  let endDate: Date;

  if (useStatementMonth) {
    const today = new Date();
    const currentYear = today.getFullYear();
    const currentMonth = today.getMonth();

    if (today.getDate() >= statementCycleDay) {
      startDate = new Date(currentYear, currentMonth, statementCycleDay);
      endDate = new Date(currentYear, currentMonth + 1, statementCycleDay - 1);
    } else {
      startDate = new Date(currentYear, currentMonth - 1, statementCycleDay);
      endDate = new Date(currentYear, currentMonth, statementCycleDay - 1);
    }

    switch (timeframe) {
      case 'thisMonth':
        break;
      case 'lastMonth':
        startDate = subMonths(startDate, 1);
        endDate = subMonths(endDate, 1);
        break;
      case 'thisYear':
        startDate = startOfMonth(new Date(currentYear, currentMonth, statementCycleDay));
        endDate = endOfMonth(new Date(currentYear, currentMonth + 1, statementCycleDay - 1));
        break;
      case 'lastYear':
        startDate = startOfMonth(new Date(currentYear - 1, currentMonth, statementCycleDay));
        endDate = endOfMonth(new Date(currentYear, currentMonth, statementCycleDay - 1));
        break;
      default:
        break;
    }
  } else {
    const today = new Date();

    switch (timeframe) {
      case 'thisMonth':
        startDate = startOfMonth(today);
        endDate = endOfMonth(today);
        break;
      case 'lastMonth':
        startDate = startOfMonth(subMonths(today, 1));
        endDate = endOfMonth(subMonths(today, 1));
        break;
      case 'thisYear':
        startDate = startOfYear(today);
        endDate = endOfYear(today);
        break;
      case 'lastYear':
        startDate = startOfYear(subYears(today, 1));
        endDate = endOfYear(subYears(today, 1));
        break;
      case 'thisWeek':
        startDate = startOfWeek(today, { weekStartsOn: 0 });
        endDate = endOfWeek(today, { weekStartsOn: 0 });
        break;
      case 'lastWeek':
        const lastWeekStart = subMonths(startOfWeek(today, { weekStartsOn: 0 }), 1);
        startDate = startOfWeek(lastWeekStart, { weekStartsOn: 0 });
        endDate = endOfWeek(lastWeekStart, { weekStartsOn: 0 });
        break;
      default:
        startDate = startOfMonth(today);
        endDate = endOfMonth(today);
        break;
    }
  }

  const interval = { start: startDate, end: endDate };
  const days = eachDayOfInterval(interval);
  return days.length;
};

const getDateRangeValues = (dateObj: Date | { start: Date, end: Date }) => {
  // Check if the date is a Date object or a DateRange object
  if (dateObj instanceof Date) {
    // If it's a Date, use the same date for both start and end
    return { start: dateObj, end: dateObj };
  } else {
    // It's a DateRange object, so we can safely access start and end
    return { start: dateObj.start, end: dateObj.end };
  }
};

================
File: utils/unusualSpendingDetection.ts
================
// src/utils/unusualSpendingDetection.ts
import { Transaction } from '@/types';

export interface SpendingAnomaly {
  merchantName: string;
  reason: string;
  amount: number;
  severity: 'low' | 'medium' | 'high';
  date: string;
  transactionId: string;
}

interface MerchantStats {
  transactions: Transaction[];
  avgAmount: number;
  stdDevAmount: number;
  usualFrequency: number; // transactions per week
  lastPurchaseDate?: Date;
}

/**
 * Analyzes transaction history to detect unusual spending patterns
 * @param transactions Recent transactions to analyze
 * @param historicalTransactions Historical transactions for baseline comparison
 * @param lookbackDays Number of days to look back for unusual frequency
 * @param amountThreshold Standard deviation multiplier for amount anomaly detection
 * @returns Array of detected spending anomalies
 */
export function detectUnusualSpending(
  transactions: Transaction[],
  historicalTransactions: Transaction[],
  lookbackDays = 7,
  amountThreshold = 1.5
): SpendingAnomaly[] {
  // Group historical transactions by merchant to build baseline stats
  const merchantStats = buildMerchantStats(historicalTransactions);
  
  // Define the lookback period
  const lookbackDate = new Date();
  lookbackDate.setDate(lookbackDate.getDate() - lookbackDays);
  
  // Sort transactions by date (newest first)
  const sortedTransactions = [...transactions].sort(
    (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()
  );
  
  const anomalies: SpendingAnomaly[] = [];
  const merchantFrequencyMap = new Map<string, number>();
  
  // Process each transaction to detect anomalies
  for (const transaction of sortedTransactions) {
    const merchantName = transaction.merchant.name;
    const txDate = new Date(transaction.date);
    
    // Skip transactions outside lookback period
    if (txDate < lookbackDate) continue;
    
    // Track frequency of merchant within lookback period
    const currentCount = merchantFrequencyMap.get(merchantName) || 0;
    merchantFrequencyMap.set(merchantName, currentCount + 1);
    
    // Check if we have baseline stats for this merchant
    const stats = merchantStats.get(merchantName);
    if (!stats || stats.transactions.length < 3) continue; // Need enough history
    
    // 1. Check for amount anomaly
    if (transaction.amount > stats.avgAmount + (stats.stdDevAmount * amountThreshold)) {
      const multiplier = Math.round((transaction.amount / stats.avgAmount) * 10) / 10;
      
      anomalies.push({
        merchantName,
        reason: `Amount ${multiplier}x higher than usual`,
        amount: transaction.amount,
        severity: getSeverity(multiplier),
        date: transaction.date,
        transactionId: transaction.id
      });
    }
    
    // 2. Check for frequency anomaly (after processing all transactions in lookback)
    if (currentCount >= 3) { // At least 3 purchases to be considered unusual frequency
      const usualWeeklyFrequency = stats.usualFrequency;
      const currentWeeklyFrequency = currentCount / (lookbackDays / 7);
      
      if (currentWeeklyFrequency > usualWeeklyFrequency * 2) {
        // Only add if we haven't already flagged this merchant for frequency
        const existingFrequencyAnomaly = anomalies.find(
          a => a.merchantName === merchantName && a.reason.includes('purchase')
        );
        
        if (!existingFrequencyAnomaly) {
          anomalies.push({
            merchantName,
            reason: `${currentCount}${getOrdinalSuffix(currentCount)} purchase this week`,
            amount: transaction.amount,
            severity: 'medium',
            date: transaction.date,
            transactionId: transaction.id
          });
        }
      }
    }
  }
  
  return anomalies;
}

/**
 * Build statistical baseline for each merchant from historical transactions
 */
function buildMerchantStats(
  transactions: Transaction[]
): Map<string, MerchantStats> {
  const merchantMap = new Map<string, Transaction[]>();
  
  // Group transactions by merchant
  for (const tx of transactions) {
    const merchantName = tx.merchant.name;
    if (!merchantMap.has(merchantName)) {
      merchantMap.set(merchantName, []);
    }
    merchantMap.get(merchantName)?.push(tx);
  }
  
  // Calculate statistics for each merchant
  const statsMap = new Map<string, MerchantStats>();
  
  for (const [merchantName, txs] of merchantMap.entries()) {
    // Need at least 2 transactions to establish a pattern
    if (txs.length < 2) continue;
    
    // Sort by date (oldest first) for time-based analysis
    const sortedTxs = [...txs].sort(
      (a, b) => new Date(a.date).getTime() - new Date(b.date).getTime()
    );
    
    // Calculate average amount
    const amounts = sortedTxs.map(tx => tx.amount);
    const avgAmount = amounts.reduce((sum, val) => sum + val, 0) / amounts.length;
    
    // Calculate standard deviation
    const squareDiffs = amounts.map(val => Math.pow(val - avgAmount, 2));
    const avgSquareDiff = squareDiffs.reduce((sum, val) => sum + val, 0) / squareDiffs.length;
    const stdDevAmount = Math.sqrt(avgSquareDiff);
    
    // Calculate usual frequency (transactions per week)
    const firstDate = new Date(sortedTxs[0].date);
    const lastDate = new Date(sortedTxs[sortedTxs.length - 1].date);
    const weeksBetween = (lastDate.getTime() - firstDate.getTime()) / (7 * 24 * 60 * 60 * 1000);
    // Avoid division by zero or very small values
    const usualFrequency = weeksBetween < 0.5 ? txs.length : txs.length / Math.max(1, weeksBetween);
    
    statsMap.set(merchantName, {
      transactions: sortedTxs,
      avgAmount,
      stdDevAmount,
      usualFrequency,
      lastPurchaseDate: lastDate
    });
  }
  
  return statsMap;
}

/**
 * Determine severity level based on the multiplier
 */
function getSeverity(multiplier: number): 'low' | 'medium' | 'high' {
  if (multiplier >= 3) return 'high';
  if (multiplier >= 2) return 'medium';
  return 'low';
}

/**
 * Get ordinal suffix for a number (1st, 2nd, 3rd, etc.)
 */
function getOrdinalSuffix(num: number): string {
  const j = num % 10;
  const k = num % 100;
  
  if (j === 1 && k !== 11) return 'st';
  if (j === 2 && k !== 12) return 'nd';
  if (j === 3 && k !== 13) return 'rd';
  return 'th';
}

/**
 * Hook for unusual spending detection
 */
export function useUnusualSpending(
  transactions: Transaction[]
): {
  anomalies: SpendingAnomaly[];
  alertCount: number;
} {
  // Get all transactions for analysis
  const recentTransactions = transactions.filter(
    tx => new Date(tx.date) >= new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
  );
  
  // Get historical transactions for baseline (excluding most recent)
  const historicalTransactions = transactions.filter(
    tx => new Date(tx.date) < new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
  );
  
  // Detect anomalies
  const anomalies = detectUnusualSpending(
    recentTransactions,
    historicalTransactions
  );
  
  // Sort anomalies by severity and date
  const sortedAnomalies = [...anomalies].sort((a, b) => {
    const severityOrder = { high: 0, medium: 1, low: 2 };
    if (severityOrder[a.severity] !== severityOrder[b.severity]) {
      return severityOrder[a.severity] - severityOrder[b.severity];
    }
    return new Date(b.date).getTime() - new Date(a.date).getTime();
  });
  
  return {
    anomalies: sortedAnomalies,
    alertCount: sortedAnomalies.length
  };
}



================================================================
End of Codebase
================================================================
