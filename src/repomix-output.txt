This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: services/, hooks/expense-form/, components/rewards/, components/expense/, components/payment-method/, pages/AddExpense.tsx, pages/PaymentMethods.tsx
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
components/
  expense/
    cards/
      UOBLadysSolitaireCard.tsx
    dialog/
      TransactionDetailsView.tsx
      TransactionDialogActions.tsx
      TransactionDialogHeader.tsx
      TransactionEditForm.tsx
    merchant/
      MerchantAddressSelect.tsx
      MerchantCategorySelect.tsx
      OnlineMerchantToggle.tsx
    ContactlessToggle.tsx
    ConvertedAmountField.tsx
    ErrorAlert.tsx
    ExpenseForm.tsx
    MerchantDetailsForm.tsx
    PaymentCardDisplay.tsx
    PaymentCardRender.tsx
    PaymentDetailsForm.tsx
    PointsCurrencyAggregator.tsx
    PointsDisplay.tsx
    StorageModeAlert.tsx
    TransactionCard.tsx
    TransactionDetailsForm.tsx
    TransactionDialog.tsx
    TransactionTable.tsx
  payment-method/
    CategorySelector.tsx
    EmptyPaymentMethodsCard.tsx
    EmptyPaymentMethodState.tsx
    ImageUploadDialog.tsx
    PaymentCardFace.tsx
    PaymentCarousel.tsx
    PaymentFunctionsList.tsx
    PaymentMethodCard.tsx
    PaymentMethodForm.tsx
    RewardRuleBadge.tsx
    RewardRuleEditDialog.tsx
  rewards/
    BonusTierEditor.tsx
    ConditionEditor.tsx
    RewardRuleEditor.tsx
    RewardRuleManager.tsx
hooks/
  expense-form/
    formSchema.ts
    useMerchantData.ts
    usePaymentMethodLogic.ts
    useRewardPoints.ts
    useRewardPointsStandalone.ts
pages/
  AddExpense.tsx
  PaymentMethods.tsx
services/
  rewards/
    CardRegistry.ts
    MonthlySpendingTracker.ts
    rewardCalculationAdapter.ts
    RewardCalculatorService.ts
    RuleEngine.ts
    RuleRepository.ts
    types.ts
  BonusPointsTrackingService.ts
  CurrencyService.ts

================================================================
Files
================================================================

================
File: components/expense/cards/UOBLadysSolitaireCard.tsx
================
import React from 'react';
import { BaseRewardCard, BaseRewardCardProps, MonthlyCap, RewardRule, RewardRuleFactory } from './BaseRewardCard';

/**
 * Extended props interface for UOBLadysSolitaireCard
 */
export interface UOBLadysSolitaireCardProps extends BaseRewardCardProps {
  usedBonusPoints: number;
  monthTotalEligibleSpend?: number; // Track monthly spend for eligible categories
  selectedCategories: string[]; // The two selected categories
}

/**
 * UOB Lady's Solitaire World MasterCard Implementation
 * 
 * Card features:
 * - Issuer: UOB
 * - Currency: SGD
 * - Card Network: MasterCard
 * - Card Type: World MasterCard
 * - Card Name: Lady's Solitaire
 * - Base points: floor round to nearest $5, then multiply by 0.4
 * - Bonus points: sum all eligible transactions in a calendar month, 
 *   floor round the total to nearest $5, then multiply by 3.6
 * - Eligible transactions determined by MCCs in selected categories (2 categories at any time)
 * - Both selected categories share the same 7200 points monthly cap on bonus points
 */
export class UOBLadysSolitaireCard extends BaseRewardCard<UOBLadysSolitaireCardProps> {
  // Define MCC categories
  private readonly categoryMCCs: Record<string, string[]> = {
    'Beauty & Wellness': ['5912', '5977', '7230', '7231', '7298', '7297', '5912', '5977', '7230', '7231', '7298', '7297'],
    // Expanded Dining MCCs to include more restaurant/food-related codes
    'Dining': ['5811', '5812', '5813', '5814', '5499', '5441', '5462', '5310', '5411', '5310', 
               '0811', '0812', '0813', '0814', '811', '812', '813', '814'], // Different formats
    'Entertainment': ['5813', '7832', '7922'],
    'Family': ['5411', '5641'],
    'Fashion': ['5311', '5611', '5621', '5631', '5651', '5655', '5661', '5691', '5699', '5948'],
    'Transport': ['4111', '4121', '4789', '5541', '5542'],
    'Travel': ['3000', '3001', '3002', '3003', '3004', '3005', '3006', '3007', '3008', '3009', 
               '3010', '3011', '3012', '3013', '3014', '3015', '3016', '3017', '3018', '3019',
               '3020', '3021', '3022', '3023', '3024', '3025', '3026', '3027', '3028', '3029',
               '3030', '3031', '3032', '3033', '3034', '3035', '3036', '3037', '3038', '3039',
               '3040', '3041', '3042', '3043', '3044', '3045', '3046', '3047', '3048', '3049',
               '3050', '3051', '3052', '3053', '3054', '3055', '3056', '3057', '3058', '3059',
               '3060', '3061', '3062', '3063', '3064', '3065', '3066', '3067', '3068', '3069',
               '3070', '3071', '3072', '3073', '3074', '3075', '3076', '3077', '3078', '3079',
               '3080', '3081', '3082', '3083', '3084', '3085', '3086', '3087', '3088', '3089',
               '3090', '3091', '3092', '3093', '3094', '3095', '3096', '3097', '3098', '3099',
               '3100', '3101', '3102', '3103', '3104', '3105', '3106', '3107', '3108', '3109',
               '3110', '3111', '3112', '3113', '3114', '3115', '3116', '3117', '3118', '3119',
               '3120', '3121', '3122', '3123', '3124', '3125', '3126', '3127', '3128', '3129',
               '3130', '3131', '3132', '3133', '3134', '3135', '3136', '3137', '3138', '3139',
               '3140', '3141', '3142', '3143', '3144', '3145', '3146', '3147', '3148', '3149',
               '3150', '3151', '3152', '3153', '3154', '3155', '3156', '3157', '3158', '3159',
               '3160', '3161', '3162', '3163', '3164', '3165', '3166', '3167', '3168', '3169',
               '3170', '3171', '3172', '3173', '3174', '3175', '3176', '3177', '3178', '3179',
               '3180', '3181', '3182', '3183', '3184', '3185', '3186', '3187', '3188', '3189',
               '3190', '3191', '3192', '3193', '3194', '3195', '3196', '3197', '3198', '3199',
               '3200', '3201', '3202', '3203', '3204', '3205', '3206', '3207', '3208', '3209',
               '3210', '3211', '3212', '3213', '3214', '3215', '3216', '3217', '3218', '3219',
               '3220', '3221', '3222', '3223', '3224', '3225', '3226', '3227', '3228', '3229',
               '3230', '3231', '3232', '3233', '3234', '3235', '3236', '3237', '3238', '3239',
               '3240', '3241', '3242', '3243', '3244', '3245', '3246', '3247', '3248', '3249',
               '3250', '3251', '3252', '3253', '3254', '3255', '3256', '3257', '3258', '3259',
               '3260', '3261', '3262', '3263', '3264', '3265', '3266', '3267', '3268', '3269',
               '3270', '3271', '3272', '3273', '3274', '3275', '3276', '3277', '3278', '3279',
               '3280', '3281', '3282', '3283', '3284', '3285', '3286', '3287', '3288', '3289',
               '3290', '3291', '3292', '3293', '3294', '3295', '3296', '3297', '3298', '3299',
               '7011', '7512']
  };

  /**
   * Floor round to nearest $5
   */
  calculateRoundedAmount(amount: number): number {
    return Math.floor(amount / 5) * 5;
  }

  /**
   * Base point calculation: 0.4 points per dollar
   */
  calculateBasePoints(roundedAmount: number): number {
    return Math.round(roundedAmount * 0.2);
  }

  /**
   * Normalize MCC codes by removing leading zeros and whitespace
   */
  private normalizeMCC(mcc: string): string {
    if (!mcc) return '';
    // Remove leading zeros and trim whitespace
    return mcc.replace(/^0+/, '').trim();
  }

  /**
   * Determines if a transaction is eligible for bonus points
   * based on its MCC code falling within the selected categories
   */
  getBonusPointsEligibility(props: UOBLadysSolitaireCardProps): boolean {
    if (!props.mcc) {
      console.log('UOB Lady\'s Card: No MCC code provided for transaction');
      return false;
    }
    
    if (!props.selectedCategories || props.selectedCategories.length === 0) {
      console.log('UOB Lady\'s Card: No categories selected');
      return false;
    }
    
    // Normalize the transaction MCC
    const normalizedMCC = this.normalizeMCC(props.mcc);
    console.log(`UOB Lady's Card: Checking MCC ${props.mcc} (normalized: ${normalizedMCC})`);
    console.log(`UOB Lady's Card: Selected categories: ${props.selectedCategories.join(', ')}`);
    
    // Check if transaction MCC falls into any selected category
    for (const category of props.selectedCategories) {
      console.log(`UOB Lady's Card: Checking category: ${category}`);
      const categoryMCCs = this.categoryMCCs[category] || [];
      
      // Check both normalized and original MCCs
      for (const categoryMCC of categoryMCCs) {
        const normalizedCategoryMCC = this.normalizeMCC(categoryMCC);
        
        if (normalizedCategoryMCC === normalizedMCC || categoryMCC === props.mcc) {
          console.log(`UOB Lady's Card: Match found! MCC ${props.mcc} is in category ${category}`);
          return true;
        }
      }
    }
    
    console.log(`UOB Lady's Card: No matches found for MCC ${props.mcc} in selected categories`);
    return false;
  }

  /**
   * Bonus point calculation: 3.6 additional points per dollar
   * Note: In a real implementation, this would be based on monthly aggregated spend
   */
  calculateBonusPoints(roundedAmount: number): number {
    return Math.round(roundedAmount * 1.8);
  }

  /**
   * UOB Lady's Solitaire has a 3600 points monthly cap on bonus points
   * that is shared across both selected categories (not per category)
   */
  getBonusPointsCap(): MonthlyCap {
    return new MonthlyCap(3600);
  }
  
  /**
   * Override the standard calculation to implement monthly aggregation
   */
  calculateRewards(): any {
    const props = this.props;
    const { amount, mcc, monthTotalEligibleSpend = 0, usedBonusPoints = 0 } = props;
    
    // Calculate base points as normal
    const roundedAmount = this.calculateRoundedAmount(amount);
    const basePoints = this.calculateBasePoints(roundedAmount);
    
    // Log current state for debugging
    console.log('UOB Lady\'s Card calculateRewards:');
    console.log('- Amount:', amount);
    console.log('- MCC:', mcc);
    console.log('- Selected Categories:', props.selectedCategories);
    console.log('- Rounded Amount:', roundedAmount);
    console.log('- Base Points:', basePoints);
    
    // Determine bonus eligibility
    const isEligible = this.getBonusPointsEligibility(props);
    console.log('- Is Eligible for Bonus:', isEligible);
    
    let bonusPointMessage = "";
    
    // For demonstration, we're showing a simplified calculation
    // In a real app, we'd track all eligible transactions across the month
    const updatedMonthlySpend = isEligible ? monthTotalEligibleSpend + amount : monthTotalEligibleSpend;
    const monthlyRoundedSpend = Math.floor(updatedMonthlySpend / 5) * 5;
    
    // Calculate potential bonus (for this transaction only, for demonstration)
    // In a real app, this would be based on the monthly total
    const potentialBonusPoints = isEligible ? Math.round(roundedAmount * 1.8) : 0;
    console.log('- Potential Bonus Points:', potentialBonusPoints);
    
    // Apply monthly cap
    const bonusPointsCap = this.getBonusPointsCap();
    const actualBonusPoints = bonusPointsCap.applyCap(potentialBonusPoints, usedBonusPoints);
    console.log('- Actual Bonus Points (after cap):', actualBonusPoints);
    
    const remainingBonusPoints = bonusPointsCap.getRemainingBonusPoints(
      usedBonusPoints,
      actualBonusPoints
    );
    console.log('- Remaining Monthly Bonus Points:', remainingBonusPoints);

    // Generate appropriate message
    if (!isEligible) {
      bonusPointMessage = " (Transaction not in selected categories)";
    } else if (potentialBonusPoints > 0 && actualBonusPoints === 0) {
      bonusPointMessage = " (Monthly cap reached)";
    } else if (isEligible) {
      bonusPointMessage = ` (Transaction eligible in ${props.selectedCategories.join(', ')} categories)`;
    }

    return {
      basePoints,
      bonusPoints: actualBonusPoints,
      totalPoints: basePoints + actualBonusPoints,
      remainingBonusPoints,
      bonusPointMessage
    };
  }
}

/**
 * Functional wrapper component for usage
 */
export const UOBLadysSolitaireCardWrapper: React.FC<UOBLadysSolitaireCardProps> = (props) => {
  return <UOBLadysSolitaireCard {...props} />;
};

================
File: components/expense/dialog/TransactionDetailsView.tsx
================
import { Transaction } from "@/types";
import { CurrencyService } from "@/services/CurrencyService";

import { CreditCardIcon, CoinsIcon } from "lucide-react";

interface TransactionDetailsViewProps {
  transaction: Transaction;
}

const TransactionDetailsView = ({
  transaction,
}: TransactionDetailsViewProps) => {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 py-4">
      <div className="space-y-4">
        <div>
          <h3 className="text-sm font-medium text-muted-foreground mb-1">
            Amount
          </h3>
          <p className="text-2xl font-semibold">
            {CurrencyService.format(transaction.amount, transaction.currency)}
          </p>
          {transaction.currency !== transaction.paymentCurrency && (
            <p className="text-sm text-muted-foreground">
              Paid as{" "}
              {CurrencyService.format(
                transaction.paymentAmount,
                transaction.paymentCurrency
              )}
            </p>
          )}
        </div>

        <div>
          <h3 className="text-sm font-medium text-muted-foreground mb-1">
            Payment Method
          </h3>
          <div className="flex items-center gap-2">
            <CreditCardIcon className="h-4 w-4" />
            <div>
              <p className="font-medium">{transaction.paymentMethod.name}</p>
              <p className="text-sm text-muted-foreground">
                {transaction.paymentMethod.issuer}
              </p>
            </div>
          </div>
        </div>

        {transaction.rewardPoints > 0 && (
          <div>
            <h3 className="text-sm font-medium text-muted-foreground mb-1">
              Reward Points
            </h3>
            <div className="flex items-center gap-2">
              <CoinsIcon className="h-4 w-4 text-amber-500" />
              <p className="font-medium">
                {transaction.rewardPoints.toLocaleString()} points
              </p>
            </div>
          </div>
        )}
      </div>

      <div className="space-y-4">
        {transaction.merchant.address && (
          <div>
            <h3 className="text-sm font-medium text-muted-foreground mb-1">
              Merchant Address
            </h3>
            <p>{transaction.merchant.address}</p>
          </div>
        )}

        {transaction.notes && (
          <div>
            <h3 className="text-sm font-medium text-muted-foreground mb-1">
              Notes
            </h3>
            <p>{transaction.notes}</p>
          </div>
        )}

        <div>
          <h3 className="text-sm font-medium text-muted-foreground mb-1">
            Transaction ID
          </h3>
          <p className="text-xs font-mono">{transaction.id}</p>
        </div>
      </div>
    </div>
  );
};

export default TransactionDetailsView;

================
File: components/expense/dialog/TransactionDialogActions.tsx
================
import { Transaction } from '@/types';
import { DialogFooter } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { EditIcon, TrashIcon } from 'lucide-react';

interface TransactionDialogActionsProps {
  transaction: Transaction;
  onDelete: (transaction: Transaction) => void;
  onEdit: () => void;
}

const TransactionDialogActions = ({
  transaction,
  onDelete,
  onEdit,
}: TransactionDialogActionsProps) => {
  return (
    <DialogFooter className="gap-2 sm:gap-0">
      <Button
        variant="destructive"
        className="gap-1"
        onClick={() => onDelete(transaction)}
      >
        <TrashIcon className="h-4 w-4" />
        Delete
      </Button>
      <Button
        className="gap-1"
        onClick={onEdit}
      >
        <EditIcon className="h-4 w-4" />
        Edit
      </Button>
    </DialogFooter>
  );
};

export default TransactionDialogActions;

================
File: components/expense/dialog/TransactionDialogHeader.tsx
================
import { Transaction } from '@/types';
import { formatDate } from '@/utils/dateUtils';
import {
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from '@/components/ui/dialog';
import { Badge } from '@/components/ui/badge';
import { CalendarIcon, MapPinIcon } from 'lucide-react';

interface TransactionDialogHeaderProps {
  transaction: Transaction;
}

const TransactionDialogHeader = ({ transaction }: TransactionDialogHeaderProps) => {
  return (
    <DialogHeader>
      <DialogTitle className="text-xl flex items-center gap-2">
        <span>{transaction.merchant.name}</span>
        {transaction.merchant.isOnline && (
          <Badge variant="outline" className="ml-2">Online</Badge>
        )}
        {transaction.isContactless && !transaction.merchant.isOnline && (
          <Badge variant="outline" className="ml-2">Contactless</Badge>
        )}
      </DialogTitle>
      <DialogDescription className="flex flex-col sm:flex-row gap-2 sm:gap-4 text-sm mt-2">
        <div className="flex items-center gap-1">
          <CalendarIcon className="h-3.5 w-3.5" />
          <span>{formatDate(transaction.date)}</span>
        </div>
        {transaction.merchant.mcc && (
          <div className="flex items-center gap-1">
            <MapPinIcon className="h-3.5 w-3.5" />
            <span>{transaction.merchant.mcc.description}</span>
          </div>
        )}
      </DialogDescription>
    </DialogHeader>
  );
};

export default TransactionDialogHeader;

================
File: components/expense/dialog/TransactionEditForm.tsx
================
import { Transaction, PaymentMethod } from '@/types';
import {
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import ExpenseForm from '../ExpenseForm';

interface TransactionEditFormProps {
  transaction: Transaction;
  paymentMethods: PaymentMethod[];
  onSubmit: (transaction: Omit<Transaction, 'id'>) => void;
  onCancel: () => void;
}

const TransactionEditForm = ({
  transaction,
  paymentMethods,
  onSubmit,
  onCancel,
}: TransactionEditFormProps) => {
  // Log transaction to debug
  console.log('Editing transaction with data:', transaction);
  console.log('Reimbursement amount:', transaction.reimbursementAmount);
  
  return (
    <>
      <DialogHeader>
        <DialogTitle>Edit Transaction</DialogTitle>
        <DialogDescription>
          Make changes to your transaction details.
        </DialogDescription>
      </DialogHeader>
      
      <ExpenseForm
        paymentMethods={paymentMethods}
        onSubmit={onSubmit}
        defaultValues={{
          merchantName: transaction.merchant.name,
          merchantAddress: transaction.merchant.address,
          isOnline: transaction.merchant.isOnline,
          isContactless: !!transaction.isContactless,
          amount: transaction.amount.toString(),
          currency: transaction.currency,
          paymentMethodId: transaction.paymentMethod.id,
          paymentAmount: transaction.paymentAmount.toString(),
          reimbursementAmount: transaction.reimbursementAmount ? transaction.reimbursementAmount.toString() : '0',
          date: new Date(transaction.date),
          notes: transaction.notes,
          mcc: transaction.merchant.mcc,
        }}
      />
      
      <DialogFooter className="gap-2 sm:gap-0 mt-4">
        <Button variant="outline" onClick={onCancel}>
          Cancel
        </Button>
      </DialogFooter>
    </>
  );
};

export default TransactionEditForm;

================
File: components/expense/merchant/MerchantAddressSelect.tsx
================
import { useState } from 'react';
import { useFormContext } from 'react-hook-form';
import { MapPinIcon, LucideLoader } from 'lucide-react';
import { Input } from '@/components/ui/input';
import { FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { useToast } from '@/hooks/use-toast';
import {
  CommandDialog,
  CommandGroup as CommandDialogGroup,
  CommandEmpty as CommandDialogEmpty,
  CommandInput as CommandDialogInput,
  CommandItem as CommandDialogItem,
  CommandList as CommandDialogList,
} from '@/components/ui/command';

interface Place {
  name: string;
  address: string;
  location?: {
    lat: number;
    lng: number;
  };
}

interface MerchantAddressSelectProps {
  places: Place[];
  isLoading: boolean;
  showDialog: boolean;
  setShowDialog: (show: boolean) => void;
}

const MerchantAddressSelect = ({ 
  places, 
  isLoading, 
  showDialog, 
  setShowDialog 
}: MerchantAddressSelectProps) => {
  const form = useFormContext();
  const { toast } = useToast();

  const handleSelectPlace = (place: Place) => {
    form.setValue('merchantAddress', place.address, { shouldValidate: true });
    setShowDialog(false);
    
    toast({
      title: "Address selected",
      description: `Selected address: ${place.address}`,
    });
  };

  return (
    <>
      <FormField
        control={form.control}
        name="merchantAddress"
        render={({ field }) => (
          <FormItem>
            <FormLabel>Merchant Address</FormLabel>
            <FormControl>
              <div className="relative">
                <Input 
                  placeholder="Enter merchant address" 
                  {...field}
                  onClick={() => {
                    if (places.length > 0) {
                      setShowDialog(true);
                    }
                  }}
                />
                {isLoading ? (
                  <div className="absolute right-3 top-1/2 transform -translate-y-1/2 animate-spin">
                    <LucideLoader className="h-4 w-4 text-gray-400" />
                  </div>
                ) : (
                  <MapPinIcon 
                    className="absolute right-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400 cursor-pointer" 
                    onClick={() => {
                      if (places.length > 0) {
                        setShowDialog(true);
                      }
                    }}
                  />
                )}
              </div>
            </FormControl>
            <FormMessage />
          </FormItem>
        )}
      />

      {/* Places Selection Dialog */}
      <CommandDialog open={showDialog} onOpenChange={setShowDialog}>
        <CommandDialogInput placeholder="Search places..." />
        <CommandDialogList>
          <CommandDialogEmpty>No places found.</CommandDialogEmpty>
          <CommandDialogGroup heading="Suggested Places">
            {places.map((place, index) => (
              <CommandDialogItem
                key={index}
                onSelect={() => handleSelectPlace(place)}
                className="cursor-pointer"
              >
                <div className="flex flex-col">
                  <span className="font-medium">{place.name}</span>
                  <span className="text-sm text-muted-foreground">{place.address}</span>
                </div>
              </CommandDialogItem>
            ))}
          </CommandDialogGroup>
        </CommandDialogList>
      </CommandDialog>
    </>
  );
};

export default MerchantAddressSelect;

================
File: components/expense/merchant/MerchantCategorySelect.tsx
================
import { useState, useEffect } from 'react';
import { useFormContext } from 'react-hook-form';
import { MerchantCategoryCode } from '@/types';
import { MCC_CODES } from '@/utils/constants/mcc';
import { Label } from '@/components/ui/label';
import { TagIcon, SearchIcon } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { Button } from '@/components/ui/button';
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from '@/components/ui/command';
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from '@/components/ui/popover';

interface MerchantCategorySelectProps {
  selectedMCC?: MerchantCategoryCode;
  onSelectMCC: (mcc: MerchantCategoryCode) => void;
}

const MerchantCategorySelect = ({ selectedMCC, onSelectMCC }: MerchantCategorySelectProps) => {
  const [showMCCDialog, setShowMCCDialog] = useState(false);
  const [mccSearchQuery, setMccSearchQuery] = useState('');
  const [filteredMCC, setFilteredMCC] = useState<MerchantCategoryCode[]>([]);
  const { toast } = useToast();
  
  // Sort MCC_CODES in ascending order by code and set as initial state
  useEffect(() => {
    const sortedMccCodes = [...MCC_CODES].sort((a, b) => {
      return a.code.localeCompare(b.code);
    });
    setFilteredMCC(sortedMccCodes);
  }, []);
  
  // Filter MCC codes based on search query
  useEffect(() => {
    const sortedMccCodes = [...MCC_CODES].sort((a, b) => a.code.localeCompare(b.code));
    
    if (mccSearchQuery.trim() === '') {
      setFilteredMCC(sortedMccCodes);
    } else {
      const query = mccSearchQuery.toLowerCase();
      const filtered = sortedMccCodes.filter(
        mcc => 
          mcc.description.toLowerCase().includes(query) || 
          mcc.code.includes(query)
      );
      setFilteredMCC(filtered);
    }
  }, [mccSearchQuery]);

  const handleSelectMCC = (mcc: MerchantCategoryCode) => {
    onSelectMCC(mcc);
    setShowMCCDialog(false);

    toast({
      title: "Category selected",
      description: `Selected category: ${mcc.description} (${mcc.code})`,
    });
  };

  return (
    <div>
      <Label>Merchant Category</Label>
      <Popover open={showMCCDialog} onOpenChange={setShowMCCDialog}>
        <PopoverTrigger asChild>
          <Button 
            variant="outline" 
            role="combobox" 
            aria-expanded={showMCCDialog}
            className="w-full justify-between mt-1"
          >
            {selectedMCC ? `${selectedMCC.description} (${selectedMCC.code})` : "Select merchant category"}
            <SearchIcon className="ml-2 h-4 w-4 shrink-0 opacity-50" />
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-[300px] p-0">
          <Command>
            <CommandInput 
              placeholder="Search categories..." 
              value={mccSearchQuery}
              onValueChange={setMccSearchQuery}
            />
            <CommandList>
              <CommandEmpty>No categories found.</CommandEmpty>
              <CommandGroup>
                {filteredMCC.map((mcc) => (
                  <CommandItem
                    key={mcc.code}
                    onSelect={() => handleSelectMCC(mcc)}
                    className="cursor-pointer"
                  >
                    <span className="text-xs font-mono text-muted-foreground mr-2">{mcc.code}</span>
                    <span>{mcc.description}</span>
                  </CommandItem>
                ))}
              </CommandGroup>
            </CommandList>
          </Command>
        </PopoverContent>
      </Popover>
      <p className="text-sm text-muted-foreground mt-1">
        {selectedMCC ? (
          <span className="flex items-center">
            <TagIcon className="h-3.5 w-3.5 mr-1.5" />
            {selectedMCC.description} ({selectedMCC.code})
          </span>
        ) : (
          "Optional - Search and select a merchant category code"
        )}
      </p>
    </div>
  );
};

export default MerchantCategorySelect;

================
File: components/expense/merchant/OnlineMerchantToggle.tsx
================
import { useFormContext } from 'react-hook-form';
import { Switch } from '@/components/ui/switch';
import { FormControl, FormDescription, FormField, FormItem, FormLabel } from '@/components/ui/form';

const OnlineMerchantToggle = () => {
  const form = useFormContext();

  return (
    <div className="flex items-center space-x-2">
      <FormField
        control={form.control}
        name="isOnline"
        render={({ field }) => (
          <FormItem className="flex flex-row items-center justify-between rounded-lg border p-3 shadow-sm">
            <div className="space-y-0.5">
              <FormLabel>Online Merchant</FormLabel>
              <FormDescription>
                Toggle if this is an online merchant
              </FormDescription>
            </div>
            <FormControl>
              <Switch
                checked={field.value}
                onCheckedChange={field.onChange}
              />
            </FormControl>
          </FormItem>
        )}
      />
    </div>
  );
};

export default OnlineMerchantToggle;

================
File: components/expense/ContactlessToggle.tsx
================
import React from 'react';
import { useFormContext } from 'react-hook-form';
import { WifiIcon } from 'lucide-react';
import { Switch } from '@/components/ui/switch';
import {
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
} from '@/components/ui/form';

interface ContactlessToggleProps {
  isOnline: boolean;
  isCash: boolean;
}

const ContactlessToggle: React.FC<ContactlessToggleProps> = ({ isOnline, isCash }) => {
  const form = useFormContext();

  // Only show for credit card payments that are not online
  if (isOnline || isCash) {
    return null;
  }

  return (
    <FormField
      control={form.control}
      name="isContactless"
      render={({ field }) => (
        <FormItem className="flex flex-row items-center justify-between rounded-lg border p-3 shadow-sm">
          <div className="space-y-0.5">
            <FormLabel>Contactless Payment</FormLabel>
            <FormDescription>
              Toggle if the payment was made contactless
            </FormDescription>
          </div>
          <FormControl>
            <div className="flex items-center space-x-2">
              <WifiIcon className="h-4 w-4 text-muted-foreground" />
              <Switch
                checked={field.value}
                onCheckedChange={field.onChange}
              />
            </div>
          </FormControl>
        </FormItem>
      )}
    />
  );
};

export default ContactlessToggle;

================
File: components/expense/ConvertedAmountField.tsx
================
import React from 'react';
import { useFormContext } from 'react-hook-form';
import { Input } from '@/components/ui/input';
import { PaymentMethod } from '@/types';
import { FormControl, FormField, FormItem, FormLabel, FormDescription, FormMessage } from '@/components/ui/form';

interface ConvertedAmountFieldProps {
  shouldOverridePayment: boolean;
  selectedPaymentMethod: PaymentMethod | undefined;
}

const ConvertedAmountField: React.FC<ConvertedAmountFieldProps> = ({ 
  shouldOverridePayment, 
  selectedPaymentMethod 
}) => {
  const form = useFormContext();
  
  if (!shouldOverridePayment || !selectedPaymentMethod) {
    return null;
  }
  
  return (
    <FormField
      control={form.control}
      name="paymentAmount"
      render={({ field }) => (
        <FormItem>
          <FormLabel>Converted Amount ({selectedPaymentMethod?.currency})</FormLabel>
          <FormDescription>
            Currency differs from transaction currency. Enter the actual payment amount.
          </FormDescription>
          <FormControl>
            <Input
              type="number"
              min="0.01"
              step="0.01"
              placeholder="0.00"
              {...field}
            />
          </FormControl>
          <FormMessage />
        </FormItem>
      )}
    />
  );
};

export default ConvertedAmountField;

================
File: components/expense/ErrorAlert.tsx
================
import React from 'react';
import { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';
import { AlertTriangle } from 'lucide-react';

interface ErrorAlertProps {
  error: string | null;
}

const ErrorAlert: React.FC<ErrorAlertProps> = ({ error }) => {
  if (!error) return null;

  return (
    <Alert className="mb-4 bg-red-50 text-red-700 border-red-200">
      <AlertTriangle className="h-5 w-5" />
      <AlertTitle>Error saving transaction</AlertTitle>
      <AlertDescription>{error}</AlertDescription>
    </Alert>
  );
};

export default ErrorAlert;

================
File: components/expense/ExpenseForm.tsx
================
import { Transaction, PaymentMethod } from '@/types';
import { FormProvider } from 'react-hook-form';
import { useExpenseForm, FormValues } from '@/hooks/useExpenseForm';
import { prepareTransactionData } from '@/utils/expense/submitExpense';
import { useToast } from '@/hooks/use-toast';

// Import component sections
import MerchantDetailsForm from './MerchantDetailsForm';
import TransactionDetailsForm from './TransactionDetailsForm';
import PaymentDetailsForm from './PaymentDetailsForm';

interface ExpenseFormProps {
  paymentMethods: PaymentMethod[];
  onSubmit: (transaction: Omit<Transaction, 'id'>) => void;
  defaultValues?: Partial<FormValues>;
}

const ExpenseForm = ({ paymentMethods, onSubmit, defaultValues }: ExpenseFormProps) => {
  const { toast } = useToast();
  const {
    form,
    selectedMCC,
    setSelectedMCC,
    selectedPaymentMethod,
    shouldOverridePayment,
    estimatedPoints,
  } = useExpenseForm({ paymentMethods, defaultValues });
  
  const handleFormSubmit = async (values: FormValues) => {
    try {
      if (!values.merchantName || values.merchantName.trim() === '') {
        toast({
          title: 'Error',
          description: 'Merchant name is required',
          variant: 'destructive',
        });
        return;
      }
      
      if (!values.paymentMethodId) {
        toast({
          title: 'Error',
          description: 'Payment method is required',
          variant: 'destructive',
        });
        return;
      }
      
      // Prepare transaction data
      const transaction = await prepareTransactionData(
        values,
        paymentMethods,
        selectedMCC,
        estimatedPoints
      );
      
      console.log('Submitting final transaction:', transaction);
      onSubmit(transaction);
    } catch (error) {
      console.error('Error submitting form:', error);
      toast({
        title: 'Error',
        description: 'Failed to save transaction',
        variant: 'destructive',
      });
    }
  };
  
  return (
    <FormProvider {...form}>
      <form onSubmit={form.handleSubmit(handleFormSubmit)} className="space-y-8">
        <MerchantDetailsForm onSelectMCC={setSelectedMCC} selectedMCC={selectedMCC} />
        <TransactionDetailsForm />
        <PaymentDetailsForm 
          paymentMethods={paymentMethods}
          selectedPaymentMethod={selectedPaymentMethod}
          shouldOverridePayment={shouldOverridePayment}
          estimatedPoints={estimatedPoints}
        />
      </form>
    </FormProvider>
  );
};

export default ExpenseForm;

================
File: components/expense/MerchantDetailsForm.tsx
================
import { useState, useEffect } from 'react';
import { useFormContext } from 'react-hook-form';
import { MerchantCategoryCode } from '@/types';
import { getMerchantByName } from '@/utils/storageUtils';
import { Input } from '@/components/ui/input';
import { StoreIcon } from 'lucide-react';
import { useDebounce } from '@/hooks/use-debounce';
import { supabase } from '@/integrations/supabase/client';
import {
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form';
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { useToast } from '@/hooks/use-toast';
import MerchantCategorySelect from './merchant/MerchantCategorySelect';
import MerchantAddressSelect from './merchant/MerchantAddressSelect';
import OnlineMerchantToggle from './merchant/OnlineMerchantToggle';
import { getSuggestedMerchantCategory, hasMerchantCategorySuggestions } from '@/utils/storage/merchantTracking';

interface Place {
  name: string;
  address: string;
  location: {
    lat: number;
    lng: number;
  };
}

interface MerchantDetailsFormProps {
  onSelectMCC: (mcc: MerchantCategoryCode) => void;
  selectedMCC?: MerchantCategoryCode;
}

const MerchantDetailsForm = ({ onSelectMCC, selectedMCC }: MerchantDetailsFormProps) => {
  const form = useFormContext();
  const [isAddressLoading, setIsAddressLoading] = useState(false);
  const [places, setPlaces] = useState<Place[]>([]);
  const [showPlacesDialog, setShowPlacesDialog] = useState(false);
  const { toast } = useToast();
  const [suggestionsChecked, setSuggestionsChecked] = useState(false);
  
  // When merchant name changes, check for existing merchant data
  const merchantName = form.watch('merchantName');
  const debouncedMerchantName = useDebounce(merchantName, 500);
  const isOnline = form.watch('isOnline');
  
  // Only check for suggestions once per merchant name and when no MCC is selected
  useEffect(() => {
    const checkMerchantSuggestions = async () => {
      if (debouncedMerchantName.trim().length >= 3 && !suggestionsChecked && !selectedMCC) {
        try {
          // Mark that we've checked suggestions for this merchant name
          setSuggestionsChecked(true);
          
          // Check if we have a suggestion for this merchant name that isn't deleted
          const hasSuggestions = await hasMerchantCategorySuggestions(debouncedMerchantName);
          
          if (hasSuggestions) {
            const suggestedMCC = await getSuggestedMerchantCategory(debouncedMerchantName);
            
            if (suggestedMCC) {
              // Set the MCC in the form and update the parent
              onSelectMCC(suggestedMCC);
              form.setValue('mcc', suggestedMCC);
              
              // Show toast to inform user about the suggested category
              toast({
                title: "Merchant category suggested",
                description: `Using ${suggestedMCC.description} (${suggestedMCC.code}) based on previous entries`,
              });
            }
          }
        } catch (error) {
          console.error('Error checking merchant suggestions:', error);
        }
      }
    };
    
    checkMerchantSuggestions();
  }, [debouncedMerchantName, form, toast, onSelectMCC, selectedMCC, suggestionsChecked]);

  // Reset suggestion check when merchant name changes significantly
  useEffect(() => {
    if (merchantName.trim().length < 3) {
      setSuggestionsChecked(false);
    }
  }, [merchantName]);

  // Fetch address suggestions when merchant name changes and it's not an online purchase
  useEffect(() => {
    const fetchAddressSuggestions = async () => {
      if (debouncedMerchantName.trim().length < 3 || isOnline) {
        setPlaces([]);
        return;
      }

      try {
        setIsAddressLoading(true);
        const { data, error } = await supabase.functions.invoke('search-places', {
          body: { query: debouncedMerchantName }
        });

        if (error) {
          console.error('Error fetching places:', error);
          return;
        }

        if (data.places && data.places.length > 0) {
          setPlaces(data.places);
          setShowPlacesDialog(true);
        } else {
          setPlaces([]);
        }
      } catch (error) {
        console.error('Error fetching places:', error);
      } finally {
        setIsAddressLoading(false);
      }
    };

    if (!isOnline) {
      fetchAddressSuggestions();
    }
  }, [debouncedMerchantName, isOnline]);

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <StoreIcon className="h-5 w-5" />
          Merchant Details
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <FormField
          control={form.control}
          name="merchantName"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Merchant Name</FormLabel>
              <FormControl>
                <Input placeholder="Enter merchant name" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <OnlineMerchantToggle />
        
        {!form.watch('isOnline') && (
          <MerchantAddressSelect 
            places={places}
            isLoading={isAddressLoading}
            showDialog={showPlacesDialog}
            setShowDialog={setShowPlacesDialog}
          />
        )}
        
        <MerchantCategorySelect 
          selectedMCC={selectedMCC}
          onSelectMCC={(mcc) => {
            onSelectMCC(mcc);
            setSuggestionsChecked(true); // Mark as checked when user manually selects
          }}
        />
      </CardContent>
    </Card>
  );
};

export default MerchantDetailsForm;

================
File: components/expense/PaymentCardDisplay.tsx
================
import React from 'react';
import { PaymentMethod } from '@/types';
import { CreditCardIcon, BanknoteIcon } from 'lucide-react';

interface PaymentCardDisplayProps {
  paymentMethod: PaymentMethod;
  customImage?: string;
  size?: 'default' | 'small';
}

const PaymentCardDisplay: React.FC<PaymentCardDisplayProps> = ({ 
  paymentMethod, 
  customImage,
  size = 'default' 
}) => {
  // Determine classes based on size
  const containerClasses = size === 'small' 
    ? "relative rounded-lg overflow-hidden w-24 h-14" 
    : "relative rounded-lg overflow-hidden w-48 h-28";
  
  const textClasses = size === 'small' ? "text-[8px]" : "text-xs";
  const iconClasses = size === 'small' ? "h-3 w-3" : "h-4 w-4";
  const lastFourClasses = size === 'small' ? "text-[8px]" : "text-xs";
  const issuerClasses = size === 'small' ? "text-[6px]" : "text-[10px]";
  const dotClasses = size === 'small' ? "w-3 h-2" : "w-6 h-4";
  
  // If there's a custom image, render that instead of the default card display
  if (customImage) {
    return (
      <div className={containerClasses}>
        <img 
          src={customImage} 
          alt={`${paymentMethod.name} card`} 
          className="w-full h-full object-cover rounded-lg"
        />
      </div>
    );
  }
  
  // Render a simplified card display with the payment method information
  return (
    <div
      className={`${containerClasses} p-3 flex flex-col justify-between`}
      style={{ backgroundColor: paymentMethod.color || '#4b5563' }}
    >
      <div className="flex justify-between items-start">
        <div className={`text-white ${textClasses} font-semibold line-clamp-2`}>
          {paymentMethod.name}
        </div>
        {paymentMethod.type === 'credit_card' ? (
          <CreditCardIcon className={`${iconClasses} text-white opacity-80`} />
        ) : (
          <BanknoteIcon className={`${iconClasses} text-white opacity-80`} />
        )}
      </div>
      
      <div className="text-white">
        {paymentMethod.type === 'credit_card' && paymentMethod.lastFourDigits && (
          <div className="flex items-center justify-between">
            <div className="flex gap-1">
              <div className={`${dotClasses} bg-white/20 rounded`} />
              <div className={`${dotClasses} bg-white/20 rounded`} />
              <div className={`${dotClasses} bg-white/20 rounded`} />
            </div>
            <div className={`${lastFourClasses} font-mono tracking-wider`}>{paymentMethod.lastFourDigits}</div>
          </div>
        )}
        {paymentMethod.issuer && (
          <div className={`${issuerClasses} text-white/70 mt-1 font-semibold uppercase`}>
            {paymentMethod.issuer}
          </div>
        )}
      </div>
    </div>
  );
};

export default PaymentCardDisplay;

================
File: components/expense/PaymentCardRender.tsx
================
import React from 'react';
import { PaymentMethod } from '@/types';
import { CreditCardIcon, BanknoteIcon } from 'lucide-react';
import { SelectItem, SelectContent, SelectTrigger, SelectValue, Select } from '@/components/ui/select';
import { FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { useFormContext } from 'react-hook-form';

interface PaymentMethodSelectProps {
  paymentMethods: PaymentMethod[];
  onSelectPaymentMethod?: (value: string) => void;
}

const PaymentMethodSelect: React.FC<PaymentMethodSelectProps> = ({ 
  paymentMethods,
  onSelectPaymentMethod 
}) => {
  const form = useFormContext();
  
  return (
    <FormField
      control={form.control}
      name="paymentMethodId"
      render={({ field }) => (
        <FormItem>
          <FormLabel>Payment Method</FormLabel>
          <Select 
            value={field.value ? String(field.value) : ''} 
            onValueChange={(value) => {
              console.log('Payment method selected:', value);
              field.onChange(value);
              if (onSelectPaymentMethod) onSelectPaymentMethod(value);
              // Force form validation after selection
              setTimeout(() => form.trigger('paymentMethodId'), 100);
            }}
          >
            <FormControl>
              <SelectTrigger>
                <SelectValue placeholder="Select payment method" />
              </SelectTrigger>
            </FormControl>
            <SelectContent>
              {paymentMethods.map((method) => (
                <SelectItem key={method.id} value={method.id}>
                  <div className="flex items-center gap-2">
                    {method.type === 'credit_card' ? (
                      <CreditCardIcon className="h-4 w-4" style={{ color: method.color }} />
                    ) : (
                      <BanknoteIcon className="h-4 w-4" style={{ color: method.color }} />
                    )}
                    <span>{method.name}</span>
                    {method.type === 'credit_card' && method.lastFourDigits && (
                      <span className="text-gray-500 text-xs">...{method.lastFourDigits}</span>
                    )}
                  </div>
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
          <FormMessage />
        </FormItem>
      )}
    />
  );
};

export default PaymentMethodSelect;

================
File: components/expense/PaymentDetailsForm.tsx
================
import { useFormContext } from 'react-hook-form';
import { PaymentMethod, Currency } from '@/types';
import { CreditCardIcon } from 'lucide-react';
import {
  Card,
  CardContent,
  CardFooter,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';

// Import our components
import PaymentMethodSelect from './PaymentCardRender';
import ContactlessToggle from './ContactlessToggle';
import PointsDisplay from './PointsDisplay';
import ConvertedAmountField from './ConvertedAmountField';
import { useCardAnalytics } from '@/hooks/useCardAnalytics';

interface PaymentDetailsFormProps {
  paymentMethods: PaymentMethod[];
  selectedPaymentMethod: PaymentMethod | undefined;
  shouldOverridePayment: boolean;
  estimatedPoints: number | {
    totalPoints: number;
    basePoints?: number;
    bonusPoints?: number;
    remainingMonthlyBonusPoints?: number;
    messageText?: string;
    pointsCurrency?: string;
  };
}

const PaymentDetailsForm = ({ 
  paymentMethods, 
  selectedPaymentMethod, 
  shouldOverridePayment,
  estimatedPoints
}: PaymentDetailsFormProps) => {
  const form = useFormContext();
  const isOnline = form.watch('isOnline');
  
  // Use our card analytics hook
  const { nonSgdSpendTotal, hasSgdTransactions } = useCardAnalytics(selectedPaymentMethod);

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <CreditCardIcon className="h-5 w-5" />
          Payment Details
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <PaymentMethodSelect paymentMethods={paymentMethods} />
        
        <ContactlessToggle 
          isOnline={isOnline} 
          isCash={selectedPaymentMethod?.type === 'cash' || false} 
        />
        
        <ConvertedAmountField 
          shouldOverridePayment={shouldOverridePayment} 
          selectedPaymentMethod={selectedPaymentMethod} 
        />
        
        <PointsDisplay 
          selectedPaymentMethod={selectedPaymentMethod}
          estimatedPoints={estimatedPoints}
        />
      </CardContent>
      <CardFooter className="flex justify-end space-x-2">
        <Button type="submit" className="w-full md:w-auto">
          Save Transaction
        </Button>
      </CardFooter>
    </Card>
  );
};

export default PaymentDetailsForm;

================
File: components/expense/PointsCurrencyAggregator.tsx
================
import React, { useMemo } from 'react';
import { Transaction } from '@/types';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { CoinsIcon } from 'lucide-react';
import { rewardCalculatorService } from '@/services/rewards/RewardCalculatorService';

interface PointsCurrencyAggregatorProps {
  transactions: Transaction[];
}

interface PointsAggregate {
  [currency: string]: number;
}

const PointsCurrencyAggregator: React.FC<PointsCurrencyAggregatorProps> = ({ transactions }) => {
  const pointsByCurrency = useMemo(() => {
    return transactions.reduce<PointsAggregate>((acc, transaction) => {
      if (!transaction.paymentMethod || !transaction.rewardPoints) return acc;
      
      // Get points currency from the central reward calculation service
      const pointsCurrency = rewardCalculationService.getPointsCurrency(transaction.paymentMethod);
      
      acc[pointsCurrency] = (acc[pointsCurrency] || 0) + (transaction.rewardPoints || 0);
      return acc;
    }, {});
  }, [transactions]);

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center">
          <CoinsIcon className="mr-2" />
          Points by Currency
        </CardTitle>
      </CardHeader>
      <CardContent>
        {Object.keys(pointsByCurrency).length > 0 ? (
          Object.entries(pointsByCurrency).map(([currency, points]) => (
            <div key={currency} className="flex justify-between items-center mb-2 p-2 border-b">
              <span>{currency}</span>
              <span className="font-bold">{points.toLocaleString()}</span>
            </div>
          ))
        ) : (
          <div className="text-center py-6 text-gray-500">
            No reward points in this period
          </div>
        )}
      </CardContent>
    </Card>
  );
};

export default PointsCurrencyAggregator;

================
File: components/expense/PointsDisplay.tsx
================
import React from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { CoinsIcon } from 'lucide-react';
import { PaymentMethod } from '@/types';
import { rewardCalculatorService } from '@/services/rewards/RewardCalculatorService';

interface PointsDisplayProps {
  selectedPaymentMethod: PaymentMethod | undefined;
  estimatedPoints: number | {
    totalPoints: number;
    basePoints?: number;
    bonusPoints?: number;
    remainingMonthlyBonusPoints?: number;
    messageText?: string;
    pointsCurrency?: string;
  };
}

/**
 * PointsDisplay component that shows reward point calculations using the
 * centralized calculation system.
 * 
 * This component is part of the reward points calculation refactoring.
 * It now uses a single source of truth (estimatedPoints from the useRewardPoints hook)
 * instead of using individual card components for calculations.
 */
const PointsDisplay: React.FC<PointsDisplayProps> = ({
  selectedPaymentMethod,
  estimatedPoints
}) => {
  // Only hide for cash payment methods or if no payment method is selected
  if (!selectedPaymentMethod || selectedPaymentMethod.type === 'cash') {
    return null;
  }

  // If estimatedPoints is just a number, create a proper object
  const pointsInfo = typeof estimatedPoints === 'number' 
    ? { 
        totalPoints: estimatedPoints,
        basePoints: estimatedPoints,
        bonusPoints: 0,
        pointsCurrency: selectedPaymentMethod ? 
          rewardCalculatorService.getPointsCurrency(selectedPaymentMethod) : 
          'Points'
      } 
    : estimatedPoints;

  // Ensure bonusPoints is properly defined
  if (typeof pointsInfo === 'object' && pointsInfo.bonusPoints === undefined && 
      pointsInfo.basePoints !== undefined && pointsInfo.totalPoints !== undefined) {
    pointsInfo.bonusPoints = pointsInfo.totalPoints - pointsInfo.basePoints;
  }

  // Ensure we never pass undefined bonus points to the card
  const finalPointsInfo = {
    ...pointsInfo,
    bonusPoints: typeof pointsInfo.bonusPoints === 'number' ? pointsInfo.bonusPoints : 0,
    basePoints: pointsInfo.basePoints ?? pointsInfo.totalPoints ?? 0,
    // Add a debug message to help troubleshoot
    messageText: pointsInfo.messageText || (
      (pointsInfo.bonusPoints && pointsInfo.bonusPoints > 0) ? 
        `Earning ${pointsInfo.bonusPoints} bonus points` : 
        undefined
    )
  };

  // Log for debugging
  console.log('PointsDisplay rendering with:', {
    selectedPaymentMethod: selectedPaymentMethod.name,
    originalPoints: estimatedPoints,
    finalPointsInfo
  });

  // Render a generic card with the points information
  return (
    <Card className="border border-amber-200 bg-amber-50 dark:bg-amber-950/20 dark:border-amber-800">
      <CardContent className="pt-6 pb-4">
        <div className="flex items-start space-x-4">
          <div className="bg-amber-100 dark:bg-amber-900/30 p-2 rounded-full">
            <CoinsIcon className="h-6 w-6 text-amber-600 dark:text-amber-400" />
          </div>
          <div className="space-y-1">
            <h3 className="text-base font-semibold">
              {finalPointsInfo.totalPoints.toLocaleString()} {finalPointsInfo.pointsCurrency || 'Points'}
            </h3>
            {finalPointsInfo.basePoints !== undefined && (
              <p className="text-sm text-gray-600 dark:text-gray-400">
                Base: {finalPointsInfo.basePoints.toLocaleString()} {finalPointsInfo.bonusPoints > 0 && 
                  `+ Bonus: ${finalPointsInfo.bonusPoints.toLocaleString()}`}
              </p>
            )}
            {finalPointsInfo.messageText && (
              <p className="text-sm text-amber-600 dark:text-amber-400">
                {finalPointsInfo.messageText}
              </p>
            )}
            {finalPointsInfo.remainingMonthlyBonusPoints !== undefined && finalPointsInfo.remainingMonthlyBonusPoints > 0 && (
              <p className="text-xs text-gray-500 dark:text-gray-500">
                {finalPointsInfo.remainingMonthlyBonusPoints.toLocaleString()} bonus points remaining this month
              </p>
            )}
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

export default PointsDisplay;

================
File: components/expense/StorageModeAlert.tsx
================
import React from 'react';
import { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';
import { AlertTriangle } from 'lucide-react';

interface StorageModeAlertProps {
  useLocalStorage: boolean;
}

const StorageModeAlert: React.FC<StorageModeAlertProps> = ({ useLocalStorage }) => {
  if (!useLocalStorage) return null;

  return (
    <Alert className="mb-4 bg-amber-50 text-amber-700 border-amber-200">
      <AlertTriangle className="h-5 w-5" />
      <AlertTitle>Using local storage</AlertTitle>
      <AlertDescription>
        Transactions will be saved to local storage. Your data will only be available on this device.
      </AlertDescription>
    </Alert>
  );
};

export default StorageModeAlert;

================
File: components/expense/TransactionCard.tsx
================
import { Transaction } from "@/types";
import { CurrencyService } from "@/services/CurrencyService";
import { formatDate } from "@/utils/dateUtils";
import {
  CreditCardIcon,
  BanknoteIcon,
  TagIcon,
  MapPinIcon,
} from "lucide-react";
import { cn } from "@/lib/utils";
import { CSSProperties } from "react";

interface TransactionCardProps {
  transaction: Transaction;
  onClick?: () => void;
  className?: string;
  style?: CSSProperties;
}

const TransactionCard = ({
  transaction,
  onClick,
  className,
  style,
}: TransactionCardProps) => {
  const { merchant, amount, currency, date, paymentMethod, rewardPoints } =
    transaction;

  const isPaymentDifferent =
    transaction.paymentAmount !== amount ||
    transaction.paymentCurrency !== currency;

  return (
    <div
      className={cn(
        "modern-card p-4 overflow-hidden",
        onClick &&
          "cursor-pointer hover:shadow-card-hover hover:-translate-y-1 transition-all duration-200",
        className
      )}
      onClick={onClick}
      style={style}
    >
      <div className="flex items-start justify-between">
        <div className="flex-1 min-w-0 pr-2">
          <h3
            className="font-semibold text-base md:text-lg truncate"
            title={merchant.name}
          >
            {merchant.name}
          </h3>
          <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
            {formatDate(date)}
          </p>
        </div>
        <div className="text-right flex-shrink-0">
          <p
            className="font-semibold text-base md:text-lg whitespace-nowrap"
            title={CurrencyService.format(amount, currency)}
          >
            {CurrencyService.format(amount, currency)}
          </p>
          {isPaymentDifferent && (
            <p
              className="text-sm text-gray-500 dark:text-gray-400 mt-1 whitespace-nowrap"
              title={`Paid: ${CurrencyService.format(transaction.paymentAmount, transaction.paymentCurrency)}`}
            >
              Paid:{" "}
              {CurrencyService.format(
                transaction.paymentAmount,
                transaction.paymentCurrency
              )}
            </p>
          )}
        </div>
      </div>

      <div className="mt-3 pt-3 border-t border-gray-100 dark:border-gray-800 flex flex-wrap gap-2">
        <div className="inline-flex items-center text-xs rounded-full px-3 py-1 bg-blue-50 dark:bg-blue-900/30 max-w-full">
          {paymentMethod.type === "credit_card" ? (
            <CreditCardIcon
              className="h-3.5 w-3.5 mr-1.5 flex-shrink-0"
              style={{ color: paymentMethod.color }}
            />
          ) : (
            <BanknoteIcon
              className="h-3.5 w-3.5 mr-1.5 flex-shrink-0"
              style={{ color: paymentMethod.color }}
            />
          )}
          <span className="truncate" title={paymentMethod.name}>
            {paymentMethod.name}
          </span>
        </div>

        {merchant.mcc && (
          <div className="inline-flex items-center text-xs rounded-full px-3 py-1 bg-purple-50 dark:bg-purple-900/30 max-w-full">
            <TagIcon className="h-3.5 w-3.5 mr-1.5 flex-shrink-0 text-purple-500" />
            <span className="truncate" title={merchant.mcc.description}>
              {merchant.mcc.description}
            </span>
          </div>
        )}

        {rewardPoints > 0 && (
          <div className="inline-flex items-center text-xs rounded-full px-3 py-1 bg-amber-50 dark:bg-amber-900/30 text-amber-700 dark:text-amber-300 whitespace-nowrap">
            <span>+{rewardPoints} points</span>
          </div>
        )}

        {merchant.address && (
          <div className="inline-flex items-center text-xs rounded-full px-3 py-1 bg-red-50 dark:bg-red-900/30 max-w-full">
            <MapPinIcon className="h-3.5 w-3.5 mr-1.5 flex-shrink-0 text-red-500" />
            <span className="truncate" title={merchant.address}>
              {merchant.address}
            </span>
          </div>
        )}
      </div>
    </div>
  );
};

export default TransactionCard;

================
File: components/expense/TransactionDetailsForm.tsx
================
import { useFormContext } from "react-hook-form";
import { format } from "date-fns";
import { Currency } from "@/types";
import { CurrencyService } from "@/services/CurrencyService";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { CalendarIcon } from "lucide-react";
import {
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  FormDescription,
} from "@/components/ui/form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Calendar } from "@/components/ui/calendar";
import { cn } from "@/lib/utils";
import { Textarea } from "@/components/ui/textarea";

const currencyOptions = CurrencyService.getCurrencyOptions();

const TransactionDetailsForm = () => {
  const form = useFormContext();
  const currency = form.watch("currency");

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <CalendarIcon className="h-5 w-5" />
          Transaction Details
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <FormField
            control={form.control}
            name="amount"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Transaction Amount</FormLabel>
                <FormControl>
                  <Input
                    type="number"
                    min="0.01"
                    step="0.01"
                    placeholder="0.00"
                    {...field}
                    onChange={(e) => {
                      field.onChange(e);
                      // Update payment amount automatically when transaction amount changes
                      const currentPaymentMethod =
                        form.getValues("paymentMethodId");
                      if (currentPaymentMethod) {
                        form.setValue("paymentAmount", e.target.value);
                      }
                    }}
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="currency"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Currency</FormLabel>
                <Select
                  value={field.value}
                  onValueChange={(value) => {
                    field.onChange(value);
                  }}
                >
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="Select currency" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    {currencyOptions.map((option) => (
                      <SelectItem key={option.value} value={option.value}>
                        {option.label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        {/* New Reimbursement Amount Field */}
        <FormField
          control={form.control}
          name="reimbursementAmount"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Reimbursement Amount</FormLabel>
              <FormControl>
                <Input
                  type="number"
                  min="0"
                  step="0.01"
                  placeholder="0.00"
                  {...field}
                />
              </FormControl>
              <FormDescription>
                Amount reimbursed for this expense (in {currency})
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="date"
          render={({ field }) => (
            <FormItem className="flex flex-col">
              <FormLabel>Date</FormLabel>
              <Popover>
                <PopoverTrigger asChild>
                  <FormControl>
                    <Button
                      variant={"outline"}
                      className={cn(
                        "w-full pl-3 text-left font-normal",
                        !field.value && "text-muted-foreground"
                      )}
                    >
                      {field.value ? (
                        format(field.value, "PPP")
                      ) : (
                        <span>Pick a date</span>
                      )}
                      <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                    </Button>
                  </FormControl>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0" align="start">
                  <Calendar
                    mode="single"
                    selected={field.value}
                    onSelect={field.onChange}
                    disabled={(date) => date > new Date()}
                    initialFocus
                    className="pointer-events-auto"
                  />
                </PopoverContent>
              </Popover>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="notes"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Notes (Optional)</FormLabel>
              <FormControl>
                <Textarea
                  placeholder="Add any notes about this transaction"
                  className="resize-none"
                  {...field}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </CardContent>
    </Card>
  );
};

export default TransactionDetailsForm;

================
File: components/expense/TransactionDialog.tsx
================
import { useState } from 'react';
import { Transaction, PaymentMethod } from '@/types';
import {
  Dialog,
  DialogContent,
} from '@/components/ui/dialog';

// Import our new components
import TransactionDialogHeader from './dialog/TransactionDialogHeader';
import TransactionDetailsView from './dialog/TransactionDetailsView';
import TransactionDialogActions from './dialog/TransactionDialogActions';
import TransactionEditForm from './dialog/TransactionEditForm';

interface TransactionDialogProps {
  transaction: Transaction | null;
  paymentMethods: PaymentMethod[];
  allTransactions: Transaction[];
  isOpen: boolean;
  mode: 'view' | 'edit';
  onClose: () => void;
  onEdit: (transaction: Transaction) => void;
  onDelete: (transaction: Transaction) => void;
  onSave: (transaction: Omit<Transaction, 'id'>) => void;
}

const TransactionDialog = ({
  transaction,
  paymentMethods,
  allTransactions,
  isOpen,
  mode,
  onClose,
  onEdit,
  onDelete,
  onSave,
}: TransactionDialogProps) => {
  const [dialogMode, setDialogMode] = useState<'view' | 'edit'>(mode);
  
  if (!transaction) return null;
  
  const handleSaveEdit = (updatedTransaction: Omit<Transaction, 'id'>) => {
    onSave(updatedTransaction);
    setDialogMode('view');
  };
  
  const handleCancelEdit = () => {
    setDialogMode('view');
  };
  
  return (
    <Dialog open={isOpen} onOpenChange={(open) => {
      if (!open) {
        onClose();
        setDialogMode(mode);
      }
    }}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-auto">
        {dialogMode === 'view' ? (
          <>
            <TransactionDialogHeader transaction={transaction} />
            <TransactionDetailsView transaction={transaction} />
            <TransactionDialogActions 
              transaction={transaction} 
              onDelete={onDelete} 
              onEdit={() => setDialogMode('edit')} 
            />
          </>
        ) : (
          <TransactionEditForm 
            transaction={transaction}
            paymentMethods={paymentMethods}
            onSubmit={handleSaveEdit}
            onCancel={handleCancelEdit}
          />
        )}
      </DialogContent>
    </Dialog>
  );
};

export default TransactionDialog;

================
File: components/expense/TransactionTable.tsx
================
import { useState, useMemo } from "react";
import {
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Transaction, PaymentMethod } from "@/types";
import { CurrencyService } from "@/services/CurrencyService";
import { formatDate } from "@/utils/dateUtils";
import { EditIcon, TrashIcon, DownloadIcon, EyeIcon } from "lucide-react";
import { exportTransactionsToCSV } from "@/utils/storage/transactions";
import {
  getCategoryFromMCC,
  getCategoryFromMerchantName,
} from "@/utils/categoryMapping";

interface TransactionTableProps {
  transactions: Transaction[];
  paymentMethods: PaymentMethod[];
  onEdit: (transaction: Transaction) => void;
  onDelete: (transaction: Transaction) => void;
  onView: (transaction: Transaction) => void;
}

const TransactionTable = ({
  transactions,
  paymentMethods,
  onEdit,
  onDelete,
  onView,
}: TransactionTableProps) => {
  // Memoize CSV export to prevent recalculation on every render
  const handleExportCSV = useMemo(
    () => () => {
      const csvContent = exportTransactionsToCSV(transactions);

      // Create a blob and download link
      const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");

      link.setAttribute("href", url);
      link.setAttribute(
        "download",
        `transactions_export_${new Date().toISOString().slice(0, 10)}.csv`
      );
      link.style.visibility = "hidden";

      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    },
    [transactions]
  );

  // Precompute all categories for display - only recalculate when transactions change
  const transactionCategories = useMemo(() => {
    return transactions.reduce(
      (acc, transaction) => {
        const txId = transaction.id;

        // Use transaction's stored category if available
        if (transaction.category && transaction.category !== "Uncategorized") {
          acc[txId] = transaction.category;
          return acc;
        }

        // Try to determine from MCC
        if (transaction.merchant.mcc?.code) {
          acc[txId] = getCategoryFromMCC(transaction.merchant.mcc.code);
          return acc;
        }

        // Try to determine from merchant name
        const nameBasedCategory = getCategoryFromMerchantName(
          transaction.merchant.name
        );
        if (nameBasedCategory) {
          acc[txId] = nameBasedCategory;
          return acc;
        }

        acc[txId] = "Uncategorized";
        return acc;
      },
      {} as Record<string, string>
    );
  }, [transactions]);

  return (
    <div className="w-full">
      <div className="flex justify-end mb-4">
        <Button
          variant="outline"
          size="sm"
          className="flex items-center gap-1"
          onClick={handleExportCSV}
        >
          <DownloadIcon className="h-4 w-4" />
          Export CSV
        </Button>
      </div>

      <div className="rounded-md border overflow-hidden">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Date</TableHead>
              <TableHead>Merchant</TableHead>
              <TableHead>Category</TableHead>
              <TableHead>Amount</TableHead>
              <TableHead>Payment Method</TableHead>
              <TableHead>Points</TableHead>
              <TableHead className="w-[100px] text-right">Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {transactions.length === 0 ? (
              <TableRow>
                <TableCell colSpan={7} className="h-24 text-center">
                  No transactions found.
                </TableCell>
              </TableRow>
            ) : (
              transactions.map((transaction) => (
                <TableRow key={transaction.id}>
                  <TableCell>{formatDate(transaction.date)}</TableCell>
                  <TableCell>
                    <div className="font-medium">
                      {transaction.merchant.name}
                    </div>
                    <div className="text-xs text-muted-foreground">
                      {transaction.merchant.isOnline ? "Online" : "In-store"}
                      {transaction.isContactless &&
                        !transaction.merchant.isOnline &&
                        "  Contactless"}
                    </div>
                  </TableCell>
                  <TableCell>{transactionCategories[transaction.id]}</TableCell>
                  <TableCell>
                    <div>
                      {CurrencyService.format(
                        transaction.amount,
                        transaction.currency
                      )}
                    </div>
                    {transaction.currency !== transaction.paymentCurrency && (
                      <div className="text-xs text-muted-foreground">
                        {CurrencyService.format(
                          transaction.paymentAmount,
                          transaction.paymentCurrency
                        )}
                      </div>
                    )}
                  </TableCell>
                  <TableCell>
                    <div className="font-medium">
                      {transaction.paymentMethod.name}
                    </div>
                    <div className="text-xs text-muted-foreground">
                      {transaction.paymentMethod.issuer}
                    </div>
                  </TableCell>
                  <TableCell>
                    {transaction.rewardPoints > 0 ? (
                      <div className="font-medium">
                        {transaction.rewardPoints.toLocaleString()}
                      </div>
                    ) : transaction.paymentMethod.type === "credit_card" ? (
                      <div className="text-amber-600 font-medium">
                        {Math.round(transaction.amount * 0.4).toLocaleString()}*
                      </div>
                    ) : (
                      <div className="text-muted-foreground">-</div>
                    )}
                  </TableCell>
                  <TableCell className="text-right">
                    <div className="flex justify-end gap-2">
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={() => onView(transaction)}
                      >
                        <EyeIcon className="h-4 w-4" />
                        <span className="sr-only">View</span>
                      </Button>
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={() => onEdit(transaction)}
                      >
                        <EditIcon className="h-4 w-4" />
                        <span className="sr-only">Edit</span>
                      </Button>
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={() => onDelete(transaction)}
                      >
                        <TrashIcon className="h-4 w-4" />
                        <span className="sr-only">Delete</span>
                      </Button>
                    </div>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>
    </div>
  );
};

export default TransactionTable;

================
File: components/payment-method/CategorySelector.tsx
================
import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { CheckIcon, SaveIcon } from 'lucide-react';
import { cn } from '@/lib/utils';
import { PaymentMethod } from '@/types';
import { getPaymentMethods, savePaymentMethods } from '@/utils/storageUtils';
import { useToast } from '@/hooks/use-toast';

// Available categories for UOB Lady's card
const AVAILABLE_CATEGORIES = [
  'Beauty & Wellness',
  'Dining',
  'Entertainment',
  'Family',
  'Fashion',
  'Transport',
  'Travel'
];

// Maximum number of selectable categories
const MAX_CATEGORIES = 2;

interface CategorySelectorProps {
  paymentMethod: PaymentMethod;
  onCategoriesChanged?: (selectedCategories: string[]) => void;
}

const CategorySelector: React.FC<CategorySelectorProps> = ({ 
  paymentMethod,
  onCategoriesChanged
}) => {
  // Track current (saved) categories
  const [currentCategories, setCurrentCategories] = useState<string[]>(
    paymentMethod.selectedCategories || []
  );
  
  // Track draft selections (not yet saved)
  const [selectedCategories, setSelectedCategories] = useState<string[]>(
    paymentMethod.selectedCategories || []
  );
  
  const [isUpdating, setIsUpdating] = useState(false);
  const { toast } = useToast();

  // Update the state when the payment method changes
  useEffect(() => {
    const savedCategories = paymentMethod.selectedCategories || [];
    setCurrentCategories(savedCategories);
    setSelectedCategories(savedCategories);
  }, [paymentMethod]);

  // Handle category selection (draft only, not saved yet)
  const handleCategoryToggle = (category: string) => {
    if (isUpdating) return;

    let updatedCategories: string[];
    
    if (selectedCategories.includes(category)) {
      // Remove category if already selected
      updatedCategories = selectedCategories.filter(c => c !== category);
    } else {
      // Add category if under the limit, otherwise replace the first one
      if (selectedCategories.length < MAX_CATEGORIES) {
        updatedCategories = [...selectedCategories, category];
      } else {
        updatedCategories = [selectedCategories[1], category];
      }
    }

    // Update local state only (not saved yet)
    setSelectedCategories(updatedCategories);
  };
  
  // Save changes when user clicks the Save button
  const handleSaveCategories = async () => {
    if (isUpdating) return;
    
    try {
      setIsUpdating(true);
      
      // Get current payment methods
      const allPaymentMethods = await getPaymentMethods();
      
      // Update this specific payment method
      const updatedPaymentMethods = allPaymentMethods.map(pm => {
        if (pm.id === paymentMethod.id) {
          return { ...pm, selectedCategories };
        }
        return pm;
      });
      
      // Save to storage
      await savePaymentMethods(updatedPaymentMethods);
      
      // Update current categories to match selection
      setCurrentCategories(selectedCategories);
      
      // Notify parent component
      if (onCategoriesChanged) {
        onCategoriesChanged(selectedCategories);
      }
      
      toast({
        title: "Categories updated",
        description: `Selected categories: ${selectedCategories.join(', ') || 'None'}`,
      });
    } catch (error) {
      console.error('Error updating categories:', error);
      toast({
        title: "Error",
        description: "Failed to update categories",
        variant: "destructive",
      });
      
      // Reset selections to last saved state on error
      setSelectedCategories(currentCategories);
    } finally {
      setIsUpdating(false);
    }
  };
  
  // Check if draft selections differ from current saved categories
  const hasUnsavedChanges = () => {
    if (selectedCategories.length !== currentCategories.length) return true;
    
    for (const category of selectedCategories) {
      if (!currentCategories.includes(category)) return true;
    }
    
    return false;
  };

  return (
    <div className="bg-slate-900 p-4 rounded-lg">
      <div className="mb-4">
        <h2 className="text-white text-lg font-medium">Category Spending</h2>
        <p className="text-gray-400">2X UNI$ on selected categories</p>
        <p className="text-white mt-3">Select up to 2 categories where you want to earn bonus points.</p>
      </div>
      
      <div className="bg-slate-800 p-4 rounded-lg">
        <div className="flex items-center mb-4">
          <h3 className="text-white font-medium">Category Spending</h3>
          <div className="ml-auto text-sm">
            <span className="bg-blue-500 text-white rounded-full px-2 py-0.5">
              {selectedCategories.length}x
            </span>
          </div>
        </div>
        
        <div className="mb-2 flex items-center">
          <span className="text-sm text-gray-400">{selectedCategories.length}/{MAX_CATEGORIES} Selected categories (up to {MAX_CATEGORIES})</span>
        </div>
        
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-2 mt-4">
          {AVAILABLE_CATEGORIES.map((category) => (
            <Button
              key={category}
              type="button"
              variant="ghost"
              className={cn(
                "justify-start h-10 px-4 py-2 w-full",
                selectedCategories.includes(category) 
                  ? "bg-blue-600 hover:bg-blue-700 text-white" 
                  : "bg-slate-900 hover:bg-slate-950 text-gray-300"
              )}
              onClick={() => handleCategoryToggle(category)}
              disabled={isUpdating}
            >
              {selectedCategories.includes(category) && (
                <CheckIcon className="h-4 w-4 mr-2 shrink-0 text-white" />
              )}
              <span className="truncate">{category}</span>
            </Button>
          ))}
        </div>
        
        <div className="mt-6 text-sm text-gray-400">
          <p>Monthly Cap: 3600 points</p>
          <p>Points Currency: UNI$</p>
        </div>
        
        <div className="mt-4 flex justify-end">
          <Button
            onClick={handleSaveCategories}
            disabled={isUpdating || !hasUnsavedChanges()}
            className={cn(
              "px-4 py-2",
              hasUnsavedChanges() ? "bg-blue-600 hover:bg-blue-700" : "bg-slate-700 text-gray-400"
            )}
          >
            {isUpdating ? (
              <div className="flex items-center">
                <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Saving...
              </div>
            ) : (
              <div className="flex items-center">
                <SaveIcon className="mr-2 h-4 w-4" />
                Save
              </div>
            )}
          </Button>
        </div>
      </div>
    </div>
  );
};

export default CategorySelector;

================
File: components/payment-method/EmptyPaymentMethodsCard.tsx
================
import React from 'react';
import { Button } from '@/components/ui/button';
import { PlusCircleIcon } from 'lucide-react';

interface EmptyPaymentMethodsCardProps {
  type: 'credit_cards' | 'cash';
  onAddClick: () => void;
}

const EmptyPaymentMethodsCard: React.FC<EmptyPaymentMethodsCardProps> = ({ type, onAddClick }) => {
  return (
    <div className="glass-card rounded-xl p-8 text-center">
      <p className="text-muted-foreground mb-4">
        {type === 'credit_cards' 
          ? 'No credit cards added yet.' 
          : 'No cash payment methods added yet.'
        }
      </p>
      <Button onClick={onAddClick}>
        <PlusCircleIcon className="mr-2 h-4 w-4" />
        Add {type === 'credit_cards' ? 'Credit Card' : 'Cash Method'}
      </Button>
    </div>
  );
};

export default EmptyPaymentMethodsCard;

================
File: components/payment-method/EmptyPaymentMethodState.tsx
================
import React from 'react';
import { CreditCardIcon, PlusCircleIcon } from 'lucide-react';
import { Button } from '@/components/ui/button';

interface EmptyPaymentMethodStateProps {
  onAddClick: () => void;
}

export const EmptyPaymentMethodState: React.FC<EmptyPaymentMethodStateProps> = ({ onAddClick }) => {
  return (
    <div className="flex flex-col items-center justify-center py-16 px-4 border-2 border-dashed rounded-lg bg-muted/20">
      <div className="bg-primary/10 p-4 rounded-full mb-4">
        <CreditCardIcon className="h-10 w-10 text-primary/70" />
      </div>
      <h3 className="text-xl font-semibold mb-2">No Payment Methods</h3>
      <p className="text-center text-muted-foreground mb-6 max-w-md">
        Add credit cards or cash payment methods to track your expenses and optimize reward points.
      </p>
      <Button onClick={onAddClick} className="gap-2">
        <PlusCircleIcon className="h-4 w-4" />
        Add Your First Payment Method
      </Button>
    </div>
  );
};

================
File: components/payment-method/ImageUploadDialog.tsx
================
import React, { useState, useRef } from 'react';
import { PaymentMethod } from '@/types';
import { 
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { ImageIcon, UploadIcon, XIcon } from 'lucide-react';
import PaymentCardDisplay from '../expense/PaymentCardDisplay';

interface ImageUploadDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  paymentMethod: PaymentMethod | null;
  onImageUpload: (file: File) => Promise<void>;
  isUploading: boolean;
}

const ImageUploadDialog: React.FC<ImageUploadDialogProps> = ({
  open,
  onOpenChange,
  paymentMethod,
  onImageUpload,
  isUploading
}) => {
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      const file = e.target.files[0];
      setSelectedFile(file);
      
      // Create a preview URL
      const url = URL.createObjectURL(file);
      setPreviewUrl(url);
    }
  };

  const handleUpload = async () => {
    if (selectedFile) {
      await onImageUpload(selectedFile);
      resetUpload();
    }
  };

  const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      const file = e.dataTransfer.files[0];
      if (file.type.startsWith('image/')) {
        setSelectedFile(file);
        const url = URL.createObjectURL(file);
        setPreviewUrl(url);
      }
    }
  };

  const resetUpload = () => {
    setSelectedFile(null);
    setPreviewUrl(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const handleClose = () => {
    resetUpload();
    onOpenChange(false);
  };

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>Upload Card Image</DialogTitle>
          <DialogDescription>
            Upload a custom image for your {paymentMethod?.name} card
          </DialogDescription>
        </DialogHeader>
        
        <div className="flex flex-col space-y-4 py-4">
          {paymentMethod?.imageUrl && !previewUrl && (
            <div>
              <div className="text-sm font-medium mb-2">Current Image:</div>
              <PaymentCardDisplay 
                paymentMethod={paymentMethod} 
                customImage={paymentMethod.imageUrl} 
              />
            </div>
          )}
          
          <div 
            className="border-2 border-dashed rounded-lg p-6 text-center cursor-pointer hover:bg-secondary/30 transition-colors"
            onDragOver={(e) => e.preventDefault()}
            onDragEnter={(e) => e.preventDefault()}
            onDrop={handleDrop}
            onClick={() => fileInputRef.current?.click()}
          >
            <input
              type="file"
              ref={fileInputRef}
              onChange={handleFileChange}
              accept="image/*"
              className="hidden"
            />
            
            {previewUrl ? (
              <div className="flex flex-col items-center">
                <div className="relative mb-3 max-w-[180px]">
                  <img 
                    src={previewUrl} 
                    alt="Card preview" 
                    className="w-full h-auto rounded-lg object-cover"
                  />
                  <Button
                    variant="destructive"
                    size="icon"
                    className="absolute -top-2 -right-2 h-6 w-6 rounded-full"
                    onClick={(e) => {
                      e.stopPropagation();
                      resetUpload();
                    }}
                  >
                    <XIcon className="h-3 w-3" />
                  </Button>
                </div>
                <span className="text-sm text-muted-foreground">Click to select a different image</span>
              </div>
            ) : (
              <div className="flex flex-col items-center">
                <ImageIcon className="h-8 w-8 mb-2 text-muted-foreground" />
                <p className="text-sm font-medium">Drop image here or click to browse</p>
                <p className="text-xs text-muted-foreground mt-1">
                  Supports JPG, PNG, WebP
                </p>
              </div>
            )}
          </div>
        </div>
        
        <DialogFooter>
          <Button 
            type="button" 
            variant="outline" 
            onClick={handleClose}
          >
            Cancel
          </Button>
          <Button 
            type="button"
            disabled={!selectedFile || isUploading}
            onClick={handleUpload}
          >
            {isUploading ? (
              <span className="flex items-center">
                <svg className="animate-spin -ml-1 mr-2 h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Uploading...
              </span>
            ) : (
              <span className="flex items-center">
                <UploadIcon className="mr-2 h-4 w-4" />
                Upload
              </span>
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default ImageUploadDialog;

================
File: components/payment-method/PaymentCardFace.tsx
================
import React from 'react';
import { PaymentMethod } from '@/types';
import { cn } from '@/lib/utils';
import { CreditCardIcon, BanknoteIcon } from 'lucide-react';
import { formatCurrency } from '@/utils/currencyFormatter';
import { useTransactionsQuery } from '@/hooks/queries/useTransactionsQuery';

interface PaymentCardFaceProps {
  paymentMethod: PaymentMethod;
}

export const PaymentCardFace: React.FC<PaymentCardFaceProps> = ({ paymentMethod }) => {
  // Get transactions for this payment method to calculate balance
  const { data: allTransactions = [] } = useTransactionsQuery();
  
  // Filter transactions for this payment method in the current month
  const currentMonthTransactions = allTransactions.filter(tx => 
    tx.paymentMethod.id === paymentMethod.id && 
    !tx.is_deleted &&
    new Date(tx.date).getMonth() === new Date().getMonth() &&
    new Date(tx.date).getFullYear() === new Date().getFullYear()
  );

  // Calculate current balance
  const currentBalance = currentMonthTransactions.reduce((total, tx) => total + tx.paymentAmount, 0);

  // Generate a background gradient based on the payment method
  const getCardBackground = (): string => {
    if (paymentMethod.type === 'cash') {
      return 'bg-gradient-to-br from-emerald-500 to-teal-700';
    }
    
    // Credit card background based on issuer
    const issuerLower = paymentMethod.issuer?.toLowerCase() || '';
    
    if (issuerLower.includes('amex') || issuerLower.includes('american')) {
      return 'bg-gradient-to-br from-blue-500 to-indigo-800';
    } else if (issuerLower.includes('visa')) {
      return 'bg-gradient-to-br from-blue-400 to-blue-700';
    } else if (issuerLower.includes('mastercard')) {
      return 'bg-gradient-to-br from-orange-500 to-red-700';
    } else if (issuerLower.includes('discover')) {
      return 'bg-gradient-to-br from-orange-400 to-orange-700';
    } else if (issuerLower.includes('diners')) {
      return 'bg-gradient-to-br from-slate-500 to-slate-800';
    } else if (issuerLower.includes('jcb')) {
      return 'bg-gradient-to-br from-green-500 to-emerald-700';
    } else if (issuerLower.includes('uob')) {
      return 'bg-gradient-to-br from-blue-600 to-indigo-900';
    } else if (issuerLower.includes('dbs')) {
      return 'bg-gradient-to-br from-red-600 to-red-900';
    } else if (issuerLower.includes('ocbc')) {
      return 'bg-gradient-to-br from-red-500 to-orange-800';
    }
    
    // Default purple gradient
    return 'bg-gradient-to-br from-purple-500 to-purple-800';
  };

  // Custom card badge component instead of using the problematic package
  const CardNetworkBadge = () => {
    if (paymentMethod.type !== 'credit_card' || !paymentMethod.issuer) {
      return null;
    }

    const issuerLower = paymentMethod.issuer.toLowerCase();
    let badgeClasses = "h-10 w-10 p-2 rounded-full bg-white/90 text-black font-bold flex items-center justify-center";
    let networkName = "";
    
    if (issuerLower.includes('visa')) {
      networkName = "VISA";
      badgeClasses += " text-blue-700";
    } else if (issuerLower.includes('mastercard') || issuerLower.includes('master')) {
      networkName = "MC";
      badgeClasses += " text-red-600";
    } else if (issuerLower.includes('amex') || issuerLower.includes('american express')) {
      networkName = "AMEX";
      badgeClasses += " text-blue-800";
    } else if (issuerLower.includes('discover')) {
      networkName = "DISC";
      badgeClasses += " text-orange-600";
    } else if (issuerLower.includes('diners') || issuerLower.includes('diner')) {
      networkName = "DC";
      badgeClasses += " text-slate-700";
    } else if (issuerLower.includes('jcb')) {
      networkName = "JCB";
      badgeClasses += " text-green-700";
    } else {
      return <CreditCardIcon className="h-10 w-10 text-white opacity-80" />;
    }

    return <div className={badgeClasses}>{networkName}</div>;
  };

  return (
    <div className={cn(
      "rounded-xl w-full h-[200px] p-6 text-white relative overflow-hidden shadow-lg",
      getCardBackground()
    )}>
      {/* Card Network Logo */}
      {paymentMethod.type === 'credit_card' && (
        <div className="absolute top-4 right-4">
          <CardNetworkBadge />
        </div>
      )}
      
      {/* Card Type Icon (for cash) */}
      {paymentMethod.type === 'cash' && (
        <div className="absolute top-4 right-4">
          <BanknoteIcon className="h-10 w-10 opacity-80" />
        </div>
      )}
      
      {/* Current Balance Label */}
      <div className="text-sm text-white/80">Current Balance</div>
      
      {/* Balance Amount */}
      <div className="text-2xl font-bold mt-1">
        {formatCurrency(currentBalance, paymentMethod.currency)}
      </div>
      
      {/* Card Details */}
      <div className="absolute bottom-6 left-6 right-6">
        {paymentMethod.type === 'credit_card' ? (
          <>
            <div className="flex justify-between items-center mb-2">
              <div className="flex items-center">
                <div className="mr-2">
                  {Array(4).fill('').join(' ')}
                </div>
                {paymentMethod.lastFourDigits && (
                  <div className="font-mono">{paymentMethod.lastFourDigits}</div>
                )}
              </div>
              
              {/* Expiry date placeholder - replace with actual data if available */}
              <div className="font-mono text-sm">MM/YY</div>
            </div>
            
            {/* Card name */}
            <div className="text-sm font-medium truncate">
              {`${paymentMethod.issuer || ''} ${paymentMethod.name}`}
            </div>
          </>
        ) : (
          <div className="text-sm font-medium">
            {`${paymentMethod.name} (${paymentMethod.currency})`}
          </div>
        )}
      </div>
      
      {/* Background pattern/design */}
      <div className="absolute inset-0 z-0 overflow-hidden opacity-10">
        <div className="absolute -right-20 -top-20 rounded-full w-80 h-80 bg-white/20"></div>
        <div className="absolute -left-20 -bottom-20 rounded-full w-80 h-80 bg-white/10"></div>
      </div>
      
      {/* Custom image overlay if available */}
      {paymentMethod.imageUrl && (
        <div className="absolute inset-0 flex items-center justify-center">
          <img 
            src={paymentMethod.imageUrl} 
            alt={paymentMethod.name}
            className="object-contain w-full h-full opacity-60 mix-blend-overlay"
          />
        </div>
      )}
      
      {/* Inactive overlay */}
      {!paymentMethod.active && (
        <div className="absolute inset-0 bg-gray-900/60 backdrop-blur-sm flex items-center justify-center">
          <div className="bg-white/20 px-4 py-2 rounded-full text-white font-bold rotate-[-15deg]">
            Inactive
          </div>
        </div>
      )}
    </div>
  );
};

================
File: components/payment-method/PaymentCarousel.tsx
================
import React from 'react';
import { PaymentMethod } from '@/types';
import Flicking from "@egjs/react-flicking";
import "@egjs/react-flicking/dist/flicking.css";
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import { PaymentCardFace } from './PaymentCardFace';

interface PaymentCarouselProps {
  paymentMethods: PaymentMethod[];
  selectedMethod: PaymentMethod | null;
  onSelectMethod: (method: PaymentMethod) => void;
}

export const PaymentCarousel: React.FC<PaymentCarouselProps> = ({
  paymentMethods,
  selectedMethod,
  onSelectMethod
}) => {
  const flickingRef = React.useRef<Flicking | null>(null);
  const [activeIndex, setActiveIndex] = React.useState(0);
  const [showLeftArrow, setShowLeftArrow] = React.useState(false);
  const [showRightArrow, setShowRightArrow] = React.useState(true);

  React.useEffect(() => {
    if (selectedMethod && flickingRef.current) {
      const index = paymentMethods.findIndex(m => m.id === selectedMethod.id);
      if (index >= 0 && index !== activeIndex) {
        flickingRef.current.moveTo(index);
      }
    }
  }, [selectedMethod, paymentMethods, activeIndex]);

  const handlePrev = () => {
    flickingRef.current?.prev();
  };

  const handleNext = () => {
    flickingRef.current?.next();
  };

  const handleChange = (e: any) => {
    const index = e.index;
    setActiveIndex(index);
    onSelectMethod(paymentMethods[index]);
    
    // Update arrow visibility
    if (flickingRef.current) {
      setShowLeftArrow(index > 0);
      setShowRightArrow(index < paymentMethods.length - 1);
    }
  };

  return (
    <div className="relative py-4">
      {showLeftArrow && (
        <Button 
          variant="outline" 
          size="icon"
          className="absolute left-0 top-1/2 -translate-y-1/2 z-10 rounded-full shadow-md bg-background/80 backdrop-blur-sm"
          onClick={handlePrev}
        >
          <ChevronLeft className="h-5 w-5" />
        </Button>
      )}
      
      <Flicking
        ref={flickingRef}
        className="overflow-visible"
        align="prev"
        onChanged={handleChange}
        circular={false}
        gap={20}
        bound={true}
      >
        {paymentMethods.map((method) => (
          <div 
            key={method.id}
            className={cn(
              "min-w-[300px] sm:min-w-[340px] transition-all duration-300",
              method.id === selectedMethod?.id ? "scale-105" : "scale-95 opacity-70",
              !method.active && "opacity-50"
            )}
            onClick={() => onSelectMethod(method)}
          >
            <PaymentCardFace paymentMethod={method} />
          </div>
        ))}
      </Flicking>

      {showRightArrow && (
        <Button 
          variant="outline" 
          size="icon"
          className="absolute right-0 top-1/2 -translate-y-1/2 z-10 rounded-full shadow-md bg-background/80 backdrop-blur-sm"
          onClick={handleNext}
        >
          <ChevronRight className="h-5 w-5" />
        </Button>
      )}
    </div>
  );
};

================
File: components/payment-method/PaymentFunctionsList.tsx
================
import React, { useState } from 'react';
import { PaymentMethod, Transaction } from '@/types';
import { 
  ToggleLeftIcon, 
  ToggleRightIcon, 
  EditIcon, 
  ImageIcon, 
  ShieldIcon, 
  CreditCardIcon,
  BanknoteIcon,
  CalendarIcon,
  CoinsIcon,
  ChevronRightIcon
} from 'lucide-react';
import { 
  Dialog, 
  DialogContent, 
  DialogHeader, 
  DialogTitle 
} from '@/components/ui/dialog';
import { RewardRuleManager } from '@/components/rewards/RewardRuleManager';
import { formatCurrency } from '@/utils/currencyFormatter';
import { Button } from '@/components/ui/button';
import { useTransactionsQuery } from '@/hooks/queries/useTransactionsQuery';
import { Separator } from '@/components/ui/separator';
import { 
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger
} from '@/components/ui/accordion';

interface PaymentFunctionsListProps {
  paymentMethod: PaymentMethod;
  onToggleActive: (id: string) => void;
  onEdit: (method: PaymentMethod) => void;
  onImageUpload: (method: PaymentMethod) => void;
}

export const PaymentFunctionsList: React.FC<PaymentFunctionsListProps> = ({
  paymentMethod,
  onToggleActive,
  onEdit,
  onImageUpload
}) => {
  const [isRulesDialogOpen, setIsRulesDialogOpen] = useState(false);
  const { data: allTransactions = [] } = useTransactionsQuery();
  
  // Filter transactions for this payment method
  const paymentMethodTransactions = allTransactions.filter(tx => 
    tx.paymentMethod.id === paymentMethod.id && !tx.is_deleted
  );

  // Calculate total spent with this payment method
  const totalSpent = paymentMethodTransactions.reduce((total, tx) => total + tx.paymentAmount, 0);
  
  // Calculate total reward points earned
  const totalRewardPoints = paymentMethodTransactions.reduce((total, tx) => total + (tx.rewardPoints || 0), 0);

  // Determine card type ID based on payment method
  const getCardTypeId = (): string => {
    if (paymentMethod.issuer && paymentMethod.name) {
      // Create a normalized ID format similar to that used in CardRegistry
      return `${paymentMethod.issuer.toLowerCase()}-${paymentMethod.name.toLowerCase().replace(/\s+/g, '-')}`;
    }
    return paymentMethod.id;
  };

  return (
    <div className="space-y-6">
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-2">
        <h2 className="text-xl font-semibold flex items-center">
          {paymentMethod.type === 'credit_card' ? (
            <CreditCardIcon className="h-5 w-5 mr-2 text-primary/70" />
          ) : (
            <BanknoteIcon className="h-5 w-5 mr-2 text-primary/70" />
          )}
          {paymentMethod.type === 'credit_card' 
            ? `${paymentMethod.issuer} ${paymentMethod.name}` 
            : paymentMethod.name
          }
        </h2>
        
        <Button 
          variant={paymentMethod.active ? "default" : "outline"} 
          size="sm"
          className="mt-2 sm:mt-0"
          onClick={() => onToggleActive(paymentMethod.id)}
        >
          {paymentMethod.active ? (
            <ToggleRightIcon className="h-4 w-4 mr-2 text-green-500" />
          ) : (
            <ToggleLeftIcon className="h-4 w-4 mr-2" />
          )}
          {paymentMethod.active ? "Active" : "Inactive"}
        </Button>
      </div>
      
      <Separator />

      {/* Stats summary */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div className="bg-muted/40 rounded-lg p-4">
          <h3 className="text-sm text-muted-foreground mb-1">Total Spent</h3>
          <p className="text-xl font-semibold">{formatCurrency(totalSpent, paymentMethod.currency)}</p>
          <p className="text-xs text-muted-foreground mt-1">{paymentMethodTransactions.length} transactions</p>
        </div>
        
        {paymentMethod.type === 'credit_card' && (
          <div className="bg-muted/40 rounded-lg p-4">
            <h3 className="text-sm text-muted-foreground mb-1">Reward Points</h3>
            <p className="text-xl font-semibold">{totalRewardPoints.toLocaleString()}</p>
            <p className="text-xs text-muted-foreground mt-1">Total earned points</p>
          </div>
        )}
        
        <div className="bg-muted/40 rounded-lg p-4">
          <h3 className="text-sm text-muted-foreground mb-1">Statement Cycle</h3>
          <p className="text-xl font-semibold">
            {paymentMethod.type === 'credit_card' && paymentMethod.statementStartDay 
              ? `Day ${paymentMethod.statementStartDay}` 
              : 'Calendar Month'}
          </p>
          <p className="text-xs text-muted-foreground mt-1">Billing cycle</p>
        </div>
      </div>

      {/* Functions list */}
      <div className="bg-card rounded-lg shadow-sm border">
        <div className="divide-y">
          {/* Edit payment method */}
          <div className="p-4 hover:bg-muted/50 transition-colors cursor-pointer" 
               onClick={() => onEdit(paymentMethod)}>
            <div className="flex justify-between items-center">
              <div className="flex items-center">
                <EditIcon className="h-4 w-4 mr-3 text-muted-foreground" />
                <div>
                  <h3 className="font-medium">Edit Payment Method</h3>
                  <p className="text-sm text-muted-foreground">Update name, currency, and other details</p>
                </div>
              </div>
              <ChevronRightIcon className="h-5 w-5 text-muted-foreground" />
            </div>
          </div>

          {/* Upload card image - only for credit cards */}
          {paymentMethod.type === 'credit_card' && (
            <div className="p-4 hover:bg-muted/50 transition-colors cursor-pointer"
                 onClick={() => onImageUpload(paymentMethod)}>
              <div className="flex justify-between items-center">
                <div className="flex items-center">
                  <ImageIcon className="h-4 w-4 mr-3 text-muted-foreground" />
                  <div>
                    <h3 className="font-medium">Upload Card Image</h3>
                    <p className="text-sm text-muted-foreground">
                      {paymentMethod.imageUrl ? "Change card image" : "Add an image of your card"}
                    </p>
                  </div>
                </div>
                <ChevronRightIcon className="h-5 w-5 text-muted-foreground" />
              </div>
            </div>
          )}
          
          {/* Statement details */}
          {paymentMethod.type === 'credit_card' && (
            <div className="p-4 hover:bg-muted/50 transition-colors">
              <div className="flex justify-between items-center">
                <div className="flex items-center">
                  <CalendarIcon className="h-4 w-4 mr-3 text-muted-foreground" />
                  <div>
                    <h3 className="font-medium">Statement Details</h3>
                    <p className="text-sm text-muted-foreground">
                      {paymentMethod.statementStartDay 
                        ? `Statement starts on day ${paymentMethod.statementStartDay} of each month` 
                        : 'Calendar month billing cycle'}
                    </p>
                  </div>
                </div>
              </div>
            </div>
          )}
          
          {/* Manage reward rules - only for credit cards */}
          {paymentMethod.type === 'credit_card' && (
            <div className="p-4 hover:bg-muted/50 transition-colors cursor-pointer"
                 onClick={() => setIsRulesDialogOpen(true)}>
              <div className="flex justify-between items-center">
                <div className="flex items-center">
                  <ShieldIcon className="h-4 w-4 mr-3 text-muted-foreground" />
                  <div>
                    <h3 className="font-medium">Manage Reward Rules</h3>
                    <p className="text-sm text-muted-foreground">
                      {paymentMethod.rewardRules && paymentMethod.rewardRules.length > 0
                        ? `${paymentMethod.rewardRules.length} rules configured` 
                        : 'No reward rules configured'}
                    </p>
                  </div>
                </div>
                <ChevronRightIcon className="h-5 w-5 text-muted-foreground" />
              </div>
            </div>
          )}
        </div>
      </div>
      
      {/* Reward rules section */}
      {paymentMethod.type === 'credit_card' && paymentMethod.rewardRules && paymentMethod.rewardRules.length > 0 && (
        <Accordion type="single" collapsible className="bg-card rounded-lg shadow-sm border">
          <AccordionItem value="reward-rules">
            <AccordionTrigger className="px-4 py-3">
              <div className="flex items-center">
                <CoinsIcon className="h-4 w-4 mr-2 text-amber-500" />
                <span className="font-medium">Reward Rules</span>
              </div>
            </AccordionTrigger>
            <AccordionContent className="px-4 pb-4">
              <div className="space-y-3">
                {paymentMethod.rewardRules.map((rule) => (
                  <div key={rule.id} className="bg-muted/50 p-3 rounded-md">
                    <h4 className="font-medium">{rule.name}</h4>
                    <p className="text-sm text-muted-foreground">{rule.description}</p>
                    <div className="mt-2 flex flex-wrap gap-2">
                      <span className="bg-primary/10 text-primary text-xs px-2 py-1 rounded-full">
                        {rule.pointsMultiplier}x Points
                      </span>
                      <span className="bg-muted text-muted-foreground text-xs px-2 py-1 rounded-full">
                        {typeof rule.condition === 'string' ? rule.condition : rule.type}
                      </span>
                      {rule.maxSpend && (
                        <span className="bg-muted text-muted-foreground text-xs px-2 py-1 rounded-full">
                          Cap: {formatCurrency(rule.maxSpend, paymentMethod.currency)}
                        </span>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </AccordionContent>
          </AccordionItem>
        </Accordion>
      )}
      
      {/* Rules Dialog */}
      <Dialog open={isRulesDialogOpen} onOpenChange={setIsRulesDialogOpen}>
        <DialogContent className="max-w-3xl max-h-[80vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>
              Manage Reward Rules for {paymentMethod.issuer} {paymentMethod.name}
            </DialogTitle>
          </DialogHeader>
          
          <RewardRuleManager cardTypeId={getCardTypeId()} />
        </DialogContent>
      </Dialog>
    </div>
  );
};

================
File: components/payment-method/PaymentMethodCard.tsx
================
import React, { useState } from 'react';
import { PaymentMethod } from '@/types';
import { ToggleLeftIcon, ToggleRightIcon, EditIcon, ImageIcon, ShieldIcon } from 'lucide-react';
import { CreditCardIcon, BanknoteIcon, CalendarIcon, CoinsIcon } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter } from '@/components/ui/card';
import { 
  Dialog, 
  DialogContent, 
  DialogHeader, 
  DialogTitle 
} from '@/components/ui/dialog';
import { cn } from '@/lib/utils';
import PaymentCardDisplay from '../expense/PaymentCardDisplay';
import { RewardRuleManager } from '@/components/rewards/RewardRuleManager';
import RewardRuleBadge from './RewardRuleBadge';

interface PaymentMethodCardProps {
  method: PaymentMethod;
  onToggleActive: (id: string) => void;
  onEdit: (method: PaymentMethod) => void;
  onImageUpload: (method: PaymentMethod) => void;
}

const PaymentMethodCard: React.FC<PaymentMethodCardProps> = ({ 
  method, 
  onToggleActive, 
  onEdit,
  onImageUpload
}) => {
  const [isRulesDialogOpen, setIsRulesDialogOpen] = useState(false);
  
  const icon = method.type === 'credit_card' ? 
    <CreditCardIcon className="h-5 w-5" style={{ color: method.color }} /> : 
    <BanknoteIcon className="h-5 w-5" style={{ color: method.color }} />;

  // Determine card type ID based on payment method
  const getCardTypeId = (): string => {
    if (method.issuer && method.name) {
      // Create a normalized ID format similar to that used in CardRegistry
      return `${method.issuer.toLowerCase()}-${method.name.toLowerCase().replace(/\s+/g, '-')}`;
    }
    return method.id;
  };

  return (
    <Card className={cn(
      "overflow-hidden transition-all duration-300",
      !method.active && "opacity-70"
    )}>
      <CardHeader className="pb-2">
        <div className="flex justify-between items-start">
          <div className="flex items-center gap-2">
            <div className="p-2 rounded-full" style={{ backgroundColor: `${method.color}20` }}>
              {icon}
            </div>
            <div>
              <CardTitle className="text-lg">{method.name}</CardTitle>
              <CardDescription>
                {method.type === 'credit_card' 
                  ? `${method.issuer} ${method.lastFourDigits ? ` ${method.lastFourDigits}` : ''}`
                  : `${method.currency}`
                }
              </CardDescription>
            </div>
          </div>
          <div className="flex">
            <Button 
              variant="ghost" 
              size="icon" 
              onClick={() => onToggleActive(method.id)}
              title={method.active ? "Deactivate" : "Activate"}
            >
              {method.active ? (
                <ToggleRightIcon className="h-5 w-5 text-green-500" />
              ) : (
                <ToggleLeftIcon className="h-5 w-5 text-gray-400" />
              )}
            </Button>
            <Button 
              variant="ghost" 
              size="icon" 
              onClick={() => onEdit(method)}
              title="Edit"
            >
              <EditIcon className="h-4 w-4" />
            </Button>
            {method.type === 'credit_card' && (
              <Button
                variant="ghost"
                size="icon"
                onClick={() => onImageUpload(method)}
                title="Upload Card Image"
              >
                <ImageIcon className="h-4 w-4" />
              </Button>
            )}
          </div>
        </div>
      </CardHeader>
      <CardContent className="pt-2">
        {method.type === 'credit_card' && (
          <>
            {method.imageUrl && (
              <div className="mb-3 max-w-[180px]">
                <PaymentCardDisplay 
                  paymentMethod={method} 
                  customImage={method.imageUrl} 
                />
              </div>
            )}
            <div className="flex items-center text-sm">
              <CalendarIcon className="h-4 w-4 mr-2 text-gray-500" />
              <span>
                {method.statementStartDay 
                  ? `Statement Cycle: Day ${method.statementStartDay}` 
                  : 'Calendar Month'}
              </span>
            </div>
            
            <div className="flex items-center text-sm mt-1">
              <CoinsIcon className="h-4 w-4 mr-2 text-amber-500" />
              <span>
                {method.rewardRules && method.rewardRules.length 
                  ? `${method.rewardRules.length} Reward Rules` 
                  : 'No rewards configured'}
              </span>
            </div>
            
            {method.rewardRules && method.rewardRules.length > 0 && (
              <div className="mt-3 flex flex-wrap gap-2">
                {method.rewardRules.slice(0, 2).map((rule) => (
                  <RewardRuleBadge key={rule.id} rule={rule} />
                ))}
                {method.rewardRules.length > 2 && (
                  <span className="text-xs text-gray-500 self-center">
                    +{method.rewardRules.length - 2} more
                  </span>
                )}
              </div>
            )}
          </>
        )}
      </CardContent>
      
      {method.type === 'credit_card' && (
        <CardFooter>
          <Button
            variant="outline"
            size="sm"
            className="w-full"
            onClick={() => setIsRulesDialogOpen(true)}
          >
            <ShieldIcon className="h-4 w-4 mr-2" />
            Manage Reward Rules
          </Button>
          
          {/* Rules Dialog */}
          <Dialog open={isRulesDialogOpen} onOpenChange={setIsRulesDialogOpen}>
            <DialogContent className="max-w-3xl max-h-[80vh] overflow-y-auto">
              <DialogHeader>
                <DialogTitle>
                  Manage Reward Rules for {method.issuer} {method.name}
                </DialogTitle>
              </DialogHeader>
              
              <RewardRuleManager cardTypeId={getCardTypeId()} />
            </DialogContent>
          </Dialog>
        </CardFooter>
      )}
    </Card>
  );
};

export default PaymentMethodCard;

================
File: components/payment-method/PaymentMethodForm.tsx
================
import React, { useState } from "react";
import { PaymentMethod, Currency } from "@/types";
import { CurrencyService } from "@/services/CurrencyService";
import { v4 as uuidv4 } from "uuid";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Button } from "@/components/ui/button";

interface PaymentMethodFormProps {
  currentMethod: PaymentMethod | null;
  isEditing: boolean;
  isLoading: boolean;
  onClose: () => void;
  onSubmit: (event: React.FormEvent<HTMLFormElement>) => void;
  isOpen: boolean; // Add this prop to control the dialog open state
}

const currencyOptions = CurrencyService.getCurrencyOptions();

const PaymentMethodForm: React.FC<PaymentMethodFormProps> = ({
  currentMethod,
  isEditing,
  isLoading,
  onClose,
  onSubmit,
  isOpen, // Use this prop to control the dialog
}) => {
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>
            {isEditing ? "Edit Payment Method" : "Add Payment Method"}
          </DialogTitle>
          <DialogDescription>
            {isEditing
              ? "Update the details of your payment method"
              : "Add a new payment method for tracking expenses"}
          </DialogDescription>
        </DialogHeader>

        <form onSubmit={onSubmit}>
          <div className="space-y-4 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="name" className="text-right">
                Name
              </Label>
              <Input
                id="name"
                name="name"
                placeholder="e.g. Chase Sapphire"
                className="col-span-3"
                defaultValue={currentMethod?.name || ""}
                required
              />
            </div>

            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="type" className="text-right">
                Type
              </Label>
              <Select
                name="type"
                defaultValue={currentMethod?.type || "credit_card"}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder="Select payment type" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="credit_card">Credit Card</SelectItem>
                  <SelectItem value="cash">Cash</SelectItem>
                </SelectContent>
              </Select>
            </div>

            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="currency" className="text-right">
                Currency
              </Label>
              <Select
                name="currency"
                defaultValue={currentMethod?.currency || "USD"}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder="Select currency" />
                </SelectTrigger>
                <SelectContent>
                  {currencyOptions.map((option) => (
                    <SelectItem key={option.value} value={option.value}>
                      {option.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            {currentMethod?.type === "credit_card" || !currentMethod ? (
              <>
                <div className="grid grid-cols-4 items-center gap-4">
                  <Label htmlFor="issuer" className="text-right">
                    Issuer
                  </Label>
                  <Input
                    id="issuer"
                    name="issuer"
                    placeholder="e.g. Chase, Amex"
                    className="col-span-3"
                    defaultValue={currentMethod?.issuer || ""}
                  />
                </div>

                <div className="grid grid-cols-4 items-center gap-4">
                  <Label htmlFor="lastFourDigits" className="text-right">
                    Last 4 Digits
                  </Label>
                  <Input
                    id="lastFourDigits"
                    name="lastFourDigits"
                    placeholder="e.g. 1234"
                    className="col-span-3"
                    maxLength={4}
                    defaultValue={currentMethod?.lastFourDigits || ""}
                  />
                </div>

                <div className="grid grid-cols-4 items-center gap-4">
                  <Label htmlFor="statementStartDay" className="text-right">
                    Statement Day
                  </Label>
                  <Input
                    id="statementStartDay"
                    name="statementStartDay"
                    type="number"
                    min="1"
                    max="31"
                    placeholder="e.g. 15"
                    className="col-span-3"
                    defaultValue={
                      currentMethod?.statementStartDay?.toString() || ""
                    }
                  />
                </div>

                <div className="grid grid-cols-4 items-center gap-4">
                  <Label className="text-right">Statement Type</Label>
                  <div className="col-span-3 flex items-center space-x-2">
                    <Switch
                      id="isMonthlyStatement"
                      name="isMonthlyStatement"
                      defaultChecked={currentMethod?.isMonthlyStatement}
                    />
                    <Label htmlFor="isMonthlyStatement">
                      Use statement month (instead of calendar month)
                    </Label>
                  </div>
                </div>
              </>
            ) : null}

            <div className="grid grid-cols-4 items-center gap-4">
              <Label className="text-right">Status</Label>
              <div className="col-span-3 flex items-center space-x-2">
                <Switch
                  id="active"
                  name="active"
                  defaultChecked={currentMethod?.active ?? true}
                />
                <Label htmlFor="active">Active</Label>
              </div>
            </div>
          </div>

          <DialogFooter>
            <Button type="button" variant="outline" onClick={onClose}>
              Cancel
            </Button>
            <Button type="submit" disabled={isLoading}>
              {isLoading ? "Saving..." : isEditing ? "Update" : "Add"}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
};

export default PaymentMethodForm;

================
File: components/payment-method/RewardRuleBadge.tsx
================
import { RewardRule } from '@/types';
import { cn } from '@/lib/utils';

interface RewardRuleBadgeProps {
  rule: RewardRule;
  variant?: 'default' | 'compact' | 'detailed';
  className?: string;
}

const RewardRuleBadge = ({ rule, variant = 'default', className }: RewardRuleBadgeProps) => {
  // Format the condition for display
  const formatCondition = (condition: string | string[]): string => {
    if (typeof condition === 'string') {
      return condition;
    }
    
    // If it's an array with more than 3 items, show a summary
    if (condition.length > 3) {
      return `${condition.length} categories`;
    }
    
    return condition.join(', ');
  };

  if (variant === 'compact') {
    return (
      <div 
        className={cn(
          "text-xs px-2 py-1 rounded-full bg-blue-50 dark:bg-blue-900/20 text-blue-600 dark:text-blue-300",
          className
        )}
      >
        {rule.name}
      </div>
    );
  }

  if (variant === 'detailed') {
    return (
      <div className={cn("space-y-1 p-3 rounded-md bg-blue-50 dark:bg-blue-900/20", className)}>
        <div className="font-medium text-sm text-blue-700 dark:text-blue-300">{rule.name}</div>
        <div className="text-xs text-blue-600/80 dark:text-blue-400/80">{rule.description}</div>
        {rule.pointsMultiplier && (
          <div className="text-xs font-medium text-green-600 dark:text-green-400">
            {rule.pointsMultiplier}x multiplier
          </div>
        )}
        {rule.maxSpend && (
          <div className="text-xs text-slate-500 dark:text-slate-400">
            Monthly cap: {rule.maxSpend} points
          </div>
        )}
      </div>
    );
  }

  // Default variant
  return (
    <div 
      className={cn(
        "text-xs px-3 py-1.5 rounded-full bg-blue-50 dark:bg-blue-900/20 text-blue-600 dark:text-blue-300",
        className
      )}
      title={rule.description}
    >
      {rule.name}
      {rule.pointsMultiplier && (
        <span className="ml-1 font-medium text-green-600 dark:text-green-400">
          {rule.pointsMultiplier}x
        </span>
      )}
    </div>
  );
};

export default RewardRuleBadge;

================
File: components/payment-method/RewardRuleEditDialog.tsx
================
import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Checkbox } from '@/components/ui/checkbox';
import { useToast } from '@/hooks/use-toast';

export interface RewardRuleFormData {
  id?: string;
  name: string;
  description: string;
  enabled: boolean;
  basePointRate: number;
  bonusPointRate: number;
  monthlyCap: number;
  isOnlineOnly: boolean;
  isContactlessOnly: boolean;
  isForeignCurrency: boolean;
  includedMCCs: string[];
  excludedMCCs: string[];
}

interface RewardRuleEditDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  initialData?: Partial<RewardRuleFormData>;
  onSave: (data: RewardRuleFormData) => void;
  title?: string;
}

const defaultFormData: RewardRuleFormData = {
  name: '',
  description: '',
  enabled: true,
  basePointRate: 0.4,
  bonusPointRate: 0,
  monthlyCap: 0,
  isOnlineOnly: false,
  isContactlessOnly: false,
  isForeignCurrency: false,
  includedMCCs: [],
  excludedMCCs: []
};

const RewardRuleEditDialog: React.FC<RewardRuleEditDialogProps> = ({
  open,
  onOpenChange,
  initialData,
  onSave,
  title = 'Edit Reward Rule'
}) => {
  const [formData, setFormData] = useState<RewardRuleFormData>({
    ...defaultFormData,
    ...initialData
  });
  const [newMCC, setNewMCC] = useState('');
  const { toast } = useToast();

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleNumberChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: Number(value) || 0 }));
  };

  const handleCheckboxChange = (name: string, checked: boolean) => {
    setFormData(prev => ({ ...prev, [name]: checked }));
  };

  const handleMCCAdd = () => {
    if (newMCC.trim() && !formData.includedMCCs.includes(newMCC.trim())) {
      setFormData(prev => ({
        ...prev,
        includedMCCs: [...prev.includedMCCs, newMCC.trim()]
      }));
      setNewMCC('');
    }
  };

  const handleMCCRemove = (mcc: string) => {
    setFormData(prev => ({
      ...prev,
      includedMCCs: prev.includedMCCs.filter(m => m !== mcc)
    }));
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!formData.name.trim()) {
      toast({
        title: "Error",
        description: "Rule name is required",
        variant: "destructive"
      });
      return;
    }
    
    onSave(formData);
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="bg-gray-900 text-white border-gray-800 max-w-lg">
        <DialogHeader>
          <DialogTitle>{title}</DialogTitle>
        </DialogHeader>
        
        <form onSubmit={handleSubmit} className="space-y-6 py-4">
          <div className="space-y-4">
            <div>
              <Label htmlFor="name" className="text-white">Rule Name</Label>
              <Input
                id="name"
                name="name"
                value={formData.name}
                onChange={handleInputChange}
                className="mt-1.5 bg-white border-gray-300 font-medium"
                style={{ color: '#000000' }}
                placeholder="e.g. Grocery Bonus"
              />
            </div>
            
            <div>
              <Label htmlFor="description" className="text-white">Description</Label>
              <Textarea
                id="description"
                name="description"
                value={formData.description}
                onChange={handleInputChange}
                className="mt-1.5 bg-white border-gray-300 font-medium"
                style={{ color: '#000000' }}
                placeholder="e.g. 6% back at U.S. supermarkets"
              />
            </div>
            
            <div className="flex items-center space-x-2">
              <Checkbox
                id="enabled"
                checked={formData.enabled}
                onCheckedChange={(checked) => handleCheckboxChange('enabled', checked as boolean)}
              />
              <Label htmlFor="enabled" className="text-white">Enabled</Label>
            </div>
          </div>
          
          <div>
            <h3 className="text-lg font-medium text-white mb-3">Points Configuration</h3>
            <div className="space-y-4">
              <div>
                <Label htmlFor="basePointRate" className="text-white">
                  Base Point Rate (per $1)
                </Label>
                <Input
                  id="basePointRate"
                  name="basePointRate"
                  type="number"
                  step="0.1"
                  value={formData.basePointRate}
                  onChange={handleNumberChange}
                  className="mt-1.5 bg-white border-gray-300 font-medium"
                  style={{ color: '#000000' }}
                />
              </div>
              
              <div>
                <Label htmlFor="bonusPointRate" className="text-white">
                  Bonus Point Rate (per $1)
                </Label>
                <Input
                  id="bonusPointRate"
                  name="bonusPointRate"
                  type="number"
                  step="0.1"
                  value={formData.bonusPointRate}
                  onChange={handleNumberChange}
                  className="mt-1.5 bg-white border-gray-300 font-medium"
                  style={{ color: '#000000' }}
                />
              </div>
              
              <div>
                <Label htmlFor="monthlyCap" className="text-white">
                  Monthly Bonus Points Cap
                </Label>
                <Input
                  id="monthlyCap"
                  name="monthlyCap"
                  type="number"
                  value={formData.monthlyCap}
                  onChange={handleNumberChange}
                  className="mt-1.5 bg-white border-gray-300 font-medium"
                  style={{ color: '#000000' }}
                />
              </div>
            </div>
          </div>
          
          <div>
            <h3 className="text-lg font-medium text-white mb-3">Eligibility Criteria</h3>
            <div className="space-y-3">
              <div className="flex items-center space-x-2">
                <Checkbox
                  id="isOnlineOnly"
                  checked={formData.isOnlineOnly}
                  onCheckedChange={(checked) => handleCheckboxChange('isOnlineOnly', checked as boolean)}
                />
                <Label htmlFor="isOnlineOnly" className="text-white">Online Transactions Only</Label>
              </div>
              
              <div className="flex items-center space-x-2">
                <Checkbox
                  id="isContactlessOnly"
                  checked={formData.isContactlessOnly}
                  onCheckedChange={(checked) => handleCheckboxChange('isContactlessOnly', checked as boolean)}
                />
                <Label htmlFor="isContactlessOnly" className="text-white">Contactless Payments Only</Label>
              </div>
              
              <div className="flex items-center space-x-2">
                <Checkbox
                  id="isForeignCurrency"
                  checked={formData.isForeignCurrency}
                  onCheckedChange={(checked) => handleCheckboxChange('isForeignCurrency', checked as boolean)}
                />
                <Label htmlFor="isForeignCurrency" className="text-white">Foreign Currency Transactions Only</Label>
              </div>
            </div>
          </div>
          
          <div>
            <h3 className="text-lg font-medium text-white mb-3">Merchant Category Codes (MCCs)</h3>
            <div className="space-y-3">
              <div className="flex items-center gap-2">
                <Input
                  id="newMCC"
                  value={newMCC}
                  onChange={(e) => setNewMCC(e.target.value)}
                  className="bg-white border-gray-300 font-medium"
                  style={{ color: '#000000' }}
                  placeholder="Enter MCC code"
                />
                <Button 
                  type="button" 
                  onClick={handleMCCAdd}
                  variant="outline"
                >
                  Add
                </Button>
              </div>
              
              {formData.includedMCCs.length > 0 ? (
                <div className="flex flex-wrap gap-2 mt-2">
                  {formData.includedMCCs.map(mcc => (
                    <div 
                      key={mcc} 
                      className="bg-blue-900 text-white text-xs rounded-full px-2.5 py-1 flex items-center"
                    >
                      <span>{mcc}</span>
                      <button
                        type="button"
                        className="ml-1.5 text-white/70 hover:text-white"
                        onClick={() => handleMCCRemove(mcc)}
                      >
                        
                      </button>
                    </div>
                  ))}
                </div>
              ) : (
                <p className="text-gray-400 text-sm">No MCCs added yet</p>
              )}
            </div>
          </div>
          
          <DialogFooter className="pt-2">
            <Button
              type="button"
              variant="outline"
              onClick={() => onOpenChange(false)}
              className="border-gray-700 text-white"
            >
              Cancel
            </Button>
            <Button type="submit" className="bg-blue-600 hover:bg-blue-700">
              Save Changes
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
};

export default RewardRuleEditDialog;

================
File: components/rewards/BonusTierEditor.tsx
================
// components/rewards/BonusTierEditor.tsx
import React, { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardFooter } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Trash, Edit } from 'lucide-react';
import { BonusTier, RuleCondition } from '@/services/rewards/types';
import { ConditionEditor } from './ConditionEditor';

interface BonusTierEditorProps {
  tier: BonusTier;
  onChange: (tier: BonusTier) => void;
  onDelete: () => void;
}

export const BonusTierEditor: React.FC<BonusTierEditorProps> = ({
  tier,
  onChange,
  onDelete
}) => {
  const [isEditing, setIsEditing] = useState(false);
  
  // Handle tier name change
  const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onChange({
      ...tier,
      name: e.target.value
    });
  };
  
  // Handle tier multiplier change
  const handleMultiplierChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = parseFloat(e.target.value);
    if (isNaN(value)) return;
    
    onChange({
      ...tier,
      multiplier: value
    });
  };
  
  // Handle tier priority change
  const handlePriorityChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = parseInt(e.target.value);
    if (isNaN(value)) return;
    
    onChange({
      ...tier,
      priority: value
    });
  };
  
  // Handle condition change
  const handleConditionChange = (condition: RuleCondition) => {
    onChange({
      ...tier,
      condition
    });
  };
  
  return (
    <Card>
      <CardHeader className="p-4 pb-2">
        <div className="flex justify-between items-center">
          {isEditing ? (
            <Input
              value={tier.name}
              onChange={handleNameChange}
              placeholder="Tier Name"
              className="font-semibold"
            />
          ) : (
            <CardTitle className="text-base">{tier.name}</CardTitle>
          )}
          <div className="flex space-x-1">
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => setIsEditing(!isEditing)}
              className="h-7 w-7 p-0"
            >
              <Edit size={16} />
            </Button>
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={onDelete}
              className="h-7 w-7 p-0"
            >
              <Trash size={16} />
            </Button>
          </div>
        </div>
      </CardHeader>
      <CardContent className="p-4 pt-0">
        <div className="space-y-3">
          {isEditing ? (
            <>
              <div>
                <Label htmlFor="multiplier" className="text-xs">Bonus Multiplier</Label>
                <Input
                  id="multiplier"
                  type="number"
                  step="0.1"
                  value={tier.multiplier}
                  onChange={handleMultiplierChange}
                  placeholder="e.g., 1.8 for 9x per $5"
                  className="h-8"
                />
              </div>
              <div>
                <Label htmlFor="priority" className="text-xs">Priority</Label>
                <Input
                  id="priority"
                  type="number"
                  value={tier.priority}
                  onChange={handlePriorityChange}
                  placeholder="Higher values take precedence"
                  className="h-8"
                />
              </div>
              <div>
                <Label className="text-xs">Condition</Label>
                <ConditionEditor
                  condition={tier.condition}
                  onChange={handleConditionChange}
                />
              </div>
            </>
          ) : (
            <>
              <div className="text-sm">
                <span className="font-medium">Multiplier:</span> {tier.multiplier}x
              </div>
              <div className="text-sm">
                <span className="font-medium">Priority:</span> {tier.priority}
              </div>
              <div>
                <span className="font-medium text-sm">Condition Type:</span>
                <div className="pl-2 mt-1 text-sm">
                  {tier.condition.type === 'compound' 
                    ? `Compound (${tier.condition.operation === 'all' ? 'AND' : 'OR'})` 
                    : tier.condition.type}
                </div>
              </div>
            </>
          )}
        </div>
      </CardContent>
    </Card>
  );
};

================
File: components/rewards/ConditionEditor.tsx
================
// components/rewards/ConditionEditor.tsx
import React, { useState } from 'react';
import { 
  Card,
  CardContent,
  CardHeader,
  CardTitle
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { 
  Select, 
  SelectContent, 
  SelectItem, 
  SelectTrigger, 
  SelectValue 
} from '@/components/ui/select';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { PlusCircle, Trash, ChevronDown, ChevronRight } from 'lucide-react';
import { RuleCondition, TransactionType } from '@/services/rewards/types';

interface ConditionEditorProps {
  condition: RuleCondition;
  onChange: (condition: RuleCondition) => void;
  onDelete?: () => void;
  isNested?: boolean;
}

export const ConditionEditor: React.FC<ConditionEditorProps> = ({
  condition,
  onChange,
  onDelete,
  isNested = false
}) => {
  const [expanded, setExpanded] = useState(!isNested);
  const [newValue, setNewValue] = useState('');
  
  // Handle condition type change
  const handleTypeChange = (type: string) => {
    let newCondition: RuleCondition;
    
    if (type === 'compound') {
      newCondition = {
        type: 'compound',
        operation: 'all',
        subConditions: []
      };
    } else {
      newCondition = {
        type: type as any,
        operation: 'equals',
        values: []
      };
    }
    
    onChange(newCondition);
  };
  
  // Handle operation change
  const handleOperationChange = (operation: string) => {
    onChange({
      ...condition,
      operation: operation as any
    });
  };
  
  // Handle value addition
  const handleAddValue = () => {
    if (!newValue.trim()) return;
    
    // Create a copy of values or initialize if undefined
    const newValues = [...(condition.values || [])];
    
    // Convert value based on condition type
    let valueToAdd: any = newValue;
    
    if (condition.type === 'mcc' || condition.type === 'currency' || 
        condition.type === 'merchant' || condition.type === 'category') {
      // String values
      valueToAdd = newValue;
    } else if (condition.type === 'amount' || condition.type === 'spend_threshold') {
      // Number values
      valueToAdd = parseFloat(newValue);
      if (isNaN(valueToAdd)) return;
    } else if (condition.type === 'transaction_type') {
      // Enum values
      valueToAdd = newValue as TransactionType;
    }
    
    // Add new value
    newValues.push(valueToAdd);
    
    // Update condition
    onChange({
      ...condition,
      values: newValues
    });
    
    // Clear input
    setNewValue('');
  };
  
  // Handle value removal
  const handleRemoveValue = (index: number) => {
    if (!condition.values) return;
    
    const newValues = [...condition.values];
    newValues.splice(index, 1);
    
    onChange({
      ...condition,
      values: newValues
    });
  };
  
  // Handle subCondition change
  const handleSubConditionChange = (index: number, subCondition: RuleCondition) => {
    if (!condition.subConditions) return;
    
    const newSubConditions = [...condition.subConditions];
    newSubConditions[index] = subCondition;
    
    onChange({
      ...condition,
      subConditions: newSubConditions
    });
  };
  
  // Handle adding a subCondition
  const handleAddSubCondition = () => {
    if (condition.type !== 'compound') return;
    
    const newSubConditions = [...(condition.subConditions || [])];
    
    newSubConditions.push({
      type: 'mcc',
      operation: 'include',
      values: []
    });
    
    onChange({
      ...condition,
      subConditions: newSubConditions
    });
  };
  
  // Handle removing a subCondition
  const handleRemoveSubCondition = (index: number) => {
    if (!condition.subConditions) return;
    
    const newSubConditions = [...condition.subConditions];
    newSubConditions.splice(index, 1);
    
    onChange({
      ...condition,
      subConditions: newSubConditions
    });
  };
  
  return (
    <Card className={isNested ? "border-dashed border-gray-300 mt-2" : ""}>
      <CardHeader className="p-3 flex flex-row items-center justify-between">
        <div className="flex items-center">
          {isNested && (
            <Button 
              type="button" 
              variant="ghost" 
              size="sm"
              onClick={() => setExpanded(!expanded)}
              className="p-0 h-6 w-6 mr-2"
            >
              {expanded ? <ChevronDown size={16} /> : <ChevronRight size={16} />}
            </Button>
          )}
          <CardTitle className="text-sm">
            {condition.type === 'compound' 
              ? `Group (${condition.operation === 'all' ? 'AND' : 'OR'})` 
              : condition.type.toUpperCase()}
          </CardTitle>
        </div>
        
        {onDelete && (
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={onDelete}
            className="p-1 h-7 w-7"
          >
            <Trash size={14} />
          </Button>
        )}
      </CardHeader>
      
      {(expanded || !isNested) && (
        <CardContent className="p-3 pt-0">
          <div className="space-y-3">
            {/* Condition Type */}
            <div>
              <Label htmlFor="conditionType" className="text-xs">Condition Type</Label>
              <Select
                value={condition.type}
                onValueChange={handleTypeChange}
              >
                <SelectTrigger id="conditionType" className="h-8">
                  <SelectValue placeholder="Select condition type" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="mcc">MCC Code</SelectItem>
                  <SelectItem value="merchant">Merchant Name</SelectItem>
                  <SelectItem value="transaction_type">Transaction Type</SelectItem>
                  <SelectItem value="currency">Currency</SelectItem>
                  <SelectItem value="amount">Amount</SelectItem>
                  <SelectItem value="category">Category</SelectItem>
                  <SelectItem value="spend_threshold">Spend Threshold</SelectItem>
                  <SelectItem value="compound">Compound (Group)</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            {/* Operation Selection */}
            {condition.type !== 'compound' ? (
              <div>
                <Label htmlFor="operation" className="text-xs">Operation</Label>
                <Select
                  value={condition.operation}
                  onValueChange={handleOperationChange}
                >
                  <SelectTrigger id="operation" className="h-8">
                    <SelectValue placeholder="Select operation" />
                  </SelectTrigger>
                  <SelectContent>
                    {condition.type === 'mcc' || condition.type === 'currency' || 
                    condition.type === 'category' || condition.type === 'merchant' ? (
                      <>
                        <SelectItem value="include">Include</SelectItem>
                        <SelectItem value="exclude">Exclude</SelectItem>
                        <SelectItem value="equals">Equals</SelectItem>
                      </>
                    ) : condition.type === 'amount' || condition.type === 'spend_threshold' ? (
                      <>
                        <SelectItem value="equals">Equals</SelectItem>
                        <SelectItem value="greater_than">Greater Than</SelectItem>
                        <SelectItem value="less_than">Less Than</SelectItem>
                        <SelectItem value="between">Between</SelectItem>
                      </>
                    ) : condition.type === 'transaction_type' ? (
                      <>
                        <SelectItem value="equals">Equals</SelectItem>
                        <SelectItem value="not_equals">Not Equals</SelectItem>
                      </>
                    ) : (
                      <SelectItem value="equals">Equals</SelectItem>
                    )}
                  </SelectContent>
                </Select>
              </div>
            ) : (
              <div>
                <Label htmlFor="compoundOperation" className="text-xs">Logic</Label>
                <RadioGroup
                  value={condition.operation}
                  onValueChange={handleOperationChange}
                  className="flex space-x-4"
                >
                  <div className="flex items-center space-x-1">
                    <RadioGroupItem value="all" id="all" />
                    <Label htmlFor="all" className="text-xs">AND (All conditions must match)</Label>
                  </div>
                  <div className="flex items-center space-x-1">
                    <RadioGroupItem value="any" id="any" />
                    <Label htmlFor="any" className="text-xs">OR (Any condition can match)</Label>
                  </div>
                </RadioGroup>
              </div>
            )}
            
            {/* Value Input (for non-compound conditions) */}
            {condition.type !== 'compound' && (
              <div>
                <Label htmlFor="conditionValue" className="text-xs">
                  {condition.type === 'transaction_type' ? 'Transaction Type' : 'Value'}
                </Label>
                
                {condition.type === 'transaction_type' ? (
                  <Select
                    value={newValue}
                    onValueChange={setNewValue}
                  >
                    <SelectTrigger id="transactionType" className="h-8">
                      <SelectValue placeholder="Select transaction type" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value={TransactionType.ONLINE}>Online</SelectItem>
                      <SelectItem value={TransactionType.CONTACTLESS}>Contactless</SelectItem>
                      <SelectItem value={TransactionType.IN_STORE}>In-Store</SelectItem>
                    </SelectContent>
                  </Select>
                ) : (
                  <div className="flex space-x-2">
                    <Input
                      id="conditionValue"
                      value={newValue}
                      onChange={(e) => setNewValue(e.target.value)}
                      placeholder={condition.type === 'amount' ? 'Enter amount' : 
                                  condition.type === 'mcc' ? 'Enter MCC code' :
                                  condition.type === 'merchant' ? 'Enter merchant name' :
                                  condition.type === 'currency' ? 'Enter currency code' :
                                  condition.type === 'category' ? 'Enter category' :
                                  'Enter value'}
                      className="h-8"
                    />
                    <Button
                      type="button"
                      size="sm"
                      onClick={handleAddValue}
                      className="h-8"
                    >
                      Add
                    </Button>
                  </div>
                )}
              </div>
            )}
            
            {/* Values Display */}
            {condition.type !== 'compound' && condition.values && condition.values.length > 0 && (
              <div>
                <Label className="text-xs">Current Values</Label>
                <div className="flex flex-wrap gap-1 p-2 border rounded-md">
                  {condition.values.map((value, index) => (
                    <div
                      key={index}
                      className="bg-blue-100 text-blue-800 px-2 py-0.5 rounded-full flex items-center"
                    >
                      <span className="text-xs">
                        {condition.type === 'transaction_type' 
                          ? (value === TransactionType.ONLINE 
                              ? 'Online' 
                              : value === TransactionType.CONTACTLESS 
                                ? 'Contactless' 
                                : 'In-Store')
                          : value.toString()}
                      </span>
                      <button
                        type="button"
                        className="ml-1 text-blue-600 hover:text-blue-800"
                        onClick={() => handleRemoveValue(index)}
                      >
                        
                      </button>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Sub-conditions (for compound conditions) */}
            {condition.type === 'compound' && (
              <div className="space-y-2">
                {condition.subConditions && condition.subConditions.length > 0 ? (
                  <div className="space-y-2">
                    {condition.subConditions.map((subCondition, index) => (
                      <ConditionEditor
                        key={index}
                        condition={subCondition}
                        onChange={(newSubCondition) => handleSubConditionChange(index, newSubCondition)}
                        onDelete={() => handleRemoveSubCondition(index)}
                        isNested={true}
                      />
                    ))}
                  </div>
                ) : (
                  <div className="text-center p-2 border border-dashed rounded-md">
                    <p className="text-xs text-gray-500">No conditions added yet</p>
                  </div>
                )}
                
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={handleAddSubCondition}
                  className="w-full"
                >
                  <PlusCircle size={14} className="mr-2" />
                  Add Condition
                </Button>
              </div>
            )}
          </div>
        </CardContent>
      )}
    </Card>
  );
};

================
File: components/rewards/RewardRuleEditor.tsx
================
// components/rewards/RewardRuleEditor.tsx
import React, { useState, useEffect } from 'react';
import { v4 as uuidv4 } from 'uuid';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Switch } from '@/components/ui/switch';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { useToast } from '@/hooks/use-toast';
import { PlusCircle } from 'lucide-react';
import { 
  RewardRule, 
  RuleCondition, 
  BonusTier,
  CalculationMethod,
  RoundingStrategy,
  SpendingPeriodType
} from '@/services/rewards/types';
import { ConditionEditor } from './ConditionEditor';
import { BonusTierEditor } from './BonusTierEditor';
import { Card, CardHeader, CardTitle, CardContent } from '../ui/card';

interface RewardRuleEditorProps {
  rule?: RewardRule;
  cardTypeId: string;
  onSave: (rule: RewardRule) => void;
  onCancel: () => void;
}

export const RewardRuleEditor: React.FC<RewardRuleEditorProps> = ({
  rule,
  cardTypeId,
  onSave,
  onCancel
}) => {
  const { toast } = useToast();
  const [activeTab, setActiveTab] = useState('general');
  
  // Initialize state with default or existing rule
  const [formData, setFormData] = useState<RewardRule>(() => {
    if (rule) {
      return { ...rule };
    }
    
    // Default rule template
    return {
      id: uuidv4(),
      cardTypeId,
      name: '',
      description: '',
      enabled: true,
      priority: 10,
      conditions: [],
      reward: {
        calculationMethod: 'standard',
        bonusMultiplier: 1.8,
        pointsRoundingStrategy: 'floor',
        amountRoundingStrategy: 'floor5',
        blockSize: 5,
        pointsCurrency: 'Points'
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  });
  
  // Handle adding a root-level condition
  const handleAddCondition = () => {
    setFormData(prev => ({
      ...prev,
      conditions: [
        ...prev.conditions,
        {
          type: 'mcc',
          operation: 'include',
          values: []
        }
      ]
    }));
  };
  
  // Handle removing a root-level condition
  const handleRemoveCondition = (index: number) => {
    setFormData(prev => ({
      ...prev,
      conditions: prev.conditions.filter((_, i) => i !== index)
    }));
  };
  
  // Handle updating a root-level condition
  const handleUpdateCondition = (index: number, condition: RuleCondition) => {
    setFormData(prev => {
      const newConditions = [...prev.conditions];
      newConditions[index] = condition;
      return {
        ...prev,
        conditions: newConditions
      };
    });
  };
  
  // Handle adding a new bonus tier
  const handleAddBonusTier = () => {
    const newTier: BonusTier = {
      name: `New Tier ${(formData.reward.bonusTiers?.length || 0) + 1}`,
      multiplier: formData.reward.bonusMultiplier,
      priority: 1,
      condition: {
        type: 'mcc',
        operation: 'include',
        values: []
      }
    };
    
    setFormData(prev => ({
      ...prev,
      reward: {
        ...prev.reward,
        bonusTiers: [...(prev.reward.bonusTiers || []), newTier]
      }
    }));
  };
  
  // Handle removing a bonus tier
  const handleRemoveBonusTier = (index: number) => {
    setFormData(prev => ({
      ...prev,
      reward: {
        ...prev.reward,
        bonusTiers: prev.reward.bonusTiers?.filter((_, i) => i !== index)
      }
    }));
  };
  
  // Handle updating a bonus tier
  const handleUpdateBonusTier = (index: number, tier: BonusTier) => {
    setFormData(prev => {
      if (!prev.reward.bonusTiers) return prev;
      
      const newTiers = [...prev.reward.bonusTiers];
      newTiers[index] = tier;
      
      return {
        ...prev,
        reward: {
          ...prev.reward,
          bonusTiers: newTiers
        }
      };
    });
  };
  
  // Input change handlers
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };
  
  // Handle reward setting changes
  const handleRewardChange = (field: keyof RewardRule['reward'], value: any) => {
    setFormData(prev => ({
      ...prev,
      reward: {
        ...prev.reward,
        [field]: value
      }
    }));
  };
  
  // Handle boolean switches
  const handleSwitchChange = (name: 'enabled', checked: boolean) => {
    setFormData(prev => ({ ...prev, [name]: checked }));
  };
  
  // Form submission
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!formData.name.trim()) {
      toast({
        title: "Error",
        description: "Rule name is required",
        variant: "destructive"
      });
      return;
    }
    
    // Update timestamps
    const updatedRule: RewardRule = {
      ...formData,
      updatedAt: new Date()
    };
    
    onSave(updatedRule);
  };
  
  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <Tabs defaultValue="general" value={activeTab} onValueChange={setActiveTab}>
        <TabsList className="grid grid-cols-4">
          <TabsTrigger value="general">General</TabsTrigger>
          <TabsTrigger value="conditions">Conditions</TabsTrigger>
          <TabsTrigger value="reward">Reward</TabsTrigger>
          <TabsTrigger value="tiers">Bonus Tiers</TabsTrigger>
        </TabsList>
        
        <TabsContent value="general" className="space-y-4">
          <div>
            <Label htmlFor="name">Rule Name</Label>
            <Input
              id="name"
              name="name"
              value={formData.name}
              onChange={handleInputChange}
              placeholder="E.g., Online Bonus Points"
            />
          </div>
          
          <div>
            <Label htmlFor="description">Description</Label>
            <Textarea
              id="description"
              name="description"
              value={formData.description}
              onChange={handleInputChange}
              placeholder="E.g., 10X points on online transactions"
            />
          </div>
          
          <div>
            <Label htmlFor="priority">Priority</Label>
            <Input
              id="priority"
              name="priority"
              type="number"
              value={formData.priority}
              onChange={(e) => setFormData(prev => ({ 
                ...prev, 
                priority: parseInt(e.target.value) 
              }))}
              placeholder="Higher values have higher priority"
            />
            <p className="text-sm text-muted-foreground mt-1">
              Rules with higher priority will be applied first
            </p>
          </div>
          
          <div className="flex items-center space-x-2">
            <Switch
              id="enabled"
              checked={formData.enabled}
              onCheckedChange={(checked) => handleSwitchChange('enabled', checked)}
            />
            <Label htmlFor="enabled">Enabled</Label>
          </div>
        </TabsContent>
        
        <TabsContent value="conditions" className="space-y-4">
          <div className="space-y-3">
            {formData.conditions.length > 0 ? (
              <div className="space-y-3">
                {formData.conditions.map((condition, index) => (
                  <ConditionEditor
                    key={index}
                    condition={condition}
                    onChange={(newCondition) => handleUpdateCondition(index, newCondition)}
                    onDelete={() => handleRemoveCondition(index)}
                  />
                ))}
              </div>
            ) : (
              <div className="text-center p-4 border border-dashed rounded-md">
                <p className="text-sm text-gray-500">
                  No conditions added yet. Add conditions to define when this rule applies.
                </p>
                <p className="text-xs text-gray-400 mt-1">
                  If no conditions are specified, the rule will apply to all transactions.
                </p>
              </div>
            )}
            
            <Button
              type="button"
              variant="outline"
              onClick={handleAddCondition}
              className="w-full"
            >
              <PlusCircle size={16} className="mr-2" />
              Add Condition
            </Button>
          </div>
        </TabsContent>
        
        <TabsContent value="reward" className="space-y-4">
          {/* Calculation Method */}
          <div>
            <Label htmlFor="calculationMethod">Calculation Method</Label>
            <Select
              value={formData.reward.calculationMethod}
              onValueChange={(value: CalculationMethod) => 
                handleRewardChange('calculationMethod', value)
              }
            >
              <SelectTrigger id="calculationMethod">
                <SelectValue placeholder="Select calculation method" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="standard">Standard (Round amount first, then calculate)</SelectItem>
                <SelectItem value="direct">Direct (Calculate first, then round)</SelectItem>
              </SelectContent>
            </Select>
            <p className="text-xs text-gray-500 mt-1">
              Standard: Round amount  Divide by block size  Multiply by rate<br />
              Direct: Multiply amount by rate  Round result
            </p>
          </div>
          
          {/* Block Size */}
          <div>
            <Label htmlFor="blockSize">Block Size</Label>
            <Select
              value={formData.reward.blockSize.toString()}
              onValueChange={(value) => 
                handleRewardChange('blockSize', parseInt(value))
              }
            >
              <SelectTrigger id="blockSize">
                <SelectValue placeholder="Select block size" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="1">$1 (Points per dollar)</SelectItem>
                <SelectItem value="5">$5 (Points per $5 block)</SelectItem>
              </SelectContent>
            </Select>
            <p className="text-xs text-gray-500 mt-1">
              For cards like UOB/OCBC that use $5 blocks, or $1 for direct point calculations
            </p>
          </div>
          
          {/* Bonus Multiplier */}
          <div>
            <Label htmlFor="bonusMultiplier">Bonus Multiplier</Label>
            <Input
              id="bonusMultiplier"
              type="number"
              step="0.1"
              value={formData.reward.bonusMultiplier}
              onChange={(e) => 
                handleRewardChange('bonusMultiplier', parseFloat(e.target.value))
              }
              placeholder="Bonus points per dollar or per block"
            />
            <p className="text-xs text-gray-500 mt-1">
              E.g., 1.8 = 9 points per $5 with block size of 5 (after 1 base point)
            </p>
          </div>
          
          {/* Monthly Cap */}
          <div>
            <Label htmlFor="monthlyCap">Monthly Bonus Points Cap</Label>
            <Input
              id="monthlyCap"
              type="number"
              value={formData.reward.monthlyCap || ''}
              onChange={(e) => 
                handleRewardChange('monthlyCap', e.target.value ? parseInt(e.target.value) : undefined)
              }
              placeholder="Leave empty for no cap"
            />
            <p className="text-xs text-gray-500 mt-1">
              Maximum bonus points that can be earned per month
            </p>
          </div>
          
          {/* Minimum Monthly Spend */}
          <div>
            <Label htmlFor="monthlyMinSpend">Minimum Monthly Spend</Label>
            <Input
              id="monthlyMinSpend"
              type="number"
              value={formData.reward.monthlyMinSpend || ''}
              onChange={(e) => 
                handleRewardChange('monthlyMinSpend', e.target.value ? parseInt(e.target.value) : undefined)
              }
              placeholder="Leave empty for no minimum"
            />
          </div>
          
          {/* Monthly Spend Period Type */}
          {formData.reward.monthlyMinSpend && (
            <div>
              <Label htmlFor="monthlySpendPeriodType">Spending Period Type</Label>
              <Select
                value={formData.reward.monthlySpendPeriodType || 'calendar_month'}
                onValueChange={(value: SpendingPeriodType) => 
                  handleRewardChange('monthlySpendPeriodType', value)
                }
              >
                <SelectTrigger id="monthlySpendPeriodType">
                  <SelectValue placeholder="Select period type" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="calendar_month">Calendar Month</SelectItem>
                  <SelectItem value="statement_month">Statement Month</SelectItem>
                </SelectContent>
              </Select>
            </div>
          )}
          
          {/* Amount Rounding Strategy */}
          <div>
            <Label htmlFor="amountRoundingStrategy">Amount Rounding Strategy</Label>
            <Select
              value={formData.reward.amountRoundingStrategy}
              onValueChange={(value: RoundingStrategy) => 
                handleRewardChange('amountRoundingStrategy', value)
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="Select rounding strategy" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="floor">Round Down (Floor)</SelectItem>
                <SelectItem value="ceiling">Round Up (Ceiling)</SelectItem>
                <SelectItem value="nearest">Round to Nearest</SelectItem>
                <SelectItem value="floor5">Round Down to Nearest $5</SelectItem>
                <SelectItem value="none">No Rounding</SelectItem>
              </SelectContent>
            </Select>
          </div>
          
          {/* Points Rounding Strategy */}
          <div>
            <Label htmlFor="pointsRoundingStrategy">Points Rounding Strategy</Label>
            <Select
              value={formData.reward.pointsRoundingStrategy}
              onValueChange={(value: RoundingStrategy) => 
                handleRewardChange('pointsRoundingStrategy', value)
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="Select rounding strategy" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="floor">Round Down (Floor)</SelectItem>
                <SelectItem value="ceiling">Round Up (Ceiling)</SelectItem>
                <SelectItem value="nearest">Round to Nearest</SelectItem>
                <SelectItem value="floor5">Round Down to Nearest $5</SelectItem>
                <SelectItem value="none">No Rounding</SelectItem>
              </SelectContent>
            </Select>
          </div>
          
          {/* Points Currency */}
          <div>
            <Label htmlFor="pointsCurrency">Points Currency</Label>
            <Input
              id="pointsCurrency"
              value={formData.reward.pointsCurrency}
              onChange={(e) => 
                handleRewardChange('pointsCurrency', e.target.value)
              }
              placeholder="E.g., UNI$, ThankYou Points, DBS Points"
            />
          </div>
          
          {/* Preview */}
          <Card className="mt-6">
            <CardHeader>
              <CardTitle>Rate Preview</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                <div className="text-2xl font-bold">
                  {(formData.reward.baseMultiplier + formData.reward.bonusMultiplier).toFixed(1)}x
                </div>
                <div className="text-sm text-muted-foreground">
                  Base: {formData.reward.baseMultiplier.toFixed(1)}x + 
                  Bonus: {formData.reward.bonusMultiplier.toFixed(1)}x
                </div>
                {formData.reward.blockSize > 1 && (
                  <div className="text-sm text-muted-foreground">
                    Per ${formData.reward.blockSize} block
                  </div>
                )}
                {formData.reward.monthlyCap && (
                  <div className="text-sm text-muted-foreground">
                    Monthly cap: {formData.reward.monthlyCap.toLocaleString()} bonus points
                  </div>
                )}
              </div>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
      
      <div className="flex justify-end space-x-2 pt-4">
        <Button type="button" variant="outline" onClick={onCancel}>
          Cancel
        </Button>
        <Button type="submit">
          {rule ? 'Update Rule' : 'Create Rule'}
        </Button>
      </div>
    </form>
  );
};

export default RewardRuleEditor;

================
File: components/rewards/RewardRuleManager.tsx
================
// components/rewards/RewardRuleManager.tsx

import React, { useEffect, useState } from 'react';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Card, CardContent, CardFooter, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { CoinsIcon, Plus, PencilIcon, TrashIcon } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { RewardRule } from '@/services/rewards/types';
import { RuleRepository } from '@/services/rewards/RuleRepository';
import { CardRegistry } from '@/services/rewards/CardRegistry';
import RewardRuleEditor from './RewardRuleEditor';

interface RewardRuleManagerProps {
  cardTypeId: string;
}

export const RewardRuleManager: React.FC<RewardRuleManagerProps> = ({ cardTypeId }) => {
  const [rules, setRules] = useState<RewardRule[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [editingRule, setEditingRule] = useState<RewardRule | undefined>(undefined);
  const { toast } = useToast();
  
  const ruleRepository = RuleRepository.getInstance();
  const cardRegistry = CardRegistry.getInstance();
  
  // Load rules when component mounts
  useEffect(() => {
    const loadRules = async () => {
      try {
        setIsLoading(true);
        const loadedRules = await ruleRepository.getRulesForCardType(cardTypeId);
        setRules(loadedRules);
      } catch (error) {
        console.error('Error loading rules:', error);
        toast({
          title: 'Error',
          description: 'Failed to load reward rules',
          variant: 'destructive',
        });
      } finally {
        setIsLoading(false);
      }
    };
    
    loadRules();
  }, [cardTypeId, toast]);
  
  // Get card name for display
  const getCardName = (): string => {
    const cardType = cardRegistry.getCardType(cardTypeId);
    if (cardType) {
      return `${cardType.issuer} ${cardType.name}`;
    }
    return cardTypeId;
  };
  
  // Handle adding a new rule
  const handleAddRule = () => {
    setEditingRule(undefined);
    setIsDialogOpen(true);
  };
  
  // Handle editing an existing rule
  const handleEditRule = (rule: RewardRule) => {
    setEditingRule(rule);
    setIsDialogOpen(true);
  };
  
  // Handle saving a rule
  const handleSaveRule = async (rule: RewardRule) => {
    try {
      const savedRule = await ruleRepository.saveRule(rule);
      
      if (savedRule) {
        // Update local rules state
        const isNewRule = !rules.some(r => r.id === savedRule.id);
        
        if (isNewRule) {
          setRules(prev => [...prev, savedRule]);
        } else {
          setRules(prev => prev.map(r => r.id === savedRule.id ? savedRule : r));
        }
        
        toast({
          title: 'Success',
          description: `Rule ${isNewRule ? 'created' : 'updated'} successfully`,
        });
        
        setIsDialogOpen(false);
      } else {
        toast({
          title: 'Error',
          description: 'Failed to save rule',
          variant: 'destructive',
        });
      }
    } catch (error) {
      console.error('Error saving rule:', error);
      toast({
        title: 'Error',
        description: 'Failed to save rule',
        variant: 'destructive',
      });
    }
  };
  
  // Handle deleting a rule
  const handleDeleteRule = async (ruleId: string) => {
    // Confirm deletion
    if (!window.confirm('Are you sure you want to delete this rule?')) {
      return;
    }
    
    try {
      const success = await ruleRepository.deleteRule(ruleId);
      
      if (success) {
        // Update local rules state
        setRules(prev => prev.filter(r => r.id !== ruleId));
        
        toast({
          title: 'Success',
          description: 'Rule deleted successfully',
        });
      } else {
        toast({
          title: 'Error',
          description: 'Failed to delete rule',
          variant: 'destructive',
        });
      }
    } catch (error) {
      console.error('Error deleting rule:', error);
      toast({
        title: 'Error',
        description: 'Failed to delete rule',
        variant: 'destructive',
      });
    }
  };
  
  // Format condition for display
  const formatCondition = (rule: RewardRule): string => {
    const conditions = rule.conditions;
    
    if (!conditions || conditions.length === 0) {
      return 'All transactions';
    }
    
    const parts: string[] = [];
    
    // Check for transaction type
    const transactionTypeCondition = conditions.find(c => c.type === 'transaction_type');
    if (transactionTypeCondition && transactionTypeCondition.values && transactionTypeCondition.values.length > 0) {
      const type = transactionTypeCondition.values[0];
      if (type === 'online') {
        parts.push('Online transactions');
      } else if (type === 'contactless') {
        parts.push('Contactless payments');
      } else if (type === 'in_store') {
        parts.push('In-store transactions');
      }
    }
    
    // Check for MCC codes
    const mccCondition = conditions.find(c => c.type === 'mcc');
    if (mccCondition && mccCondition.values && mccCondition.values.length > 0) {
      const mccCount = mccCondition.values.length;
      parts.push(`${mccCount} MCC code${mccCount > 1 ? 's' : ''}`);
    }
    
    // Check for merchant names
    const merchantCondition = conditions.find(c => c.type === 'merchant');
    if (merchantCondition && merchantCondition.values && merchantCondition.values.length > 0) {
      const merchantCount = merchantCondition.values.length;
      parts.push(`${merchantCount} merchant${merchantCount > 1 ? 's' : ''}`);
    }
    
    return parts.join(', ') || 'Custom conditions';
  };
  
  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h2 className="text-xl font-semibold flex items-center gap-2">
          <CoinsIcon className="h-5 w-5" />
          Reward Rules for {getCardName()}
        </h2>
        <Button onClick={handleAddRule}>
          <Plus className="h-4 w-4 mr-2" />
          Add Rule
        </Button>
      </div>
      
      {isLoading ? (
        <div className="flex justify-center py-8">
          <div className="animate-spin h-8 w-8 border-4 border-primary border-t-transparent rounded-full"></div>
        </div>
      ) : rules.length === 0 ? (
        <Card>
          <CardContent className="py-8 text-center">
            <CoinsIcon className="h-12 w-12 mx-auto mb-4 text-gray-400" />
            <p className="text-gray-500">No reward rules defined for this card type.</p>
            <Button className="mt-4" onClick={handleAddRule}>
              <Plus className="h-4 w-4 mr-2" />
              Add First Rule
            </Button>
          </CardContent>
        </Card>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {rules.map(rule => (
            <Card key={rule.id} className={rule.enabled ? undefined : 'opacity-60'}>
              <CardHeader className="pb-2">
                <div className="flex justify-between items-start">
                  <div>
                    <CardTitle>{rule.name}</CardTitle>
                    <CardDescription>{rule.description}</CardDescription>
                  </div>
                  <Badge 
                    className={rule.enabled ? 'bg-green-500' : 'bg-gray-500'}
                  >
                    {(rule.reward.baseMultiplier + rule.reward.bonusMultiplier).toFixed(1)}x
                  </Badge>
                </div>
              </CardHeader>
              <CardContent className="py-2">
                <div className="space-y-2 text-sm">
                  <div>
                    <span className="font-medium">Conditions:</span> {formatCondition(rule)}
                  </div>
                  <div>
                    <span className="font-medium">Calculation:</span> 
                    {rule.reward.baseMultiplier.toFixed(1)}x base + 
                    {rule.reward.bonusMultiplier.toFixed(1)}x bonus
                    {rule.reward.blockSize > 1 ? ` per $${rule.reward.blockSize}` : ' per $1'}
                  </div>
                  {rule.reward.monthlyCap && (
                    <div>
                      <span className="font-medium">Monthly Cap:</span> 
                      {rule.reward.monthlyCap.toLocaleString()} bonus points
                    </div>
                  )}
                  {rule.reward.monthlyMinSpend && (
                    <div>
                      <span className="font-medium">Minimum Spend:</span> 
                      ${rule.reward.monthlyMinSpend.toLocaleString()} per 
                      {rule.reward.monthlySpendPeriodType === 'statement_month' 
                        ? ' statement month' 
                        : ' calendar month'}
                    </div>
                  )}
                </div>
              </CardContent>
              <CardFooter className="pt-0 flex justify-end space-x-2">
                <Button variant="outline" size="sm" onClick={() => handleEditRule(rule)}>
                  <PencilIcon className="h-4 w-4 mr-1" />
                  Edit
                </Button>
                <Button variant="outline" size="sm" variant="destructive" onClick={() => handleDeleteRule(rule.id)}>
                  <TrashIcon className="h-4 w-4 mr-1" />
                  Delete
                </Button>
              </CardFooter>
            </Card>
          ))}
        </div>
      )}
      
      <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
        <DialogContent className="max-w-3xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>{editingRule ? 'Edit Rule' : 'Create Rule'}</DialogTitle>
          </DialogHeader>
          <RewardRuleEditor
            rule={editingRule}
            cardTypeId={cardTypeId}
            onSave={handleSaveRule}
            onCancel={() => setIsDialogOpen(false)}
          />
        </DialogContent>
      </Dialog>
    </div>
  );
};

export default RewardRuleManager;

================
File: hooks/expense-form/formSchema.ts
================
import { z } from 'zod';
import { MerchantCategoryCode } from '@/types';

// Form schema definition
export const formSchema = z.object({
  merchantName: z.string().min(1, 'Merchant name is required'),
  merchantAddress: z.string().optional(),
  isOnline: z.boolean().default(false),
  isContactless: z.boolean().default(false),
  amount: z.string().min(1, 'Amount is required').refine(value => !isNaN(Number(value)) && Number(value) > 0, {
    message: 'Amount must be a positive number',
  }),
  currency: z.string().min(1, 'Currency is required'),
  paymentMethodId: z.string().min(1, 'Payment method is required'),
  paymentAmount: z.string().refine(value => !isNaN(Number(value)) && Number(value) >= 0, {
    message: 'Payment amount must be a non-negative number',
  }).optional(),
  reimbursementAmount: z.string().refine(value => value === '' || (!isNaN(Number(value)) && Number(value) >= 0), {
    message: 'Reimbursement amount must be a non-negative number',
  }).default('0'),
  date: z.date({
    required_error: 'Date is required',
  }),
  notes: z.string().optional(),
  mcc: z.any().optional(),
});

export type FormValues = z.infer<typeof formSchema>;

================
File: hooks/expense-form/useMerchantData.ts
================
import { useCallback, useEffect, useState } from 'react';
import { MerchantCategoryCode } from '@/types';
import { UseFormReturn } from 'react-hook-form';
import { FormValues } from './formSchema';
import { getMerchantByName } from '@/utils/storageUtils';
import { getSuggestedMerchantCategory, hasMerchantCategorySuggestions } from '@/utils/storage/merchantTracking';

export const useMerchantData = (
  form: UseFormReturn<FormValues>,
  merchantName: string
) => {
  const [selectedMCC, setSelectedMCC] = useState<MerchantCategoryCode | undefined>();
  const [suggestionChecked, setSuggestionChecked] = useState(false);

  // Memoize merchant fetch to prevent excessive rerenders
  const fetchMerchant = useCallback(async (name: string) => {
    if (name && name.trim().length >= 3) {
      try {
        // First check if we have a merchant in database
        const existingMerchant = await getMerchantByName(name);
        if (existingMerchant?.mcc) {
          setSelectedMCC(existingMerchant.mcc);
          form.setValue('mcc', existingMerchant.mcc);
          return; // Exit if we found merchant with MCC
        }
        
        // If no merchant with MCC is found, check our mappings
        if (!suggestionChecked) {
          setSuggestionChecked(true);
          
          // Check if this merchant name has suggestions enabled and is not deleted
          const hasSuggestions = await hasMerchantCategorySuggestions(name);
          if (hasSuggestions) {
            const suggestedMCC = await getSuggestedMerchantCategory(name);
            if (suggestedMCC && (!selectedMCC || suggestedMCC.code !== selectedMCC.code)) {
              setSelectedMCC(suggestedMCC);
              form.setValue('mcc', suggestedMCC);
              return true; // Return true to indicate we found a suggestion
            }
          }
        }
        
        return false; // Return false to indicate no suggestion found
      } catch (error) {
        console.error('Error fetching merchant:', error);
        return false;
      }
    }
    return false;
  }, [form, selectedMCC, suggestionChecked]);

  // Debounce merchant fetch to avoid excessive API calls
  useEffect(() => {
    if (merchantName.trim().length < 3) {
      setSuggestionChecked(false); // Reset when merchant name changes significantly
      return;
    }
    
    const timer = setTimeout(() => {
      fetchMerchant(merchantName);
    }, 300); // 300ms debounce
    
    return () => clearTimeout(timer);
  }, [merchantName, fetchMerchant]);

  return { 
    selectedMCC, 
    setSelectedMCC,
    hasSuggestion: suggestionChecked
  };
};

================
File: hooks/expense-form/usePaymentMethodLogic.ts
================
import { useCallback, useEffect, useState } from 'react';
import { UseFormReturn } from 'react-hook-form';
import { PaymentMethod, Currency } from '@/types';
import { FormValues } from './formSchema';
import { findCashPaymentMethodForCurrency } from '@/utils/defaults/paymentMethods';
import { rewardCalculatorService } from '@/services/rewards/RewardCalculatorService';

// Initialize the reward calculator service
rewardCalculatorService.initialize().catch(error => {
  console.error('Failed to initialize reward calculator service:', error);
});

export const usePaymentMethodLogic = (
  form: UseFormReturn<FormValues>,
  paymentMethods: PaymentMethod[],
  currency: Currency,
  amount: number,
  isOnline: boolean
) => {
  const [selectedPaymentMethod, setSelectedPaymentMethod] = useState<PaymentMethod | undefined>();
  const [shouldOverridePayment, setShouldOverridePayment] = useState(false);
  
  const paymentMethodId = form.watch('paymentMethodId');

  // Initialize selected payment method based on stored payment methods
  useEffect(() => {
    if (paymentMethods.length > 0 && !paymentMethodId) {
      // Find default cash payment method for the selected currency
      const cashMethod = findCashPaymentMethodForCurrency(currency);
      if (cashMethod) {
        form.setValue('paymentMethodId', cashMethod.id);
        form.trigger('paymentMethodId');
      } else {
        // Use the first payment method as fallback
        form.setValue('paymentMethodId', paymentMethods[0].id);
        form.trigger('paymentMethodId');
      }
    }
  }, [paymentMethods, form, paymentMethodId, currency]);

  // Update payment method when currency changes
  useEffect(() => {
    if (currency && !paymentMethodId) {
      const cashMethod = findCashPaymentMethodForCurrency(currency);
      if (cashMethod) {
        form.setValue('paymentMethodId', cashMethod.id);
        form.trigger('paymentMethodId');
      }
    }
  }, [currency, form, paymentMethodId]);

  // Handle payment method selection changes - memoized to prevent excessive rerenders
  const updateSelectedPaymentMethod = useCallback(() => {
    if (paymentMethodId) {
      const method = paymentMethods.find(pm => pm.id === paymentMethodId);
      
      if (method) {
        setSelectedPaymentMethod(method);
        
        // Check if we need to handle currency conversion
        if (currency !== method.currency) {
          setShouldOverridePayment(true);
          
          // Set initial payment amount only if amount has changed
          if (amount > 0) {
            const conversionRates: Record<string, Record<string, number>> = {
              USD: { SGD: 1.35, EUR: 0.92, GBP: 0.78 },
              SGD: { USD: 0.74, EUR: 0.68, GBP: 0.58 },
              EUR: { USD: 1.09, SGD: 1.47, GBP: 0.85 },
              GBP: { USD: 1.28, SGD: 1.73, EUR: 1.17 }
            };
            
            const rate = conversionRates[currency]?.[method.currency] || 1;
            const convertedAmount = (amount * rate).toFixed(2);
            form.setValue('paymentAmount', convertedAmount);
          }
        } else {
          setShouldOverridePayment(false);
          form.setValue('paymentAmount', form.watch('amount'));
        }
        
        // Set contactless for credit cards when not online
        if (!isOnline && method.type === 'credit_card') {
          form.setValue('isContactless', true);
        }
      } else {
        setSelectedPaymentMethod(undefined);
        setShouldOverridePayment(false);
      }
    } else {
      setSelectedPaymentMethod(undefined);
      setShouldOverridePayment(false);
    }
  }, [currency, paymentMethodId, form, paymentMethods, amount, isOnline]);

  // Call the memoized update function when dependencies change
  useEffect(() => {
    updateSelectedPaymentMethod();
  }, [updateSelectedPaymentMethod]);

  return {
    selectedPaymentMethod,
    shouldOverridePayment,
  };
};

================
File: hooks/expense-form/useRewardPoints.ts
================
// hooks/expense-form/useRewardPoints.ts
import { useState } from 'react';
import { PaymentMethod } from '@/types';
import { rewardCalculatorService } from '@/services/rewards/RewardCalculatorService';
import { bonusPointsTrackingService } from '@/services/BonusPointsTrackingService';
import { TransactionType } from '@/services/rewards/types';

// Define return type for clearer API
export interface PointsSimulationResult {
  totalPoints: number;
  basePoints?: number;
  bonusPoints?: number;
  remainingMonthlyBonusPoints?: number;
  messageText?: string;
  pointsCurrency?: string;
  isLoading?: boolean;
  error?: string;
}

export const useRewardPoints = () => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | undefined>(undefined);

  /**
   * Simulate points for a transaction based on the given parameters
   */
  const simulatePoints = async (
    amount: number,
    currency: string,
    paymentMethod: PaymentMethod,
    mcc?: string,
    merchantName?: string,
    isOnline?: boolean,
    isContactless?: boolean
  ): Promise<PointsSimulationResult> => {
    // Reset state
    setIsLoading(true);
    setError(undefined);
    
    try {
      // Determine transaction type from isOnline and isContactless
      let transactionType: TransactionType;
      if (isOnline) {
        transactionType = TransactionType.ONLINE;
      } else if (isContactless) {
        transactionType = TransactionType.CONTACTLESS;
      } else {
        transactionType = TransactionType.IN_STORE;
      }
      
      // Get monthly used bonus points from service
      const usedBonusPoints = await bonusPointsTrackingService.getUsedBonusPoints(
        paymentMethod.id
      );
      
      // Use the reward calculation service for simulation
      const result = await rewardCalculatorService.simulatePoints(
        amount,
        currency,
        paymentMethod,
        mcc,
        merchantName,
        isOnline,
        isContactless,
        usedBonusPoints
      );
      
      // Format a message based on calculation results
      let messageText;
      if (result.bonusPoints === 0 && result.remainingMonthlyBonusPoints === 0) {
        messageText = "Monthly bonus points cap reached";
      } else if (result.bonusPoints === 0 && result.remainingMonthlyBonusPoints !== undefined && result.remainingMonthlyBonusPoints > 0) {
        messageText = "Not eligible for bonus points";
      } else if (result.bonusPoints > 0) {
        messageText = `Earning ${result.bonusPoints} bonus points`;
      } else if (result.remainingMonthlyBonusPoints !== undefined) {
        messageText = `${result.remainingMonthlyBonusPoints.toLocaleString()} bonus points remaining this month`;
      }
      
      return {
        ...result,
        messageText,
        isLoading: false
      };
    } catch (err) {
      // Handle any unexpected errors
      const errorMessage = err instanceof Error ? err.message : 'Error calculating reward points';
      setError(errorMessage);
      console.error('Error in simulatePoints hook:', err);
      
      // Return fallback result with error - using Math.round for proper rounding
      return {
        totalPoints: Math.round(amount),
        basePoints: Math.round(amount),
        bonusPoints: 0,
        error: errorMessage,
        isLoading: false,
        pointsCurrency: rewardCalculatorService.getPointsCurrency(paymentMethod)
      };
    } finally {
      setIsLoading(false);
    }
  };

  return { 
    simulatePoints,
    isLoading,
    error
  };
};

================
File: hooks/expense-form/useRewardPointsStandalone.ts
================
import { useState, useEffect } from 'react';
import { PaymentMethod } from '@/types';
import { rewardCalculatorService } from '@/services/rewards/RewardCalculatorService';
import { TransactionType } from '@/services/rewards/types';
import { bonusPointsTrackingService } from '@/services/BonusPointsTrackingService';

// Define the result interface to include all possible fields
interface PointsResult {
  totalPoints: number;
  basePoints?: number;
  bonusPoints?: number;
  remainingMonthlyBonusPoints?: number;
  pointsCurrency?: string;
  messageText?: string;
}

/**
 * Hook for calculating reward points outside of the Dashboard context
 * This is a standalone version that doesn't require DashboardContext
 */
export function useRewardPointsStandalone(
  amount: number | null,
  paymentMethodId: string | null,
  paymentMethods: PaymentMethod[] | undefined,
  mcc?: string,
  merchantName?: string,
  isOnline?: boolean,
  isContactless?: boolean
) {
  // State for estimated points
  const [estimatedPoints, setEstimatedPoints] = useState<PointsResult>({
    totalPoints: 0,
    basePoints: 0,
    bonusPoints: 0
  });
  
  // Find selected payment method, with null check for paymentMethods
  const selectedPaymentMethod = paymentMethods && paymentMethodId ? 
    paymentMethods.find(pm => pm.id === paymentMethodId) || null : null;
  
  // Calculate estimated points when inputs change
  useEffect(() => {
    // Reset points if no amount or payment method
    if (!amount || amount <= 0 || !selectedPaymentMethod) {
      setEstimatedPoints({
        totalPoints: 0,
        basePoints: 0,
        bonusPoints: 0
      });
      return;
    }
    
    // Skip for cash payment methods
    if (selectedPaymentMethod.type === 'cash') {
      setEstimatedPoints({
        totalPoints: 0,
        basePoints: 0,
        bonusPoints: 0
      });
      return;
    }
    
    // Define an async function to get the points
    const calculatePoints = async () => {
      const currency = selectedPaymentMethod.currency || 'SGD';
      
      try {
        console.log('useRewardPointsStandalone: Calculating points with parameters:', {
          amount,
          currency, 
          selectedPaymentMethod: selectedPaymentMethod.name,
          mcc,
          merchantName,
          isOnline,
          isContactless
        });
        
        // Determine transaction type
        let transactionType: TransactionType;
        if (isOnline) {
          transactionType = TransactionType.ONLINE;
        } else if (isContactless) {
          transactionType = TransactionType.CONTACTLESS;
        } else {
          transactionType = TransactionType.IN_STORE;
        }
        
        // Get monthly used bonus points
        const usedBonusPoints = await bonusPointsTrackingService.getUsedBonusPoints(
          selectedPaymentMethod.id
        );
        
        // Calculate points using the service
        const result = await rewardCalculatorService.simulatePoints(
          amount,
          currency,
          selectedPaymentMethod,
          mcc,
          merchantName,
          isOnline,
          isContactless,
          usedBonusPoints
        );
        
        console.log('Reward calculation result:', result);
        
        // Format message text based on calculation results
        let messageText;
        if (result.bonusPoints === 0 && result.remainingMonthlyBonusPoints === 0) {
          messageText = "Monthly bonus points cap reached";
        } else if (result.bonusPoints === 0 && result.remainingMonthlyBonusPoints !== undefined && result.remainingMonthlyBonusPoints > 0) {
          messageText = "Not eligible for bonus points";
        } else if (result.bonusPoints > 0) {
          messageText = `Earning ${result.bonusPoints} bonus points`;
        } else if (result.remainingMonthlyBonusPoints !== undefined) {
          messageText = `${result.remainingMonthlyBonusPoints.toLocaleString()} bonus points remaining this month`;
        }
        
        // Ensure we have proper values
        setEstimatedPoints({
          totalPoints: result.totalPoints || 0,
          basePoints: result.basePoints || 0,
          bonusPoints: result.bonusPoints || 0,
          remainingMonthlyBonusPoints: result.remainingMonthlyBonusPoints,
          pointsCurrency: result.pointsCurrency || (selectedPaymentMethod.issuer ? `${selectedPaymentMethod.issuer} Points` : 'Points'),
          messageText: messageText
        });
      } catch (error) {
        console.error('Error calculating reward points:', error);
        // Provide fallback calculation
        const fallbackPoints = Math.round(amount);
        setEstimatedPoints({
          totalPoints: fallbackPoints,
          basePoints: fallbackPoints,
          bonusPoints: 0,
          messageText: 'Error calculating points'
        });
      }
    };
    
    // Call the async function
    calculatePoints();
  }, [amount, paymentMethodId, selectedPaymentMethod, mcc, merchantName, isOnline, isContactless, paymentMethods]);
  
  return {
    estimatedPoints,
    selectedPaymentMethod
  };
}

================
File: pages/AddExpense.tsx
================
import { useSupabaseConnectionCheck } from '@/hooks/useSupabaseConnectionCheck';
import { usePaymentMethods } from '@/hooks/usePaymentMethods';
import { useTransactionSubmit } from '@/hooks/useTransactionSubmit';
import ExpenseForm from '@/components/expense/ExpenseForm';
import StorageModeAlert from '@/components/expense/StorageModeAlert';
import ErrorAlert from '@/components/expense/ErrorAlert';
import { useState, useEffect } from 'react';
import { useIsMobile } from '@/hooks/use-mobile';
// Import from the new reward system
import { CardRegistry } from '@/services/rewards/CardRegistry';
import { rewardCalculatorService } from '@/services/rewards/RewardCalculatorService';

const AddExpense = () => {
  const { useLocalStorage } = useSupabaseConnectionCheck();
  const { paymentMethods, isLoading } = usePaymentMethods();
  const { handleSubmit, isLoading: isSaving, saveError } = useTransactionSubmit(useLocalStorage);
  const isMobile = useIsMobile();
  const [activeTab, setActiveTab] = useState("expense");
  
  // Initialize custom calculators when the page loads
  useEffect(() => {
    console.log('AddExpense: Initializing calculators');
    
    // Initialize the card registry to ensure all card types are loaded
    const cardRegistry = CardRegistry.getInstance();
    
    // Force initialize the reward calculation service
    rewardCalculatorService.initialize().then(() => {
      console.log('RewardCalculatorService initialized successfully');
      
      // Test the service with a dummy call
      rewardCalculatorService.getPointsCurrency({
        id: '',
        name: '',
        type: 'credit_card',
        currency: 'SGD',
        rewardRules: [],
        active: true
      });
      
      console.log('Reward calculation system ready');
    }).catch(error => {
      console.error('Failed to initialize RewardCalculatorService:', error);
    });
    
  }, []);
  
  return (
    <div className="min-h-screen">
      <div className="container max-w-7xl mx-auto pb-16">
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-10 mt-4">
          <div>
            <h1 className="text-3xl font-bold tracking-tight text-gradient">Add Expense</h1>
            <p className="text-muted-foreground mt-1.5 text-sm">
              Record a new expense transaction
            </p>
          </div>
        </div>
        
        <StorageModeAlert useLocalStorage={useLocalStorage} />
        <ErrorAlert error={saveError} />
        
        {isLoading && paymentMethods.length === 0 ? (
          <div className="animate-pulse text-center py-10">Loading...</div>
        ) : (
          <ExpenseForm
            paymentMethods={paymentMethods}
            onSubmit={handleSubmit}
          />
        )}
      </div>
    </div>
  );
};

export default AddExpense;

================
File: pages/PaymentMethods.tsx
================
import { useState, useEffect } from 'react';
import { PaymentMethod } from '@/types';
import { usePaymentMethodsQuery } from '@/hooks/queries/usePaymentMethodsQuery';
import { useToast } from '@/hooks/use-toast';
import { savePaymentMethods, uploadCardImage } from '@/utils/storage/paymentMethods';
import PaymentMethodForm from '@/components/payment-method/PaymentMethodForm';
import ImageUploadDialog from '@/components/payment-method/ImageUploadDialog';
import { v4 as uuidv4 } from 'uuid';
import { PaymentCarousel } from '@/components/payment-method/PaymentCarousel';
import { PaymentFunctionsList } from '@/components/payment-method/PaymentFunctionsList';
import { EmptyPaymentMethodState } from '@/components/payment-method/EmptyPaymentMethodState';
import { Button } from '@/components/ui/button';
import { Plus } from 'lucide-react';

const PaymentMethods = () => {
  const { data: paymentMethods = [], isLoading, refetch } = usePaymentMethodsQuery();
  const [isFormOpen, setIsFormOpen] = useState(false);
  const [editingMethod, setEditingMethod] = useState<PaymentMethod | null>(null);
  const [imageUploadMethod, setImageUploadMethod] = useState<PaymentMethod | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [selectedMethod, setSelectedMethod] = useState<PaymentMethod | null>(null);
  const { toast } = useToast();

  // Set first active payment method as selected on load
  useEffect(() => {
    if (paymentMethods.length > 0 && !selectedMethod) {
      const activeMethod = paymentMethods.find(m => m.active) || paymentMethods[0];
      setSelectedMethod(activeMethod);
    }
  }, [paymentMethods, selectedMethod]);

  const handleAddMethod = () => {
    setEditingMethod(null);
    setIsFormOpen(true);
  };

  const handleEditMethod = (method: PaymentMethod) => {
    setEditingMethod(method);
    setIsFormOpen(true);
  };

  const handleFormSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    
    try {
      const formData = new FormData(event.currentTarget);
      
      const method: PaymentMethod = {
        id: editingMethod?.id || uuidv4(),
        name: formData.get('name') as string,
        type: formData.get('type') as 'cash' | 'credit_card',
        currency: formData.get('currency') as any,
        rewardRules: editingMethod?.rewardRules || [],
        active: formData.get('active') === 'on',
        imageUrl: editingMethod?.imageUrl,
      };
      
      // Add credit card specific fields if applicable
      if (method.type === 'credit_card') {
        method.issuer = formData.get('issuer') as string || undefined;
        method.lastFourDigits = formData.get('lastFourDigits') as string || undefined;
        
        const statementDay = formData.get('statementStartDay') as string;
        if (statementDay) {
          method.statementStartDay = parseInt(statementDay, 10);
        }
        
        method.isMonthlyStatement = formData.get('isMonthlyStatement') === 'on';
      }
      
      await handleSaveMethod(method);
    } catch (error) {
      console.error('Error saving payment method:', error);
      toast({
        title: 'Error',
        description: 'Failed to save payment method',
        variant: 'destructive',
      });
    }
  };

  const handleSaveMethod = async (method: PaymentMethod) => {
    try {
      let updatedMethods: PaymentMethod[];
      
      if (editingMethod) {
        // Update existing method
        updatedMethods = paymentMethods.map(m => 
          m.id === method.id ? method : m
        );
      } else {
        // Add new method
        updatedMethods = [...paymentMethods, method];
      }
      
      await savePaymentMethods(updatedMethods);
      
      toast({
        title: 'Success',
        description: `Payment method ${editingMethod ? 'updated' : 'added'} successfully`,
      });
      
      setIsFormOpen(false);
      setEditingMethod(null);
      refetch(); // Refresh the data
    } catch (error) {
      console.error('Error saving payment method:', error);
      toast({
        title: 'Error',
        description: 'Failed to save payment method',
        variant: 'destructive',
      });
    }
  };

  const handleToggleActive = async (id: string) => {
    try {
      const updatedMethods = paymentMethods.map(method => 
        method.id === id 
          ? { ...method, active: !method.active } 
          : method
      );
      
      await savePaymentMethods(updatedMethods);
      
      const method = updatedMethods.find(m => m.id === id);
      
      toast({
        title: 'Success',
        description: `${method?.name} ${method?.active ? 'activated' : 'deactivated'} successfully`,
      });

      refetch(); // Refresh the data
    } catch (error) {
      console.error('Error toggling payment method active state:', error);
      toast({
        title: 'Error',
        description: 'Failed to update payment method',
        variant: 'destructive',
      });
    }
  };

  const handleOpenImageUpload = (method: PaymentMethod) => {
    setImageUploadMethod(method);
  };

  const handleImageUpload = async (file: File) => {
    if (!imageUploadMethod) return;
    
    setIsUploading(true);
    
    try {
      const imageUrl = await uploadCardImage(file, imageUploadMethod.id);
      
      if (imageUrl) {
        // Update the payment method with the image URL
        const updatedMethods = paymentMethods.map(method => 
          method.id === imageUploadMethod.id 
            ? { ...method, imageUrl } 
            : method
        );
        
        await savePaymentMethods(updatedMethods);
        
        toast({
          title: 'Success',
          description: 'Card image uploaded successfully',
        });

        refetch(); // Refresh the data
      } else {
        throw new Error('Failed to upload image');
      }
    } catch (error) {
      console.error('Error uploading card image:', error);
      toast({
        title: 'Error',
        description: 'Failed to upload card image',
        variant: 'destructive',
      });
    } finally {
      setIsUploading(false);
      setImageUploadMethod(null);
    }
  };

  return (
    <div className="min-h-screen">
      <div className="container max-w-7xl mx-auto pb-16">
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-8 mt-4">
          <div>
            <h1 className="text-3xl font-bold tracking-tight text-gradient">Payment Methods</h1>
            <p className="text-muted-foreground mt-1.5 text-sm">
              Manage your payment cards and cash payment methods
            </p>
          </div>
          
          <Button onClick={handleAddMethod} className="gap-2 mt-4 sm:mt-0">
            <Plus className="h-4 w-4" />
            Add Method
          </Button>
        </div>
        
        {isLoading ? (
          <div className="animate-pulse text-center py-10">
            Loading payment methods...
          </div>
        ) : paymentMethods.length === 0 ? (
          <EmptyPaymentMethodState onAddClick={handleAddMethod} />
        ) : (
          <div className="space-y-8">
            {/* Card Carousel */}
            <div className="mb-8 relative">
              <PaymentCarousel 
                paymentMethods={paymentMethods}
                selectedMethod={selectedMethod}
                onSelectMethod={setSelectedMethod}
              />
            </div>
            
            {/* Functions List */}
            {selectedMethod && (
              <PaymentFunctionsList 
                paymentMethod={selectedMethod}
                onToggleActive={handleToggleActive}
                onEdit={handleEditMethod}
                onImageUpload={handleOpenImageUpload}
              />
            )}
          </div>
        )}
        
        {/* Payment Method Form Modal */}
        <PaymentMethodForm
          currentMethod={editingMethod}
          isEditing={!!editingMethod}
          isLoading={isLoading}
          isOpen={isFormOpen}
          onClose={() => {
            setIsFormOpen(false);
            setEditingMethod(null);
          }}
          onSubmit={handleFormSubmit}
        />
        
        {/* Image Upload Dialog */}
        <ImageUploadDialog
          open={!!imageUploadMethod}
          onOpenChange={(open) => {
            if (!open) setImageUploadMethod(null);
          }}
          paymentMethod={imageUploadMethod}
          onImageUpload={handleImageUpload}
          isUploading={isUploading}
        />
      </div>
    </div>
  );
};

export default PaymentMethods;

================
File: services/rewards/CardRegistry.ts
================
// services/rewards/CardRegistry.ts

import { CardType, RewardRule, TransactionType } from './types';
import { v4 as uuidv4 } from 'uuid';

/**
 * Registry for all card types and their default rules
 */
export class CardRegistry {
  private static instance: CardRegistry;
  private cardTypes: Map<string, CardType> = new Map();
  
  private constructor() {
    this.initializeDefaultCards();
  }
  
  /**
   * Get singleton instance
   */
  public static getInstance(): CardRegistry {
    if (!CardRegistry.instance) {
      CardRegistry.instance = new CardRegistry();
    }
    return CardRegistry.instance;
  }
  
  /**
   * Register a card type
   */
  public registerCardType(cardType: CardType): void {
    this.cardTypes.set(cardType.id, cardType);
  }
  
  /**
   * Get a card type by ID
   */
  public getCardType(id: string): CardType | undefined {
    return this.cardTypes.get(id);
  }
  
  /**
   * Get a card type by issuer and name
   */
  public getCardTypeByIssuerAndName(issuer: string, name: string): CardType | undefined {
    const normalizedIssuer = issuer.toLowerCase();
    const normalizedName = name.toLowerCase();
    
    for (const cardType of this.cardTypes.values()) {
      if (cardType.issuer.toLowerCase() === normalizedIssuer && 
          cardType.name.toLowerCase() === normalizedName) {
        return cardType;
      }
    }
    
    return undefined;
  }
  
  /**
   * Get all card types
   */
  public getAllCardTypes(): CardType[] {
    return Array.from(this.cardTypes.values());
  }
  
  /**
   * Get card types by issuer
   */
  public getCardTypesByIssuer(issuer: string): CardType[] {
    const normalizedIssuer = issuer.toLowerCase();
    
    return Array.from(this.cardTypes.values())
      .filter(cardType => cardType.issuer.toLowerCase() === normalizedIssuer);
  }
  
  /**
   * Initialize default card types
   */
  private initializeDefaultCards(): void {
    // 1. DBS Woman's World Card
    this.registerCardType({
      id: 'dbs-womans-world-mastercard',
      issuer: 'DBS',
      name: 'Woman\'s World MasterCard',
      pointsCurrency: 'DBS Points',
      defaultRules: [
        this.createDBSWomansWorldCardRule()
      ]
    });
    
    // 2. Citibank Rewards Card
    this.registerCardType({
      id: 'citibank-rewards-visa-signature',
      issuer: 'Citibank',
      name: 'Rewards Visa Signature',
      pointsCurrency: 'ThankYou Points',
      defaultRules: [
        this.createCitibankRewardsCardRule()
      ]
    });
    
    // 3. UOB Preferred Platinum Card
    this.registerCardType({
      id: 'uob-preferred-visa-platinum',
      issuer: 'UOB',
      name: 'Preferred Visa Platinum',
      pointsCurrency: 'UNI$',
      defaultRules: [
        this.createUOBPlatinumCardRule()
      ]
    });
    
    // 4. UOB Lady's Solitaire Card
    this.registerCardType({
      id: 'uob-ladys-solitaire-world-mastercard',
      issuer: 'UOB',
      name: 'Lady\'s Solitaire',
      pointsCurrency: 'UNI$',
      hasCategories: true,
      availableCategories: [
        'Beauty & Wellness',
        'Dining',
        'Entertainment',
        'Family',
        'Fashion',
        'Transport',
        'Travel'
      ],
      maxCategoriesSelectable: 2,
      defaultRules: [
        this.createUOBLadysSolitaireCardRule()
      ]
    });
    
    // 5. UOB Visa Signature Card
    this.registerCardType({
      id: 'uob-visa-signature',
      issuer: 'UOB',
      name: 'Visa Signature',
      pointsCurrency: 'UNI$',
      defaultRules: [
        this.createUOBVisaSignatureCardRule()
      ]
    });
    
    // 6. OCBC Rewards World Card
    this.registerCardType({
      id: 'ocbc-rewards-world-mastercard',
      issuer: 'OCBC',
      name: 'Rewards World Mastercard',
      pointsCurrency: 'OCBC$',
      defaultRules: [
        this.createOCBCRewardsWorldCardRule()
      ]
    });
    
    // 7. Amex Platinum Credit
    this.registerCardType({
      id: 'amex-platinum-credit-sg',
      issuer: 'American Express',
      name: 'Platinum Credit',
      pointsCurrency: 'Membership Rewards Points',
      defaultRules: [
        this.createAmexPlatinumCreditCardRule()
      ]
    });
    
    // 8. Amex Platinum Singapore
    this.registerCardType({
      id: 'amex-platinum-sg',
      issuer: 'American Express',
      name: 'Platinum Singapore',
      pointsCurrency: 'Membership Rewards Points',
      defaultRules: [
        this.createAmexPlatinumSingaporeCardRule()
      ]
    });
    
    // 9. Amex Platinum Canada
    this.registerCardType({
      id: 'amex-platinum-ca',
      issuer: 'American Express',
      name: 'Platinum Canada',
      pointsCurrency: 'Membership Rewards Points',
      defaultRules: [
        this.createAmexPlatinumCanadaCardRule()
      ]
    });
    
    // 10. Amex Cobalt
    this.registerCardType({
      id: 'amex-cobalt',
      issuer: 'American Express',
      name: 'Cobalt',
      pointsCurrency: 'Membership Rewards Points',
      defaultRules: [
        this.createAmexCobaltCardRule()
      ]
    });
    
    // 11. TD Aeroplan Visa Infinite
    this.registerCardType({
      id: 'td-aeroplan-visa-infinite',
      issuer: 'TD',
      name: 'Aeroplan Visa Infinite',
      pointsCurrency: 'Aeroplan Points',
      defaultRules: [
        this.createTDAeroplanVisaInfiniteCardRule()
      ]
    });
  }
  
  /**
   * 1. DBS Woman's World Card Rule
   * 10X DBS Points (20 miles) on online spend, capped at 2,000 bonus points monthly
   */
  private createDBSWomansWorldCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'dbs-womans-world-mastercard',
      name: 'Online Shopping 10X',
      description: '10X DBS Points (20 miles) on online spend',
      enabled: true,
      priority: 10,
      conditions: [
        {
          type: 'transaction_type',
          operation: 'equals',
          values: [TransactionType.ONLINE]
        }
      ],
      reward: {
        calculationMethod: 'standard',
        baseMultiplier: 1,
        bonusMultiplier: 9, // 9 additional points per $5
        pointsRoundingStrategy: 'floor',
        amountRoundingStrategy: 'floor5',
        blockSize: 5,
        monthlyCap: 2700, // Cap at 2,700 bonus points per month
        pointsCurrency: 'DBS Points'
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 2. Citibank Rewards Card Rule
   * 10X points on online or department store spend, capped at 4,000 bonus points monthly
   */
  private createCitibankRewardsCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'citibank-rewards-visa-signature',
      name: 'Citibank Rewards 10X',
      description: '10X ThankYou Points on online & department store shopping',
      enabled: true,
      priority: 10,
      conditions: [
        {
          type: 'compound',
          operation: 'any', // OR logic
          subConditions: [
            // Online transactions excluding airlines and travel
            {
              type: 'compound',
              operation: 'all', // AND logic
              subConditions: [
                {
                  type: 'transaction_type',
                  operation: 'equals',
                  values: [TransactionType.ONLINE]
                },
                {
                  type: 'mcc',
                  operation: 'exclude',
                  values: [
                    // Airlines (3000-3999)
                    ...[...Array(1000)].map((_, i) => `${3000 + i}`),
                    // Other excluded travel categories
                    '4511', '7512', '7011', '4111', '4112', '4789', 
                    '4411', '4722', '4723', '5962', '7012'
                  ]
                }
              ]
            },
            // Department store transactions
            {
              type: 'mcc',
              operation: 'include',
              values: [
                '5311', '5611', '5621', '5631', '5641', '5651', 
                '5655', '5661', '5691', '5699', '5948'
              ]
            }
          ]
        }
      ],
      reward: {
        calculationMethod: 'standard',
        baseMultiplier: 1,
        bonusMultiplier: 9, // 9x bonus points
        pointsRoundingStrategy: 'floor',
        amountRoundingStrategy: 'floor',
        blockSize: 1,
        monthlyCap: 9000, // Cap at 9,000 bonus points per month
        pointsCurrency: 'ThankYou Points'
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 3. UOB Preferred Platinum Card Rule
   * 10X UNI$ on online or contactless spending (with eligible MCCs), capped at 4,000 bonus points monthly
   */
  private createUOBPlatinumCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'uob-preferred-visa-platinum',
      name: 'UOB Platinum 10X',
      description: '10X UNI$ (4 miles) on online or contactless spending',
      enabled: true,
      priority: 10,
      conditions: [],
      reward: {
        calculationMethod: 'standard',
        baseMultiplier: 1,
        bonusMultiplier: 0, // No default bonus
        pointsRoundingStrategy: 'floor',
        amountRoundingStrategy: 'floor5',
        blockSize: 5,
        monthlyCap: 2000, // Shared cap: 2,000 bonus points per month
        pointsCurrency: 'UNI$',
        bonusTiers: [
          {
            name: 'Contactless Payments',
            priority: 1,
            multiplier: 9, // 9 additional points per $5
            condition: {
              type: 'transaction_type',
              operation: 'equals',
              values: [TransactionType.CONTACTLESS]
            }
          },
          {
            name: 'Online with Eligible MCCs',
            priority: 1,
            multiplier: 9, // 9 additional points per $5
            condition: {
              type: 'compound',
              operation: 'all', // AND logic
              subConditions: [
                {
                  type: 'transaction_type',
                  operation: 'equals',
                  values: [TransactionType.ONLINE]
                },
                {
                  type: 'mcc',
                  operation: 'include',
                  values: [
                    '4816', '5262', '5306', '5309', '5310', '5311', '5331', '5399', 
                    '5611', '5621', '5631', '5641', '5651', '5661', '5691', '5699',
                    '5732', '5733', '5734', '5735', '5912', '5942', '5944', '5945',
                    '5946', '5947', '5948', '5949', '5964', '5965', '5966', '5967',
                    '5968', '5969', '5970', '5992', '5999', '5811', '5812', '5814',
                    '5333', '5411', '5441', '5462', '5499', '8012', '9751', '7278',
                    '7832', '7841', '7922', '7991', '7996', '7998', '7999'
                  ]
                }
              ]
            }
          }
        ]
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 4. UOB Lady's Solitaire Card Rule
   * 10X UNI$ on spending in selected categories, capped at 3,600 bonus points monthly
   */
  private createUOBLadysSolitaireCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'uob-ladys-solitaire-world-mastercard',
      name: 'Selected Categories 10X',
      description: '10X UNI$ (4 miles) on spending in selected categories',
      enabled: true,
      priority: 10,
      conditions: [
        {
          type: 'category',
          operation: 'include',
          values: [] // This will be populated based on user selection
        }
      ],
      reward: {
        calculationMethod: 'standard',
        baseMultiplier: 1,
        bonusMultiplier: 9, // 9 additional points per $5
        pointsRoundingStrategy: 'floor',
        amountRoundingStrategy: 'floor5',
        blockSize: 5,
        monthlyCap: 3600, // Cap at 3,600 bonus points per month
        pointsCurrency: 'UNI$'
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 5. UOB Visa Signature Card Rule
   * 10X UNI$ on all foreign currency spending, capped at 8,000 points monthly
   * Minimum spend $1,000 in foreign currency per statement month to activate
   */
  private createUOBVisaSignatureCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'uob-visa-signature',
      name: 'Foreign Currency 10X',
      description: '10X UNI$ (4 miles) on all foreign currency spend',
      enabled: true,
      priority: 10,
      conditions: [
        {
          type: 'currency',
          operation: 'exclude',
          values: ['SGD'] // Any currency except SGD
        }
      ],
      reward: {
        calculationMethod: 'standard',
        baseMultiplier: 1,
        bonusMultiplier: 9, // 9 additional points per $5
        pointsRoundingStrategy: 'floor',
        amountRoundingStrategy: 'floor5',
        blockSize: 5,
        monthlyCap: 3600, // Cap at 3,600 bonus points per month
        monthlyMinSpend: 1000, // Min $1,000 foreign currency spend to qualify
        monthlySpendPeriodType: 'statement_month',
        pointsCurrency: 'UNI$'
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 6. OCBC Rewards World Card Rule
   * Tiered earning rates with shared monthly cap of 10,000 bonus points:
   * - Tier 1: 28X points on selected department stores/Watsons
   * - Tier 2: 18X points on other retail/dining
   */
  private createOCBCRewardsWorldCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'ocbc-rewards-world-mastercard',
      name: 'OCBC Rewards World Tiered Bonus',
      description: 'Tiered bonus points on shopping, dining, and e-commerce',
      enabled: true,
      priority: 10,
      conditions: [], // Base rule applies to all transactions
      reward: {
        calculationMethod: 'standard',
        baseMultiplier: 1,
        bonusMultiplier: 0, // Base rule has 0 bonus by default
        pointsRoundingStrategy: 'floor',
        amountRoundingStrategy: 'floor5',
        blockSize: 5,
        monthlyCap: 10000, // Shared cap across all tiers: 10,000 bonus points
        pointsCurrency: 'OCBC$',
        // Define multiple bonus tiers with different rates
        bonusTiers: [
          {
            name: 'Tier 1 - Selected Retail',
            priority: 1,
            multiplier: 14, // 28x points per $5 (base 2x + bonus 26x)
            condition: {
              type: 'compound',
              operation: 'any', // OR logic
              subConditions: [
                {
                  // Department store MCC
                  type: 'mcc',
                  operation: 'include',
                  values: ['5311']
                },
                {
                  // Watsons merchant name
                  type: 'merchant',
                  operation: 'include',
                  values: ['Watsons']
                }
              ]
            }
          },
          {
            name: 'Tier 2 - Shopping & Dining',
            priority: 2,
            multiplier: 9, // 18x points per $5 (base 2x + bonus 16x)
            condition: {
              type: 'mcc',
              operation: 'include',
              values: [
                '5309', '5611', '5621', '5641', '5651', '5655', '5661', '5691', 
                '5699', '5941', '5948'
              ]
            }
          }
        ]
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 7. Amex Platinum Credit Card Rule
   * Fixed rate: 2 MR points for every $1.60 spent
   */
  private createAmexPlatinumCreditCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'amex-platinum-credit-sg',
      name: 'Amex Platinum Credit Base Earning',
      description: '2 Membership Rewards points for every $1.60 spent',
      enabled: true,
      priority: 10,
      conditions: [], // Applies to all transactions
      reward: {
        calculationMethod: 'direct',
        baseMultiplier: 2,
        bonusMultiplier: 0, // No bonus multiplier
        pointsRoundingStrategy: 'nearest',
        amountRoundingStrategy: 'none',
        blockSize: 1.6, // 2 points per $1.6
        pointsCurrency: 'Membership Rewards Points'
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 8. Amex Platinum Singapore Card Rule
   * Fixed rate: 2 MR points for every $1.60 spent
   */
  private createAmexPlatinumSingaporeCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'amex-platinum-sg',
      name: 'Amex Platinum Singapore Base Earning',
      description: '2 Membership Rewards points for every $1.60 spent',
      enabled: true,
      priority: 10,
      conditions: [], // Applies to all transactions
      reward: {
        calculationMethod: 'direct',
        baseMultiplier: 1,
        bonusMultiplier: 0, // No bonus multiplier
        pointsRoundingStrategy: 'nearest',
        amountRoundingStrategy: 'none',
        blockSize: 1.6, // $1.60 per 2 points
        pointsCurrency: 'Membership Rewards Points'
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 9. Amex Platinum Canada Card Rule
   * - Base: 1 point per dollar for all transactions
   * - Bonus tiers with different multipliers for different categories
   */
  private createAmexPlatinumCanadaCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'amex-platinum-ca',
      name: 'Amex Platinum Canada Tiered Earning',
      description: 'Up to 3X MR points on travel and dining',
      enabled: true,
      priority: 10,
      conditions: [], // Base rule applies to all transactions
      reward: {
        calculationMethod: 'direct',
        baseMultiplier: 1,
        bonusMultiplier: 0, // Base rate is 1x, set in the calculation
        pointsRoundingStrategy: 'nearest',
        amountRoundingStrategy: 'none',
        blockSize: 1,
        pointsCurrency: 'Membership Rewards Points',
        // Multiple tiers with different rates
        bonusTiers: [
          {
            name: 'Amex Travel',
            priority: 1,
            multiplier: 2, // 3x total (1x base + 2x bonus)
            condition: {
              type: 'merchant',
              operation: 'include',
              values: ['Amex Travel']
            }
          },
          {
            name: 'Dining & Food Delivery in Canada',
            priority: 2,
            multiplier: 1, // 2x total (1x base + 1x bonus)
            condition: {
              type: 'compound',
              operation: 'all', // AND logic
              subConditions: [
                {
                  type: 'mcc',
                  operation: 'include',
                  values: [
                    '5811', '5812', '5813', '5814', // Restaurants and dining
                    '5499' // Food delivery
                  ]
                },
                {
                  type: 'currency',
                  operation: 'equals',
                  values: ['CAD']
                }
              ]
            }
          },
          {
            name: 'Travel',
            priority: 3,
            multiplier: 1, // 2x total (1x base + 1x bonus)
            condition: {
              type: 'mcc',
              operation: 'include',
              values: [
                // Airlines
                ...[...Array(200)].map((_, i) => `${3000 + i}`),
                // Hotels
                '7011',
                // Car rentals
                '7512',
                // Travel agencies
                '4722',
                // Transportation services
                '4111', '4112', '4121', '4131', '4411', '4457', '4468', '4789'
              ]
            }
          }
        ]
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 10. Amex Cobalt Card Rule
   * Multiple tiers with monthly spending caps per category
   */
  private createAmexCobaltCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'amex-cobalt',
      name: 'Amex Cobalt Tiered Earning',
      description: 'Up to 5X MR points on eats & drinks, 2-3X on other categories',
      enabled: true,
      priority: 10,
      conditions: [], // Base rule applies to all transactions
      reward: {
        calculationMethod: 'direct',
        baseMultiplier: 1,
        bonusMultiplier: 0, // Base rate is 1x, set in the calculation
        pointsRoundingStrategy: 'nearest',
        amountRoundingStrategy: 'none',
        blockSize: 1,
        pointsCurrency: 'Membership Rewards Points',
        // Multiple tiers with different rates
        bonusTiers: [
          {
            name: 'Dining & Grocery',
            priority: 1,
            multiplier: 4, // 5x total (1x base + 4x bonus)
            condition: {
              type: 'mcc',
              operation: 'include',
              values: [
                '5811', '5812', '5814', // Restaurants
                '5411' // Grocery stores
              ]
            }
          },
          {
            name: 'Food Delivery',
            priority: 1,
            multiplier: 4, // 5x total (1x base + 4x bonus)
            condition: {
              type: 'mcc',
              operation: 'include',
              values: ['5499'] // Food delivery
            }
          },
          {
            name: 'Streaming Services',
            priority: 2,
            multiplier: 2, // 3x total (1x base + 2x bonus)
            condition: {
              type: 'merchant',
              operation: 'include',
              values: [
                'Apple TV+', 'Apple Music', 'Crave', 'Disney+', 'fuboTV',
                'hayu', 'Netflix', 'RDS', 'SiriusXM Canada', 'Spotify', 'TSN'
              ]
            }
          },
          {
            name: 'Travel & Transit',
            priority: 3,
            multiplier: 1, // 2x total (1x base + 1x bonus)
            condition: {
              type: 'compound',
              operation: 'any', // OR logic
              subConditions: [
                {
                  type: 'mcc',
                  operation: 'include',
                  values: [
                    // Airlines (first 300 codes for brevity)
                    ...[...Array(300)].map((_, i) => `${3000 + i}`),
                    // Hotels
                    '7011',
                    // Car rentals
                    '7512',
                    // Travel agencies
                    '4722'
                  ]
                },
                {
                  type: 'mcc',
                  operation: 'include',
                  values: [
                    '4111', '4121', '4789', // Local transit, taxis, transportation
                    '7299', '5734', '4214'  // Other services (ride-sharing apps)
                  ]
                },
                {
                  type: 'mcc',
                  operation: 'include',
                  values: [
                    '5541', '5542' // Gas stations
                  ]
                }
              ]
            }
          }
        ]
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 11. TD Aeroplan Visa Infinite Card Rule
   * 1.5X Aeroplan points on gas, grocery, and Air Canada purchases
   */
  private createTDAeroplanVisaInfiniteCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'td-aeroplan-visa-infinite',
      name: 'TD Aeroplan Visa Infinite 1.5X',
      description: '1.5X Aeroplan points on gas, grocery, and Air Canada purchases',
      enabled: true,
      priority: 10,
      conditions: [
        {
          type: 'compound',
          operation: 'any', // OR logic
          subConditions: [
            // Gas stations
            {
              type: 'mcc',
              operation: 'include',
              values: ['5541', '5542'] // Gas stations
            },
            // Grocery stores
            {
              type: 'mcc',
              operation: 'include',
              values: ['5411', '5422', '5441', '5451', '5462'] // Grocery stores
            },
            // Air Canada purchases
            {
              type: 'merchant',
              operation: 'include',
              values: ['Air Canada']
            }
          ]
        }
      ],
      reward: {
        calculationMethod: 'direct',
        baseMultiplier: 1,
        bonusMultiplier: 0.5, // 0.5x bonus points (1x base + 0.5x bonus = 1.5x total)
        pointsRoundingStrategy: 'nearest',
        amountRoundingStrategy: 'nearest',
        blockSize: 1,
        pointsCurrency: 'Aeroplan Points'
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
}

// Export a singleton instance
export const cardRegistry = CardRegistry.getInstance();

================
File: services/rewards/MonthlySpendingTracker.ts
================
// services/rewards/MonthlySpendingTracker.ts

import { PaymentMethod, Transaction } from '@/types';
import { supabase } from '@/integrations/supabase/client';
import { SpendingPeriodType } from './types';

/**
 * Service for tracking monthly spending for reward rules
 */
export class MonthlySpendingTracker {
  private static instance: MonthlySpendingTracker;
  private spendingCache: Map<string, number> = new Map();
  
  private constructor() {}
  
  /**
   * Get singleton instance
   */
  public static getInstance(): MonthlySpendingTracker {
    if (!MonthlySpendingTracker.instance) {
      MonthlySpendingTracker.instance = new MonthlySpendingTracker();
    }
    return MonthlySpendingTracker.instance;
  }
  
  /**
   * Get total monthly spending for a payment method
   */
  public async getMonthlySpending(
    paymentMethodId: string,
    periodType: SpendingPeriodType = 'calendar_month',
    date: Date = new Date(),
    statementDay: number = 1
  ): Promise<number> {
    // Create a cache key
    const cacheKey = this.createCacheKey(paymentMethodId, periodType, date, statementDay);
    
    // Check cache first
    if (this.spendingCache.has(cacheKey)) {
      return this.spendingCache.get(cacheKey) || 0;
    }
    
    try {
      // Calculate date range
      const { startDate, endDate } = this.calculateDateRange(date, periodType, statementDay);
      
      // Query database for transactions in this period
      const { data, error } = await supabase
        .from('transactions')
        .select('amount')
        .eq('payment_method_id', paymentMethodId)
        .gte('date', startDate.toISOString())
        .lt('date', endDate.toISOString())
        .eq('is_deleted', false);
        
      if (error) {
        console.error('Error fetching monthly spending:', error);
        return 0;
      }
      
      // Calculate total
      const totalSpending = data.reduce((sum, tx) => sum + (tx.amount || 0), 0);
      
      // Cache the result
      this.spendingCache.set(cacheKey, totalSpending);
      
      return totalSpending;
    } catch (error) {
      console.error('Error calculating monthly spending:', error);
      return 0;
    }
  }
  
  /**
   * Calculate monthly spending from an array of transactions
   * Useful when we don't have direct database access
   */
  public calculateMonthlySpendingFromTransactions(
    transactions: Transaction[],
    paymentMethodId: string,
    periodType: SpendingPeriodType = 'calendar_month',
    date: Date = new Date(),
    statementDay: number = 1
  ): number {
    try {
      // Calculate date range
      const { startDate, endDate } = this.calculateDateRange(date, periodType, statementDay);
      
      // Filter transactions by date range and payment method
      const relevantTransactions = transactions.filter(tx => {
        const txDate = new Date(tx.date);
        return tx.paymentMethod.id === paymentMethodId &&
               txDate >= startDate &&
               txDate < endDate;
      });
      
      // Calculate total
      return relevantTransactions.reduce((sum, tx) => sum + tx.amount, 0);
    } catch (error) {
      console.error('Error calculating monthly spending from transactions:', error);
      return 0;
    }
  }
  
  /**
   * Update monthly spending when a new transaction is added
   */
  public updateMonthlySpending(transaction: Transaction): void {
    // Clear all cache entries for this payment method
    // This is a simple approach - in a real implementation, you might
    // want to be more selective about which cache entries to invalidate
    this.clearCacheForPaymentMethod(transaction.paymentMethod.id);
  }
  
  /**
   * Clear cache for a payment method
   */
  public clearCacheForPaymentMethod(paymentMethodId: string): void {
    const keysToDelete: string[] = [];
    
    // Find all cache keys for this payment method
    for (const key of this.spendingCache.keys()) {
      if (key.startsWith(`${paymentMethodId}-`)) {
        keysToDelete.push(key);
      }
    }
    
    // Delete from cache
    keysToDelete.forEach(key => this.spendingCache.delete(key));
  }
  
  /**
   * Clear all cache
   */
  public clearCache(): void {
    this.spendingCache.clear();
  }
  
  /**
   * Create a cache key
   */
  private createCacheKey(
    paymentMethodId: string,
    periodType: SpendingPeriodType,
    date: Date,
    statementDay: number
  ): string {
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    return `${paymentMethodId}-${periodType}-${year}-${month}-${statementDay}`;
  }
  
  /**
   * Calculate date range for a period
   */
  private calculateDateRange(
    date: Date,
    periodType: SpendingPeriodType,
    statementDay: number
  ): { startDate: Date; endDate: Date } {
    const year = date.getFullYear();
    const month = date.getMonth();
    
    if (periodType === 'calendar_month') {
      // Calendar month: 1st day of month to last day of month
      const startDate = new Date(year, month, 1);
      const endDate = new Date(year, month + 1, 1);
      
      return { startDate, endDate };
    } else {
      // Statement month: statementDay of month to statementDay of next month
      let startMonth = month;
      let startYear = year;
      
      // If the current date is before statement day, use previous month's statement day
      if (date.getDate() < statementDay) {
        startMonth = month - 1;
        if (startMonth < 0) {
          startMonth = 11; // December
          startYear = year - 1;
        }
      }
      
      const startDate = new Date(startYear, startMonth, statementDay);
      
      // End date is the next statement day
      let endMonth = startMonth + 1;
      let endYear = startYear;
      if (endMonth > 11) {
        endMonth = 0; // January
        endYear += 1;
      }
      
      const endDate = new Date(endYear, endMonth, statementDay);
      
      return { startDate, endDate };
    }
  }
}

// Export a singleton instance
export const monthlySpendingTracker = MonthlySpendingTracker.getInstance();

================
File: services/rewards/rewardCalculationAdapter.ts
================
// services/rewards/rewardCalculationAdapter.ts

import { Transaction, PaymentMethod } from '@/types';
import { rewardCalculatorService } from '@/services/rewards/RewardCalculatorService';
import { TransactionType } from '@/services/rewards/types';
import { bonusPointsTrackingService } from '@/services/BonusPointsTrackingService';

/**
 * Adapter function for calculating points
 * This replaces the old calculator logic and reconnects it to the new system
 */
export async function calculateRewardPoints(transaction: Transaction): Promise<{
  basePoints: number;
  bonusPoints: number;
  totalPoints: number;
  pointsCurrency?: string;
}> {
  // Skip calculation for cash payments
  if (transaction.paymentMethod.type === 'cash') {
    return {
      basePoints: 0,
      bonusPoints: 0,
      totalPoints: 0
    };
  }
  
  try {
    // Get monthly used bonus points
    const usedBonusPoints = await bonusPointsTrackingService.getUsedBonusPoints(
      transaction.paymentMethod.id
    );
    
    // Use the new reward calculator service
    const result = await rewardCalculatorService.calculatePoints(
      transaction,
      usedBonusPoints
    );
    
    // If we successfully calculated the rewards, record the bonus points movement
    if (result.bonusPoints > 0) {
      await bonusPointsTrackingService.recordBonusPointsMovement(
        transaction.id,
        transaction.paymentMethod.id,
        result.bonusPoints
      );
    }
    
    return {
      basePoints: result.basePoints,
      bonusPoints: result.bonusPoints,
      totalPoints: result.totalPoints,
      pointsCurrency: result.pointsCurrency
    };
  } catch (error) {
    console.error('Error calculating reward points:', error);
    
    // Fallback to simple calculation
    return {
      basePoints: Math.round(transaction.amount),
      bonusPoints: 0,
      totalPoints: Math.round(transaction.amount)
    };
  }
}

/**
 * Adapter function for simulating points
 * This replaces the old simulator logic
 */
export async function simulateRewardPoints(
  amount: number,
  currency: string,
  paymentMethod: PaymentMethod,
  mcc?: string,
  merchantName?: string,
  isOnline?: boolean,
  isContactless?: boolean
): Promise<{
  totalPoints: number;
  basePoints?: number;
  bonusPoints?: number;
  remainingMonthlyBonusPoints?: number;
  messageText?: string;
  pointsCurrency?: string;
}> {
  if (paymentMethod.type === 'cash') {
    return { totalPoints: 0 };
  }
  
  try {
    // Determine transaction type
    let transactionType: TransactionType;
    if (isOnline) {
      transactionType = TransactionType.ONLINE;
    } else if (isContactless) {
      transactionType = TransactionType.CONTACTLESS;
    } else {
      transactionType = TransactionType.IN_STORE;
    }
    
    // Get monthly used bonus points
    const usedBonusPoints = await bonusPointsTrackingService.getUsedBonusPoints(
      paymentMethod.id
    );
    
    // Use the new reward calculator service
    const result = await rewardCalculatorService.simulatePoints(
      amount,
      currency,
      paymentMethod,
      mcc,
      merchantName,
      isOnline,
      isContactless,
      usedBonusPoints
    );
    
    // Format message text based on calculation results
    let messageText;
    if (result.messages.length > 0) {
      messageText = result.messages.join('. ');
    } else if (result.bonusPoints === 0 && result.remainingMonthlyBonusPoints === 0) {
      messageText = "Monthly bonus points cap reached";
    } else if (result.bonusPoints === 0 && result.remainingMonthlyBonusPoints !== undefined && result.remainingMonthlyBonusPoints > 0) {
      messageText = "Not eligible for bonus points";
    } else if (result.bonusPoints > 0) {
      messageText = `Earning ${result.bonusPoints} bonus points`;
    } else if (result.remainingMonthlyBonusPoints !== undefined) {
      messageText = `${result.remainingMonthlyBonusPoints.toLocaleString()} bonus points remaining this month`;
    }
    
    return {
      totalPoints: result.totalPoints,
      basePoints: result.basePoints,
      bonusPoints: result.bonusPoints,
      remainingMonthlyBonusPoints: result.remainingMonthlyBonusPoints,
      messageText,
      pointsCurrency: result.pointsCurrency
    };
  } catch (error) {
    console.error('Error simulating reward points:', error);
    
    // Provide a fallback response
    return { 
      totalPoints: Math.round(amount), 
      basePoints: Math.round(amount),
      bonusPoints: 0,
      messageText: 'Error calculating points' 
    };
  }
}

================
File: services/rewards/RewardCalculatorService.ts
================
// services/rewards/RewardCalculatorService.ts

import { Transaction, PaymentMethod } from '@/types';
import { 
  CalculationInput, 
  CalculationResult, 
  RewardRule,
  RuleCondition,
  TransactionType
} from './types';
import { v4 as uuidv4 } from 'uuid';
import { RuleEngine } from './RuleEngine';
import { RuleRepository } from './RuleRepository';
import { CardRegistry } from './CardRegistry';
import { MonthlySpendingTracker } from './MonthlySpendingTracker';

/**
 * Central service for all reward calculations
 */
export class RewardCalculatorService {
  private static instance: RewardCalculatorService;
  private ruleEngine: RuleEngine;
  private ruleRepository: RuleRepository;
  private cardRegistry: CardRegistry;
  private monthlySpendingTracker: MonthlySpendingTracker;
  private initialized = false;
  
  private constructor() {
    this.ruleEngine = new RuleEngine();
    this.ruleRepository = RuleRepository.getInstance();
    this.cardRegistry = CardRegistry.getInstance();
    this.monthlySpendingTracker = MonthlySpendingTracker.getInstance();
  }
  
  /**
   * Get singleton instance
   */
  public static getInstance(): RewardCalculatorService {
    if (!RewardCalculatorService.instance) {
      RewardCalculatorService.instance = new RewardCalculatorService();
    }
    return RewardCalculatorService.instance;
  }
  
  /**
   * Initialize service by loading all rules
   */
  public async initialize(): Promise<void> {
    if (!this.initialized) {
      await this.ruleRepository.loadRules();
      this.initialized = true;
      console.log('RewardCalculatorService initialized');
    }
  }
  
  /**
   * Calculate reward points for a transaction
   */
  public async calculatePoints(
    transaction: Transaction,
    usedBonusPoints: number = 0
  ): Promise<CalculationResult> {
    // Ensure the service is initialized
    if (!this.initialized) {
      await this.initialize();
    }
    
    // Create calculation input from transaction
    const input = await this.createCalculationInput(
      transaction,
      usedBonusPoints
    );
    
    // Get rules for this payment method
    const rules = await this.getRulesForPaymentMethod(transaction.paymentMethod);
    
    // Calculate rewards using the rule engine
    return this.ruleEngine.calculateRewards(input, rules);
  }
  
  /**
   * Simulate reward points for a hypothetical transaction
   */
  public async simulatePoints(
    amount: number,
    currency: string,
    paymentMethod: PaymentMethod,
    mcc?: string,
    merchantName?: string,
    isOnline?: boolean,
    isContactless?: boolean,
    usedBonusPoints: number = 0
  ): Promise<CalculationResult> {
    // Ensure the service is initialized
    if (!this.initialized) {
      await this.initialize();
    }
    
    // Determine transaction type from isOnline and isContactless
    let transactionType: TransactionType;
    if (isOnline) {
      transactionType = TransactionType.ONLINE;
    } else if (isContactless) {
      transactionType = TransactionType.CONTACTLESS;
    } else {
      transactionType = TransactionType.IN_STORE;
    }
    
    // Get monthly spending for minimum spend threshold
    const monthlySpend = await this.monthlySpendingTracker.getMonthlySpending(
      paymentMethod.id,
      'calendar_month',
      new Date(),
      paymentMethod.statementStartDay
    );
    
    // Create calculation input
    const input: CalculationInput = {
      amount,
      currency,
      mcc,
      merchantName,
      transactionType,
      usedBonusPoints,
      monthlySpend,
      paymentMethod,
      date: new Date(),
      statementDay: paymentMethod.statementStartDay
    };
    
    // Get rules for this payment method
    const rules = await this.getRulesForPaymentMethod(paymentMethod);
    
    // Calculate rewards using the rule engine
    return this.ruleEngine.calculateRewards(input, rules);
  }
  
  /**
   * Get point currency for a payment method
   */
  public getPointsCurrency(paymentMethod: PaymentMethod): string {
    // Try to get from card registry first
    const cardType = this.cardRegistry.getCardTypeByIssuerAndName(
      paymentMethod.issuer || '',
      paymentMethod.name || ''
    );
    
    if (cardType) {
      return cardType.pointsCurrency;
    }
    
    // Fallback to payment method properties
    if (paymentMethod.issuer) {
      return `${paymentMethod.issuer} Points`;
    }
    
    return 'Points';
  }
  
  /**
   * Create calculation input from transaction
   */
  private async createCalculationInput(
    transaction: Transaction,
    usedBonusPoints: number
  ): Promise<CalculationInput> {
    // Determine transaction type
    let transactionType: TransactionType;
    if (transaction.merchant?.isOnline) {
      transactionType = TransactionType.ONLINE;
    } else if (transaction.isContactless) {
      transactionType = TransactionType.CONTACTLESS;
    } else {
      transactionType = TransactionType.IN_STORE;
    }
    
    // Get monthly spending for minimum spend threshold
    const monthlySpend = await this.monthlySpendingTracker.getMonthlySpending(
      transaction.paymentMethod.id,
      'calendar_month',
      new Date(transaction.date),
      transaction.paymentMethod.statementStartDay
    );
    
    // Create input object
    return {
      amount: transaction.amount,
      currency: transaction.currency,
      mcc: transaction.merchant?.mcc?.code,
      merchantName: transaction.merchant?.name,
      transactionType,
      usedBonusPoints,
      monthlySpend,
      paymentMethod: transaction.paymentMethod,
      date: new Date(transaction.date),
      statementDay: transaction.paymentMethod.statementStartDay
    };
  }
  
  /**
   * Get rules for a payment method
   */
  private async getRulesForPaymentMethod(paymentMethod: PaymentMethod): Promise<RewardRule[]> {
    // Try to get card type ID
    let cardTypeId: string | undefined;
    
    if (paymentMethod.issuer && paymentMethod.name) {
      const cardType = this.cardRegistry.getCardTypeByIssuerAndName(
        paymentMethod.issuer,
        paymentMethod.name
      );
      
      if (cardType) {
        cardTypeId = cardType.id;
      } else {
        // Fallback to a normalized ID
        cardTypeId = `${paymentMethod.issuer.toLowerCase()}-${paymentMethod.name.toLowerCase().replace(/\s+/g, '-')}`;
      }
    } else {
      // Use payment method ID as fallback
      cardTypeId = paymentMethod.id;
    }
    
    // Get rules for this card type
    let rules = await this.ruleRepository.getRulesForCardType(cardTypeId);
    
    // If no rules found, check if this paymentMethod has custom rules
    if (rules.length === 0 && paymentMethod.rewardRules && paymentMethod.rewardRules.length > 0) {
      // Convert payment method reward rules to our format
      rules = paymentMethod.rewardRules.map(customRule => this.convertCustomRule(customRule, cardTypeId!));
    }
    
    // If still no rules, get default rules from card registry
    if (rules.length === 0) {
      const cardType = this.cardRegistry.getCardTypeByIssuerAndName(
        paymentMethod.issuer || '',
        paymentMethod.name || ''
      );
      
      if (cardType) {
        rules = cardType.defaultRules;
      }
    }
    
    // Handle category selection for cards with selectable categories
    if (paymentMethod.selectedCategories && paymentMethod.selectedCategories.length > 0) {
      rules = this.applySelectedCategories(rules, paymentMethod.selectedCategories);
    }
    
    return rules;
  }
  
  /**
   * Convert a custom reward rule to our standard format
   */
  private convertCustomRule(customRule: any, cardTypeId: string): RewardRule {
    // Implementation depends on your custom rule format
    // This is a simplified example
    return {
      id: customRule.id || uuidv4(),
      cardTypeId,
      name: customRule.name || 'Custom Rule',
      description: customRule.description || '',
      enabled: true,
      priority: customRule.priority || 10,
      conditions: this.convertCustomConditions(customRule),
      reward: {
        calculationMethod: 'standard',
        baseMultiplier: 1,
        bonusMultiplier: customRule.pointsMultiplier ? customRule.pointsMultiplier - 1 : 0,
        pointsRoundingStrategy: 'floor',
        amountRoundingStrategy: 'floor',
        blockSize: 1,
        monthlyCap: customRule.maxSpend,
        pointsCurrency: customRule.pointsCurrency || 'Points'
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * Convert custom conditions to our format
   */
  private convertCustomConditions(customRule: any): RuleCondition[] {
    const conditions: RuleCondition[] = [];
    
    // Check rule type and create appropriate condition
    switch (customRule.type) {
      case 'online':
        conditions.push({
          type: 'transaction_type',
          operation: 'equals',
          values: [TransactionType.ONLINE]
        });
        break;
        
      case 'contactless':
        conditions.push({
          type: 'transaction_type',
          operation: 'equals',
          values: [TransactionType.CONTACTLESS]
        });
        break;
        
      case 'mcc':
        if (Array.isArray(customRule.condition)) {
          conditions.push({
            type: 'mcc',
            operation: 'include',
            values: customRule.condition
          });
        }
        break;
        
      case 'merchant':
        if (typeof customRule.condition === 'string' || Array.isArray(customRule.condition)) {
          conditions.push({
            type: 'merchant',
            operation: 'include',
            values: Array.isArray(customRule.condition) ? 
              customRule.condition : [customRule.condition]
          });
        }
        break;
        
      case 'currency':
        if (Array.isArray(customRule.condition)) {
          const excludedCurrencies = customRule.condition
            .filter((curr: string) => curr.startsWith('!'))
            .map((curr: string) => curr.substring(1));
          
          const includedCurrencies = customRule.condition
            .filter((curr: string) => !curr.startsWith('!'));
          
          if (excludedCurrencies.length > 0) {
            conditions.push({
              type: 'currency',
              operation: 'exclude',
              values: excludedCurrencies
            });
          }
          
          if (includedCurrencies.length > 0) {
            conditions.push({
              type: 'currency',
              operation: 'include',
              values: includedCurrencies
            });
          }
        }
        break;
    }
    
    return conditions;
  }
  
  /**
   * Apply selected categories to rules
   */
  private applySelectedCategories(rules: RewardRule[], selectedCategories: string[]): RewardRule[] {
    return rules.map(rule => {
      // Create a deep copy of the rule
      const updatedRule = JSON.parse(JSON.stringify(rule));
      
      // Update conditions that have a category type
      updatedRule.conditions = rule.conditions.map((condition: RuleCondition) => {
        if (condition.type === 'category') {
          return {
            ...condition,
            values: selectedCategories
          };
        }
        return condition;
      });
      
      return updatedRule;
    });
  }
}

// Export a singleton instance
export const rewardCalculatorService = RewardCalculatorService.getInstance();

================
File: services/rewards/RuleEngine.ts
================
// services/rewards/RuleEngine.ts

import { 
  CalculationInput, 
  CalculationResult, 
  RewardRule, 
  RuleCondition,
  RoundingStrategy,
  TransactionType,
  SpendingPeriodType,
  BonusTier
} from './types';

export class RuleEngine {
  /**
   * Calculate reward points for a given input based on rules
   */
  public calculateRewards(input: CalculationInput, rules: RewardRule[]): CalculationResult {
    // Filter for enabled rules only
    const enabledRules = rules.filter(rule => rule.enabled);
    
    // Sort by priority (highest first)
    enabledRules.sort((a, b) => b.priority - a.priority);
    
    // Find applicable rules
    const applicableRules = enabledRules.filter(rule => 
      this.evaluateConditions(rule.conditions, input)
    );
    
    // If no rules apply, return default calculation
    if (applicableRules.length === 0) {
      return {
        totalPoints: Math.round(input.amount),
        basePoints: Math.round(input.amount),
        bonusPoints: 0,
        pointsCurrency: input.paymentMethod.issuer ? `${input.paymentMethod.issuer} Points` : 'Points',
        minSpendMet: false,
        messages: ['No specific reward rules applied']
      };
    }
    
    // Use the highest priority matching rule
    const rule = applicableRules[0];
    
    // Check if minimum monthly spend threshold is met
    const minSpendMet = this.isMinimumSpendMet(rule, input);
    
    // Find the applicable bonus tier if any exist
    let appliedTier: BonusTier | undefined;
    let effectiveMultiplier = rule.reward.bonusMultiplier;

    if (rule.reward.bonusTiers && rule.reward.bonusTiers.length > 0 && minSpendMet) {
      // Filter tiers that match the input
      const matchingTiers = rule.reward.bonusTiers
        .filter(tier => {
          // Check if the tier has a compound condition
          if (tier.condition.type === 'compound') {
            return this.evaluateCondition(tier.condition, input);
          } else {
            // Single condition
            return this.evaluateCondition(tier.condition, input);
          }
        })
        .sort((a, b) => b.priority - a.priority); // Sort by priority (highest first)
      
      // If we have a matching tier, use its multiplier
      if (matchingTiers.length > 0) {
        appliedTier = matchingTiers[0];
        effectiveMultiplier = appliedTier.multiplier;
      }
    }
    
    // Calculate points based on rule's calculation method
    let basePoints: number, bonusPoints: number;
    
    if (rule.reward.calculationMethod === 'standard') {
      // Standard method:
      // 1. Round amount according to strategy
      // 2. Divide by block size
      // 3. Multiply by rates
      const roundedAmount = this.applyRounding(
        input.amount, 
        rule.reward.amountRoundingStrategy
      );
      
      // Calculate points per block
      const pointsPerBlock = roundedAmount / rule.reward.blockSize;
      
      // Apply base rate (always 1x)
      basePoints = this.applyRounding(
        pointsPerBlock * rule.reward.baseMultiplier, 
        rule.reward.pointsRoundingStrategy
      );
      
      // Only apply bonus rate if minimum spend threshold is met
      if (minSpendMet) {
        bonusPoints = this.applyRounding(
          pointsPerBlock * effectiveMultiplier,
          rule.reward.pointsRoundingStrategy
        );
      } else {
        bonusPoints = 0;
      }
    } else {
      // Direct method:
      // 1. Multiply amount by total rate (base=1 + bonus multiplier)
      // 2. Round the result
      
      // Base points calculation 
      basePoints = this.applyRounding(
        input.amount * rule.reward.baseMultiplier,
        rule.reward.pointsRoundingStrategy
      );
      
      // Only apply bonus if minimum spend threshold is met
      if (minSpendMet) {
        // Calculate total points with multiplier
        const totalPoints = this.applyRounding(
          input.amount * (rule.reward.baseMultiplier + effectiveMultiplier),
          rule.reward.pointsRoundingStrategy
        );
        
        // Bonus is the difference between total and base
        bonusPoints = totalPoints - basePoints;
      } else {
        bonusPoints = 0;
      }
    }
    
    // Apply monthly cap if specified
    let actualBonusPoints = bonusPoints;
    let remainingMonthlyBonusPoints;
    
    if (rule.reward.monthlyCap && rule.reward.monthlyCap > 0 && minSpendMet) {
      const usedBonusPoints = input.usedBonusPoints || 0;
      
      // Check if already reached the cap
      if (usedBonusPoints >= rule.reward.monthlyCap) {
        actualBonusPoints = 0;
        remainingMonthlyBonusPoints = 0;
      } else {
        // Check if this would exceed the cap
        const remainingCap = rule.reward.monthlyCap - usedBonusPoints;
        if (bonusPoints > remainingCap) {
          actualBonusPoints = remainingCap;
          remainingMonthlyBonusPoints = 0;
        } else {
          remainingMonthlyBonusPoints = remainingCap - bonusPoints;
        }
      }
    }
    
    // Create messages
    const messages: string[] = [];
    
    if (!minSpendMet && rule.reward.monthlyMinSpend) {
      messages.push(`Minimum monthly spend of ${rule.reward.monthlyMinSpend} not met for bonus points`);
    } else if (bonusPoints > 0 && actualBonusPoints === 0) {
      messages.push('Monthly bonus points cap reached');
    } else if (appliedTier) {
      messages.push(`Applied tier: ${appliedTier.name} (${effectiveMultiplier}x)`);
    } else if (rule.description) {
      messages.push(`Applied rule: ${rule.description}`);
    }
    
    // Return the result
    return {
      totalPoints: basePoints + actualBonusPoints,
      basePoints,
      bonusPoints: actualBonusPoints,
      pointsCurrency: rule.reward.pointsCurrency,
      remainingMonthlyBonusPoints,
      minSpendMet,
      appliedRule: rule,
      appliedTier,
      messages
    };
  }
  
  /**
   * Check if minimum monthly spend threshold is met
   */
  private isMinimumSpendMet(rule: RewardRule, input: CalculationInput): boolean {
    // If no minimum spend requirement, always return true
    if (!rule.reward.monthlyMinSpend || rule.reward.monthlyMinSpend <= 0) {
      return true;
    }
    
    // If monthly spend data is not provided, assume threshold is not met
    if (!input.monthlySpend) {
      return false;
    }
    
    // Check if spend meets or exceeds threshold
    return input.monthlySpend >= rule.reward.monthlyMinSpend;
  }
  
  /**
   * Evaluate if all conditions in a rule apply to the input
   */
  private evaluateConditions(conditions: RuleCondition[], input: CalculationInput): boolean {
    // If no conditions, the rule applies
    if (!conditions || conditions.length === 0) {
      return true;
    }
    
    // All conditions must be satisfied (AND logic)
    for (const condition of conditions) {
      if (!this.evaluateCondition(condition, input)) {
        return false;
      }
    }
    
    return true;
  }
  
  /**
   * Evaluate a single condition
   */
  public evaluateCondition(condition: RuleCondition, input: CalculationInput): boolean {
    // For compound conditions
    if (condition.type === 'compound') {
      if (!condition.subConditions || condition.subConditions.length === 0) {
        return true;
      }
      
      if (condition.operation === 'all') {
        // AND logic - all must be true
        return condition.subConditions.every(subCondition => 
          this.evaluateCondition(subCondition, input)
        );
      } else if (condition.operation === 'any') {
        // OR logic - any can be true
        return condition.subConditions.some(subCondition => 
          this.evaluateCondition(subCondition, input)
        );
      }
      
      return false;
    }
    
    // Handle specific condition types
    switch (condition.type) {
      case 'mcc':
        return this.evaluateMccCondition(condition, input);
      
      case 'merchant':
        return this.evaluateMerchantCondition(condition, input);
      
      case 'transaction_type':
        return this.evaluateTransactionTypeCondition(condition, input);
      
      case 'currency':
        return this.evaluateCurrencyCondition(condition, input);
      
      case 'amount':
        return this.evaluateAmountCondition(condition, input);
      
      case 'date':
        return this.evaluateDateCondition(condition, input);
      
      case 'category':
        return this.evaluateCategoryCondition(condition, input);
      
      case 'spend_threshold':
        return this.evaluateSpendThresholdCondition(condition, input);
      
      default:
        return false;
    }
  }
  
  /**
   * Evaluate MCC code condition
   */
  private evaluateMccCondition(condition: RuleCondition, input: CalculationInput): boolean {
    if (!input.mcc || !condition.values) {
      return false;
    }
    
    if (condition.operation === 'include') {
      return (condition.values as string[]).includes(input.mcc);
    } else if (condition.operation === 'exclude') {
      return !(condition.values as string[]).includes(input.mcc);
    }
    
    return false;
  }
  
  /**
   * Evaluate merchant name condition
   */
  private evaluateMerchantCondition(condition: RuleCondition, input: CalculationInput): boolean {
    if (!input.merchantName || !condition.values) {
      return false;
    }
    
    const merchantNameLower = input.merchantName.toLowerCase();
    
    if (condition.operation === 'include') {
      return (condition.values as string[]).some(name => 
        merchantNameLower.includes(name.toLowerCase())
      );
    } else if (condition.operation === 'exclude') {
      return !(condition.values as string[]).some(name => 
        merchantNameLower.includes(name.toLowerCase())
      );
    } else if (condition.operation === 'equals') {
      return (condition.values as string[]).some(name => 
        merchantNameLower === name.toLowerCase()
      );
    }
    
    return false;
  }
  
  /**
   * Evaluate transaction type condition (online/contactless/in-store)
   */
  private evaluateTransactionTypeCondition(condition: RuleCondition, input: CalculationInput): boolean {
    if (!condition.values) {
      return false;
    }
    
    if (condition.operation === 'equals') {
      return (condition.values as TransactionType[]).includes(input.transactionType);
    } else if (condition.operation === 'not_equals') {
      return !(condition.values as TransactionType[]).includes(input.transactionType);
    }
    
    return false;
  }
  
  /**
   * Evaluate currency condition
   */
  private evaluateCurrencyCondition(condition: RuleCondition, input: CalculationInput): boolean {
    if (!condition.values) {
      return false;
    }
    
    if (condition.operation === 'include') {
      return (condition.values as string[]).includes(input.currency);
    } else if (condition.operation === 'exclude') {
      return !(condition.values as string[]).includes(input.currency);
    } else if (condition.operation === 'equals') {
      return input.currency === condition.values[0];
    } else if (condition.operation === 'not_equals') {
      return input.currency !== condition.values[0];
    }
    
    return false;
  }
  
  /**
   * Evaluate amount condition
   */
  private evaluateAmountCondition(condition: RuleCondition, input: CalculationInput): boolean {
    if (!condition.values) {
      return false;
    }
    
    const amount = input.amount;
    
    if (condition.operation === 'greater_than') {
      return amount > (condition.values[0] as number);
    } else if (condition.operation === 'less_than') {
      return amount < (condition.values[0] as number);
    } else if (condition.operation === 'between') {
      return amount >= (condition.values[0] as number) && 
             amount <= (condition.values[1] as number);
    } else if (condition.operation === 'equals') {
      return amount === (condition.values[0] as number);
    }
    
    return false;
  }
  
  /**
   * Evaluate date condition
   */
  private evaluateDateCondition(condition: RuleCondition, input: CalculationInput): boolean {
    if (!condition.values || !input.date) {
      return false;
    }
    
    // Implementation depends on your needs
    return true;
  }
  
  /**
   * Evaluate category condition
   */
  private evaluateCategoryCondition(condition: RuleCondition, input: CalculationInput): boolean {
    if (!input.category || !condition.values) {
      return false;
    }
    
    if (condition.operation === 'include') {
      return (condition.values as string[]).includes(input.category);
    } else if (condition.operation === 'exclude') {
      return !(condition.values as string[]).includes(input.category);
    } else if (condition.operation === 'equals') {
      return input.category === condition.values[0];
    }
    
    return false;
  }
  
  /**
   * Evaluate spend threshold condition
   */
  private evaluateSpendThresholdCondition(condition: RuleCondition, input: CalculationInput): boolean {
    if (!condition.values || !input.monthlySpend) {
      return false;
    }
    
    const monthlySpend = input.monthlySpend;
    
    if (condition.operation === 'greater_than') {
      return monthlySpend > (condition.values[0] as number);
    } else if (condition.operation === 'less_than') {
      return monthlySpend < (condition.values[0] as number);
    } else if (condition.operation === 'between') {
      return monthlySpend >= (condition.values[0] as number) && 
             monthlySpend <= (condition.values[1] as number);
    } else if (condition.operation === 'equals') {
      return monthlySpend === (condition.values[0] as number);
    }
    
    return false;
  }
  
  /**
   * Apply rounding strategy to a number
   */
  private applyRounding(value: number, strategy: RoundingStrategy): number {
    switch (strategy) {
      case 'floor':
        return Math.floor(value);
      
      case 'ceiling':
        return Math.ceil(value);
      
      case 'nearest':
        return Math.round(value);
      
      case 'floor5':
        return Math.floor(value / 5) * 5;
      
      case 'none':
      default:
        return value;
    }
  }
}

================
File: services/rewards/RuleRepository.ts
================
// services/rewards/RuleRepository.ts

import { RewardRule, BonusTier } from './types';
import { supabase } from '@/integrations/supabase/client';

/**
 * Repository for storing and retrieving reward rules
 */
export class RuleRepository {
  private static instance: RuleRepository;
  private rules: Map<string, RewardRule> = new Map();
  private rulesByCardType: Map<string, RewardRule[]> = new Map();
  
  private constructor() {}
  
  /**
   * Get singleton instance
   */
  public static getInstance(): RuleRepository {
    if (!RuleRepository.instance) {
      RuleRepository.instance = new RuleRepository();
    }
    return RuleRepository.instance;
  }
  
  /**
   * Load all rules from the database
   */
  public async loadRules(): Promise<RewardRule[]> {
    try {
      const { data, error } = await supabase
        .from('reward_rules')
        .select('*');
        
      if (error) {
        console.error('Error loading rules:', error);
        return [];
      }
      
      const rules: RewardRule[] = data.map(this.mapDbRuleToRewardRule);
      
      // Store rules in memory
      this.rules.clear();
      this.rulesByCardType.clear();
      
      rules.forEach(rule => {
        this.rules.set(rule.id, rule);
        
        // Group by card type
        if (!this.rulesByCardType.has(rule.cardTypeId)) {
          this.rulesByCardType.set(rule.cardTypeId, []);
        }
        
        this.rulesByCardType.get(rule.cardTypeId)?.push(rule);
      });
      
      return rules;
    } catch (error) {
      console.error('Error loading rules:', error);
      return [];
    }
  }
  
  /**
   * Get rules for a specific card type
   */
  public async getRulesForCardType(cardTypeId: string): Promise<RewardRule[]> {
    // Check cache first
    if (this.rulesByCardType.has(cardTypeId)) {
      return this.rulesByCardType.get(cardTypeId) || [];
    }
    
    try {
      const { data, error } = await supabase
        .from('reward_rules')
        .select('*')
        .eq('card_type_id', cardTypeId)
        .eq('enabled', true);
        
      if (error) {
        console.error('Error loading rules for card type:', error);
        return [];
      }
      
      const rules: RewardRule[] = data.map(this.mapDbRuleToRewardRule);
      
      // Cache results
      this.rulesByCardType.set(cardTypeId, rules);
      rules.forEach(rule => this.rules.set(rule.id, rule));
      
      return rules;
    } catch (error) {
      console.error('Error loading rules for card type:', error);
      return [];
    }
  }
  
  /**
   * Get a rule by ID
   */
  public async getRule(id: string): Promise<RewardRule | null> {
    // Check cache first
    if (this.rules.has(id)) {
      return this.rules.get(id) || null;
    }
    
    try {
      const { data, error } = await supabase
        .from('reward_rules')
        .select('*')
        .eq('id', id)
        .single();
        
      if (error || !data) {
        console.error('Error loading rule:', error);
        return null;
      }
      
      const rule = this.mapDbRuleToRewardRule(data);
      
      // Cache the result
      this.rules.set(rule.id, rule);
      
      // Add to card type mapping
      if (!this.rulesByCardType.has(rule.cardTypeId)) {
        this.rulesByCardType.set(rule.cardTypeId, []);
      }
      this.rulesByCardType.get(rule.cardTypeId)?.push(rule);
      
      return rule;
    } catch (error) {
      console.error('Error loading rule:', error);
      return null;
    }
  }
  
  /**
   * Save a rule
   */
  public async saveRule(rule: RewardRule): Promise<RewardRule | null> {
    try {
      const dbRule = this.mapRewardRuleToDbRule(rule);
      
      const { data, error } = await supabase
        .from('reward_rules')
        .upsert(dbRule)
        .select()
        .single();
        
      if (error) {
        console.error('Error saving rule:', error);
        return null;
      }
      
      const savedRule = this.mapDbRuleToRewardRule(data);
      
      // Update cache
      this.rules.set(savedRule.id, savedRule);
      
      // Update card type mapping
      if (!this.rulesByCardType.has(savedRule.cardTypeId)) {
        this.rulesByCardType.set(savedRule.cardTypeId, []);
      }
      
      const cardRules = this.rulesByCardType.get(savedRule.cardTypeId) || [];
      const existingIndex = cardRules.findIndex(r => r.id === savedRule.id);
      
      if (existingIndex >= 0) {
        cardRules[existingIndex] = savedRule;
      } else {
        cardRules.push(savedRule);
      }
      
      this.rulesByCardType.set(savedRule.cardTypeId, cardRules);
      
      return savedRule;
    } catch (error) {
      console.error('Error saving rule:', error);
      return null;
    }
  }
  
  /**
   * Delete a rule
   */
  public async deleteRule(id: string): Promise<boolean> {
    try {
      const { error } = await supabase
        .from('reward_rules')
        .delete()
        .eq('id', id);
        
      if (error) {
        console.error('Error deleting rule:', error);
        return false;
      }
      
      // Get rule from cache to get its card type
      const rule = this.rules.get(id);
      
      // Remove from cache
      this.rules.delete(id);
      
      // Remove from card type mapping
      if (rule) {
        const cardRules = this.rulesByCardType.get(rule.cardTypeId) || [];
        this.rulesByCardType.set(
          rule.cardTypeId,
          cardRules.filter(r => r.id !== id)
        );
      }
      
      return true;
    } catch (error) {
      console.error('Error deleting rule:', error);
      return false;
    }
  }
  
  /**
   * Map database rule to RewardRule
   */
  private mapDbRuleToRewardRule(dbRule: any): RewardRule {
    // Parse JSON fields
    const conditions = typeof dbRule.conditions === 'string' ? 
      JSON.parse(dbRule.conditions) : dbRule.conditions || [];
    
    // Parse bonus tiers if present
    let bonusTiers: BonusTier[] | undefined;
    if (dbRule.bonus_tiers) {
      try {
        bonusTiers = typeof dbRule.bonus_tiers === 'string' ?
          JSON.parse(dbRule.bonus_tiers) : dbRule.bonus_tiers;
        
        // Make sure compound conditions are properly parsed
        if (bonusTiers) {
          bonusTiers = bonusTiers.map((tier: any) => {
            // If it's a compound condition, ensure subConditions are properly formatted
            if (tier.condition?.type === 'compound' && typeof tier.condition.subConditions === 'string') {
              tier.condition.subConditions = JSON.parse(tier.condition.subConditions);
            }
            return tier;
          });
        }
      } catch (e) {
        console.error('Error parsing bonus tiers:', e);
      }
    }
    
    return {
      id: dbRule.id,
      cardTypeId: dbRule.card_type_id,
      name: dbRule.name,
      description: dbRule.description || '',
      enabled: dbRule.enabled,
      priority: dbRule.priority || 0,
      conditions,
      reward: {
        calculationMethod: dbRule.calculation_method || 'standard',
        baseMultiplier: dbRule.base_multiplier || 0,
        bonusMultiplier: dbRule.bonus_multiplier || 0,
        pointsRoundingStrategy: dbRule.points_rounding_strategy || 'floor',
        amountRoundingStrategy: dbRule.amount_rounding_strategy || 'floor',
        blockSize: dbRule.block_size || 1,
        bonusTiers,
        monthlyCap: dbRule.monthly_cap,
        monthlyMinSpend: dbRule.monthly_min_spend,
        monthlySpendPeriodType: dbRule.monthly_spend_period_type,
        pointsCurrency: dbRule.points_currency || 'Points'
      },
      createdAt: new Date(dbRule.created_at),
      updatedAt: new Date(dbRule.updated_at || dbRule.created_at)
    };
  }
  
  /**
   * Map RewardRule to database rule
   */
  private mapRewardRuleToDbRule(rule: RewardRule): any {
    return {
      id: rule.id,
      card_type_id: rule.cardTypeId,
      name: rule.name,
      description: rule.description,
      enabled: rule.enabled,
      priority: rule.priority,
      conditions: JSON.stringify(rule.conditions),
      calculation_method: rule.reward.calculationMethod,
      base_multiplier: rule.reward.baseMultiplier,
      bonus_multiplier: rule.reward.bonusMultiplier,
      points_rounding_strategy: rule.reward.pointsRoundingStrategy,
      amount_rounding_strategy: rule.reward.amountRoundingStrategy,
      block_size: rule.reward.blockSize,
      bonus_tiers: rule.reward.bonusTiers ? JSON.stringify(rule.reward.bonusTiers) : null,
      monthly_cap: rule.reward.monthlyCap,
      monthly_min_spend: rule.reward.monthlyMinSpend,
      monthly_spend_period_type: rule.reward.monthlySpendPeriodType,
      points_currency: rule.reward.pointsCurrency,
      created_at: rule.createdAt.toISOString(),
      updated_at: rule.updatedAt.toISOString()
    };
  }
}

// Export a singleton instance
export const ruleRepository = RuleRepository.getInstance();

================
File: services/rewards/types.ts
================
// services/rewards/types.ts

import { PaymentMethod } from "@/types";

/**
 * Transaction type enum (mutually exclusive types)
 */
export enum TransactionType {
  ONLINE = 'online',
  CONTACTLESS = 'contactless',
  IN_STORE = 'in_store' // Neither online nor contactless
}

/**
 * Condition types supported by the rule engine
 */
export type ConditionType = 
  | 'mcc' 
  | 'merchant' 
  | 'transaction_type' // For online/contactless/in_store
  | 'currency'
  | 'amount'
  | 'date'
  | 'category'
  | 'spend_threshold' // For minimum monthly spend
  | 'compound';

/**
 * Condition interface - defines what makes a transaction eligible for a rule
 */
export interface RuleCondition {
  type: ConditionType;
  operation: 'include' | 'exclude' | 'equals' | 'not_equals' | 'greater_than' | 'less_than' | 'between' | 'any' | 'all';
  values?: string[] | number[] | boolean[] | TransactionType[];
  subConditions?: RuleCondition[]; // For compound conditions (AND/OR)
  field?: string; // For dynamic field conditions
}

/**
 * Reward calculation method
 */
export type CalculationMethod = 
  | 'standard'      // Amount is rounded first, then divided by blockSize, then multiplied by rate
  | 'direct';       // Amount is multiplied by rate first, then rounded

/**
 * Rounding strategy for amount and points
 */
export type RoundingStrategy = 
  | 'floor'     // Round down
  | 'ceiling'   // Round up
  | 'nearest'   // Round to nearest
  | 'floor5'    // Round down to nearest $5
  | 'none';     // No rounding

/**
 * Period type for minimum spend threshold
 */
export type SpendingPeriodType = 
  | 'statement_month'  // Based on card's statement cycle
  | 'calendar_month';  // Based on calendar month

/**
 * Bonus tier definition
 */
export interface BonusTier {
  name: string;
  multiplier: number;
  priority: number;
  // Modify the condition to support compound conditions
  condition: RuleCondition | {
    type: 'compound',
    operation: 'any' | 'all', // 'any' for OR logic, 'all' for AND logic
    subConditions: RuleCondition[]
  };
}

/**
 * Reward definition - defines how points are calculated
 */
export interface RuleReward {
  calculationMethod: CalculationMethod;
  baseMultiplier: number // Default base multiplier
  bonusMultiplier: number; // Default bonus multiplier
  pointsRoundingStrategy: RoundingStrategy; // How to round the calculated points
  amountRoundingStrategy: RoundingStrategy; // How to round the amount before calculation
  blockSize: number; // Amount per point block (usually 1 or 5)
  bonusTiers?: BonusTier[]; // Multiple bonus tiers with different multipliers
  monthlyCap?: number; // Maximum bonus points per month (shared across all tiers)
  monthlyMinSpend?: number; // Minimum spend required to activate bonus rate
  monthlySpendPeriodType?: SpendingPeriodType; // Whether minimum spend is per statement or calendar month
  pointsCurrency: string; // What kind of points this earns
}

/**
 * Complete rule definition
 */
export interface RewardRule {
  id: string;
  cardTypeId: string;
  name: string;
  description: string;
  enabled: boolean;
  priority: number; // Higher priority rules are applied first
  conditions: RuleCondition[];
  reward: RuleReward;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Input for rule engine calculation
 */
export interface CalculationInput {
  amount: number;
  currency: string;
  mcc?: string;
  merchantName?: string;
  transactionType: TransactionType; // Updated to use enum
  usedBonusPoints?: number;
  monthlySpend?: number; // Total eligible spend this month for threshold calculation
  paymentMethod: PaymentMethod;
  date: Date;
  category?: string;
  statementDay?: number; // Day of month when statement cycle starts
  [key: string]: any; // For extensibility
}

/**
 * Result of rule engine calculation
 */
export interface CalculationResult {
  totalPoints: number;
  basePoints: number;
  bonusPoints: number;
  pointsCurrency: string;
  remainingMonthlyBonusPoints?: number;
  minSpendMet: boolean; // Whether minimum spend threshold was met
  appliedRule?: RewardRule; // The rule that was applied
  appliedTier?: BonusTier; // The bonus tier that was applied (if any)
  messages: string[];
}

/**
 * Card type definition
 */
export interface CardType {
  id: string;
  issuer: string;
  name: string;
  defaultRules: RewardRule[];
  pointsCurrency: string;
  hasCategories?: boolean;
  availableCategories?: string[];
  maxCategoriesSelectable?: number;
  statementDay?: number; // Default statement cycle start day (1-31)
}

================
File: services/BonusPointsTrackingService.ts
================
// src/services/BonusPointsTrackingService.ts
import { Transaction, PaymentMethod } from '@/types';
import { supabase } from '@/integrations/supabase/client';

/**
 * Service for tracking used bonus points per payment method and month
 */
export class BonusPointsTrackingService {
  private static instance: BonusPointsTrackingService;
  
  // In-memory cache for performance
  private bonusPointsCache: Map<string, number> = new Map();
  
  private constructor() {}
  
  /**
   * Get the singleton instance of the BonusPointsTrackingService
   */
  public static getInstance(): BonusPointsTrackingService {
    if (!BonusPointsTrackingService.instance) {
      BonusPointsTrackingService.instance = new BonusPointsTrackingService();
    }
    return BonusPointsTrackingService.instance;
  }
  
  /**
   * Get used bonus points for a payment method in the current month
   */
  public async getUsedBonusPoints(
    paymentMethodId: string,
    year: number = new Date().getFullYear(),
    month: number = new Date().getMonth()
  ): Promise<number> {
    // Check cache first
    const cacheKey = `${paymentMethodId}-${year}-${month}`;
    if (this.bonusPointsCache.has(cacheKey)) {
      return this.bonusPointsCache.get(cacheKey) || 0;
    }
    
    try {
      // Try to query the database for used bonus points
      try {
        const { data, error } = await supabase
          .from('bonus_points_movements')
          .select('bonus_points')
          .eq('payment_method_id', paymentMethodId)
          .gte('created_at', new Date(year, month, 1).toISOString())
          .lt('created_at', new Date(year, month + 1, 1).toISOString());
          
        if (!error && data) {
          // Sum up the bonus points
          const totalBonusPoints = data.reduce((sum, record) => sum + record.bonus_points, 0);
          
          // Update cache
          this.bonusPointsCache.set(cacheKey, totalBonusPoints);
          
          return totalBonusPoints;
        }
      } catch (dbError) {
        console.log('Database query failed, falling back to localStorage:', dbError);
      }
      
      // If database query fails or is not available, fall back to localStorage
      const localStorageKey = `bonusPoints-${paymentMethodId}-${year}-${month}`;
      const storedValue = localStorage.getItem(localStorageKey);
      
      if (storedValue) {
        const totalBonusPoints = parseInt(storedValue, 10);
        this.bonusPointsCache.set(cacheKey, totalBonusPoints);
        return totalBonusPoints;
      }
      
      return 0;
    } catch (error) {
      console.error('Exception in getUsedBonusPoints:', error);
      return 0;
    }
  }
  
  /**
   * Record a bonus points movement
   */
  public async recordBonusPointsMovement(
    transactionId: string,
    paymentMethodId: string,
    bonusPoints: number
  ): Promise<boolean> {
    try {
      // Skip recording if bonus points is zero
      if (bonusPoints === 0) return true;
      
      // Try to record in the database first
      try {
        const { error } = await supabase
          .from('bonus_points_movements')
          .insert({
            transaction_id: transactionId,
            payment_method_id: paymentMethodId,
            bonus_points: bonusPoints
          });
          
        if (!error) {
          // Database insert succeeded
          const now = new Date();
          const cacheKey = `${paymentMethodId}-${now.getFullYear()}-${now.getMonth()}`;
          this.bonusPointsCache.delete(cacheKey);
          return true;
        }
      } catch (dbError) {
        console.log('Database insert failed, falling back to localStorage:', dbError);
      }
      
      // If database insert fails, fall back to localStorage
      const now = new Date();
      const year = now.getFullYear();
      const month = now.getMonth();
      
      const localStorageKey = `bonusPoints-${paymentMethodId}-${year}-${month}`;
      const currentValue = localStorage.getItem(localStorageKey) || '0';
      const updatedValue = parseInt(currentValue, 10) + bonusPoints;
      
      localStorage.setItem(localStorageKey, updatedValue.toString());
      
      // Invalidate cache
      const cacheKey = `${paymentMethodId}-${year}-${month}`;
      this.bonusPointsCache.delete(cacheKey);
      
      return true;
    } catch (error) {
      console.error('Exception in recordBonusPointsMovement:', error);
      return false;
    }
  }
  
  /**
   * Calculate used bonus points from a set of transactions
   * Useful when we don't have direct access to the bonus_points_movements table
   */
  public calculateUsedBonusPointsFromTransactions(
    transactions: Transaction[],
    paymentMethodId: string,
    year: number = new Date().getFullYear(),
    month: number = new Date().getMonth()
  ): number {
    // Filter transactions by payment method and month
    const relevantTransactions = transactions.filter(tx => {
      const txDate = new Date(tx.date);
      return tx.paymentMethod.id === paymentMethodId &&
             txDate.getFullYear() === year &&
             txDate.getMonth() === month;
    });
    
    // Calculate total bonus points used
    let totalBonusPoints = 0;
    
    for (const tx of relevantTransactions) {
      // Extract bonus points from transaction, if available
      const bonusPoints = tx.bonusPoints || 0;
      totalBonusPoints += bonusPoints;
    }
    
    return totalBonusPoints;
  }
  
  /**
   * Get remaining bonus points for a payment method
   */
  public async getRemainingBonusPoints(
    paymentMethod: PaymentMethod,
    usedBonusPoints?: number
  ): Promise<number> {
    // Get the card info to determine the monthly cap
    // This should ideally be fetched from a centralized configuration or card registry
    const monthlyCapByCard: Record<string, number> = {
      'UOB Preferred Visa Platinum': 4000,
      'Citibank Rewards Visa Signature': 4000,
      'UOB Visa Signature': 8000,
      'UOB Lady\'s Solitaire': 7200
    };
    
    // Safely access card name
    const cardName = paymentMethod.name || '';
    const defaultCap = 0; // No cap by default
    const cap = monthlyCapByCard[cardName] || defaultCap;
    
    // If cap is 0 (unlimited), return a large number
    if (cap === 0) return Number.MAX_SAFE_INTEGER;
    
    // If usedBonusPoints is provided, use it directly
    if (usedBonusPoints !== undefined) {
      return Math.max(0, cap - usedBonusPoints);
    }
    
    // Otherwise, fetch from database
    const actualUsedPoints = await this.getUsedBonusPoints(paymentMethod.id);
    return Math.max(0, cap - actualUsedPoints);
  }
  
  /**
   * Clear the bonus points cache
   */
  public clearCache(): void {
    this.bonusPointsCache.clear();
  }
}

// Export a singleton instance for easy access
export const bonusPointsTrackingService = BonusPointsTrackingService.getInstance();

================
File: services/CurrencyService.ts
================
import { Currency, PaymentMethod } from "@/types";

/**
 * Service for handling all currency-related operations including
 * formatting, conversion, and currency information.
 */
export class CurrencyService {
  /**
   * List of currencies that don't use decimal places
   */
  private static readonly NO_DECIMAL_CURRENCIES = ["JPY", "VND", "IDR", "TWD"];

  /**
   * Currency symbols mapping
   */
  private static readonly CURRENCY_SYMBOLS: Record<Currency, string> = {
    USD: "$",
    EUR: "",
    GBP: "",
    JPY: "",
    AUD: "A$",
    CAD: "C$",
    CNY: "",
    INR: "",
    TWD: "NT$",
    SGD: "S$",
    VND: "",
    IDR: "Rp",
    THB: "",
    MYR: "RM",
  };

  /**
   * Default exchange rates - in a real app, these would come from an API
   */
  private static readonly DEFAULT_EXCHANGE_RATES: Record<
    Currency,
    Record<Currency, number>
  > = {
    USD: {
      USD: 1,
      EUR: 0.93,
      GBP: 0.79,
      JPY: 151.77,
      AUD: 1.53,
      CAD: 1.37,
      CNY: 7.26,
      INR: 83.42,
      TWD: 32.27,
      SGD: 1.35,
      VND: 25305,
      IDR: 16158,
      THB: 36.17,
      MYR: 4.72,
    },
    EUR: {
      USD: 1.08,
      EUR: 1,
      GBP: 0.85,
      JPY: 163.59,
      AUD: 1.65,
      CAD: 1.47,
      CNY: 7.83,
      INR: 89.93,
      TWD: 34.78,
      SGD: 1.45,
      VND: 27276,
      IDR: 17416,
      THB: 38.99,
      MYR: 5.09,
    },
    GBP: {
      USD: 1.27,
      EUR: 1.18,
      GBP: 1,
      JPY: 192.96,
      AUD: 1.94,
      CAD: 1.74,
      CNY: 9.24,
      INR: 106.06,
      TWD: 41.04,
      SGD: 1.71,
      VND: 32179,
      IDR: 20548,
      THB: 46.0,
      MYR: 6.0,
    },
    JPY: {
      USD: 0.0066,
      EUR: 0.0061,
      GBP: 0.0052,
      JPY: 1,
      AUD: 0.01,
      CAD: 0.009,
      CNY: 0.048,
      INR: 0.55,
      TWD: 0.21,
      SGD: 0.0089,
      VND: 166.73,
      IDR: 106.43,
      THB: 0.24,
      MYR: 0.031,
    },
    AUD: {
      USD: 0.65,
      EUR: 0.61,
      GBP: 0.52,
      JPY: 99.06,
      AUD: 1,
      CAD: 0.89,
      CNY: 4.74,
      INR: 54.47,
      TWD: 21.08,
      SGD: 0.88,
      VND: 16524,
      IDR: 10551,
      THB: 23.61,
      MYR: 3.08,
    },
    CAD: {
      USD: 0.73,
      EUR: 0.68,
      GBP: 0.58,
      JPY: 111.31,
      AUD: 1.12,
      CAD: 1,
      CNY: 5.32,
      INR: 61.2,
      TWD: 23.68,
      SGD: 0.99,
      VND: 18564,
      IDR: 11854,
      THB: 26.53,
      MYR: 3.46,
    },
    CNY: {
      USD: 0.14,
      EUR: 0.13,
      GBP: 0.11,
      JPY: 20.9,
      AUD: 0.21,
      CAD: 0.19,
      CNY: 1,
      INR: 11.49,
      TWD: 4.45,
      SGD: 0.19,
      VND: 3486,
      IDR: 2225,
      THB: 4.98,
      MYR: 0.65,
    },
    INR: {
      USD: 0.012,
      EUR: 0.011,
      GBP: 0.0094,
      JPY: 1.82,
      AUD: 0.018,
      CAD: 0.016,
      CNY: 0.087,
      INR: 1,
      TWD: 0.39,
      SGD: 0.016,
      VND: 303.33,
      IDR: 193.69,
      THB: 0.43,
      MYR: 0.057,
    },
    TWD: {
      USD: 0.031,
      EUR: 0.029,
      GBP: 0.024,
      JPY: 4.71,
      AUD: 0.047,
      CAD: 0.042,
      CNY: 0.22,
      INR: 2.59,
      TWD: 1,
      SGD: 0.042,
      VND: 784.16,
      IDR: 500.71,
      THB: 1.12,
      MYR: 0.15,
    },
    SGD: {
      USD: 0.74,
      EUR: 0.69,
      GBP: 0.58,
      JPY: 112.8,
      AUD: 1.14,
      CAD: 1.01,
      CNY: 5.39,
      INR: 61.97,
      TWD: 23.98,
      SGD: 1,
      VND: 18796,
      IDR: 12005,
      THB: 26.88,
      MYR: 3.51,
    },
    VND: {
      USD: 0.00004,
      EUR: 0.000037,
      GBP: 0.000031,
      JPY: 0.006,
      AUD: 0.000061,
      CAD: 0.000054,
      CNY: 0.00029,
      INR: 0.0033,
      TWD: 0.0013,
      SGD: 0.000053,
      VND: 1,
      IDR: 0.64,
      THB: 0.0014,
      MYR: 0.00019,
    },
    IDR: {
      USD: 0.000062,
      EUR: 0.000057,
      GBP: 0.000049,
      JPY: 0.0094,
      AUD: 0.000095,
      CAD: 0.000084,
      CNY: 0.00045,
      INR: 0.0052,
      TWD: 0.002,
      SGD: 0.000083,
      VND: 1.57,
      IDR: 1,
      THB: 0.0022,
      MYR: 0.00029,
    },
    THB: {
      USD: 0.028,
      EUR: 0.026,
      GBP: 0.022,
      JPY: 4.2,
      AUD: 0.042,
      CAD: 0.038,
      CNY: 0.2,
      INR: 2.31,
      TWD: 0.89,
      SGD: 0.037,
      VND: 699.81,
      IDR: 446.86,
      THB: 1,
      MYR: 0.13,
    },
    MYR: {
      USD: 0.21,
      EUR: 0.2,
      GBP: 0.17,
      JPY: 32.15,
      AUD: 0.32,
      CAD: 0.29,
      CNY: 1.54,
      INR: 17.67,
      TWD: 6.84,
      SGD: 0.29,
      VND: 5360,
      IDR: 3423,
      THB: 7.66,
      MYR: 1,
    },
  };

  /**
   * Currency options for dropdown selects
   */
  private static readonly CURRENCY_OPTIONS: {
    value: Currency;
    label: string;
  }[] = [
    { value: "USD", label: "USD - US Dollar ($)" },
    { value: "EUR", label: "EUR - Euro ()" },
    { value: "GBP", label: "GBP - British Pound ()" },
    { value: "JPY", label: "JPY - Japanese Yen ()" },
    { value: "AUD", label: "AUD - Australian Dollar (A$)" },
    { value: "CAD", label: "CAD - Canadian Dollar (C$)" },
    { value: "CNY", label: "CNY - Chinese Yuan ()" },
    { value: "INR", label: "INR - Indian Rupee ()" },
    { value: "TWD", label: "TWD - New Taiwan Dollar (NT$)" },
    { value: "SGD", label: "SGD - Singapore Dollar (S$)" },
    { value: "VND", label: "VND - Vietnamese Dong ()" },
    { value: "IDR", label: "IDR - Indonesian Rupiah (Rp)" },
    { value: "THB", label: "THB - Thai Baht ()" },
    { value: "MYR", label: "MYR - Malaysian Ringgit (RM)" },
  ];

  /**
   * Formats a currency amount with the appropriate symbol and formatting rules
   *
   * @param amount - Amount to format
   * @param currency - Currency code
   * @returns Formatted currency string (e.g., "$123.45")
   */
  static format(amount: number, currency: Currency): string {
    // Handle edge cases where currency might be undefined or invalid
    if (!currency || !Object.keys(this.CURRENCY_SYMBOLS).includes(currency)) {
      console.warn(
        `Invalid currency provided: ${currency}, using USD as fallback`
      );
      currency = "USD" as Currency;
    }

    // Get decimal places based on currency type
    const decimalPlaces = this.NO_DECIMAL_CURRENCIES.includes(currency) ? 0 : 2;

    // Format the number part with appropriate decimal places
    const formatter = new Intl.NumberFormat("en-US", {
      style: "decimal", // Use decimal style to avoid built-in currency symbols
      minimumFractionDigits: decimalPlaces,
      maximumFractionDigits: decimalPlaces,
    });

    // Get the correct currency symbol from our mapping
    const symbol = this.CURRENCY_SYMBOLS[currency];

    // Return the formatted string with our custom symbol
    return `${symbol}${formatter.format(amount)}`;
  }

  /**
   * Converts an amount from one currency to another
   *
   * @param amount - Amount to convert
   * @param fromCurrency - Source currency code
   * @param toCurrency - Target currency code
   * @param paymentMethod - Optional payment method with custom conversion rates
   * @returns Converted amount in the target currency
   */
  static convert(
    amount: number,
    fromCurrency: Currency,
    toCurrency: Currency,
    paymentMethod?: PaymentMethod
  ): number {
    if (fromCurrency === toCurrency) return amount;

    // Check if payment method exists before trying to access its properties
    if (
      paymentMethod?.conversionRate &&
      paymentMethod.conversionRate[toCurrency] !== undefined
    ) {
      return amount * paymentMethod.conversionRate[toCurrency];
    }

    // Add validation for currency codes to prevent accessing undefined rates
    if (!this.DEFAULT_EXCHANGE_RATES[fromCurrency]) {
      console.error(`Invalid source currency: ${fromCurrency}`);
      return amount; // Return original amount if conversion not possible
    }

    if (!this.DEFAULT_EXCHANGE_RATES[fromCurrency][toCurrency]) {
      console.error(
        `Invalid target currency or exchange rate not available: ${fromCurrency} to ${toCurrency}`
      );
      return amount; // Return original amount if conversion not possible
    }

    // Now we can safely access the exchange rate
    return amount * this.DEFAULT_EXCHANGE_RATES[fromCurrency][toCurrency];
  }

  /**
   * Gets the symbol for a given currency
   *
   * @param currency - Currency code
   * @returns Currency symbol (e.g., "$" for USD)
   */
  static getSymbol(currency: Currency): string {
    return this.CURRENCY_SYMBOLS[currency] || currency;
  }

  /**
   * Gets the list of currency options for dropdown menus
   *
   * @returns Array of currency options with value and label
   */
  static getCurrencyOptions(): { value: Currency; label: string }[] {
    return [...this.CURRENCY_OPTIONS];
  }

  /**
   * Gets the exchange rate between two currencies
   *
   * @param fromCurrency - Source currency code
   * @param toCurrency - Target currency code
   * @returns Exchange rate or 1 if conversion not possible
   */
  static getExchangeRate(fromCurrency: Currency, toCurrency: Currency): number {
    if (fromCurrency === toCurrency) return 1;

    if (
      !this.DEFAULT_EXCHANGE_RATES[fromCurrency] ||
      !this.DEFAULT_EXCHANGE_RATES[fromCurrency][toCurrency]
    ) {
      console.error(
        `Exchange rate not available: ${fromCurrency} to ${toCurrency}`
      );
      return 1;
    }

    return this.DEFAULT_EXCHANGE_RATES[fromCurrency][toCurrency];
  }
}



================================================================
End of Codebase
================================================================
