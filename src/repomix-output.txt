This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: components/expense/, components/rewards/, utils/expense/, utils/storage/, utils/formatting.ts, utils/currencyFormatter.ts, utils/dateUtils.ts, utils/storageUtils.ts, hooks/expense-form/, hooks/useExpenseForm.ts, hooks/useSupabaseConnectionCheck.ts, hooks/useTransactionAction.ts, hooks/useTransactionList.ts, hooks/useTransactionSubmit.ts, services/, types/index.ts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
components/
  expense/
    cards/
      CardRuleService.ts
    dialog/
      TransactionDetailsView.tsx
      TransactionDialogActions.tsx
      TransactionDialogHeader.tsx
      TransactionEditForm.tsx
    form/
      ContactlessToggle.tsx
      ConvertedAmountField.tsx
      MerchantCategorySelect.tsx
      MerchantDetailsForm.tsx
      OnlineMerchantToggle.tsx
      PaymentDetailsForm.tsx
      PaymentMethodSelect.tsx
      PointsDisplay.tsx
      TransactionDetailsForm.tsx
    merchant/
      MerchantAddressSelect.tsx
    ErrorAlert.tsx
    ExpenseForm.tsx
    PaymentCardDisplay.tsx
    PaymentCardRender.tsx
    PointsCurrencyAggregator.tsx
    StorageModeAlert.tsx
    TransactionCard.tsx
    TransactionDialog.tsx
    TransactionTable.tsx
  rewards/
    BonusTierEditor.tsx
    ConditionEditor.tsx
    RewardRuleEditor.tsx
    RewardRuleManager.tsx
hooks/
  useExpenseForm.ts
  useSupabaseConnectionCheck.ts
  useTransactionList.ts
  useTransactionSubmit.ts
services/
  currency/
    index.ts
  rewards/
    CardRegistry.ts
    index.ts
    MonthlySpendingTracker.ts
    RewardCalculatorService.ts
    RuleEngine.ts
    RuleRepository.ts
    types.ts
  storage/
    index.ts
types/
  index.ts
utils/
  storage/
    transactions/
      add.ts
      bonus-points.ts
      delete.ts
      edit.ts
      export.ts
      get.ts
      local-storage.ts
      save.ts
    fileUtils.ts
    index.ts
    merchants.ts
    merchantTracking.ts
    paymentMethods.ts
    transactions.ts
  currencyFormatter.ts
  dateUtils.ts
  formatting.ts
  storageUtils.ts

================================================================
Files
================================================================

================
File: components/expense/cards/CardRuleService.ts
================
// Implementation of CardRuleService for use by migrateRewardRules.ts

export class CardRuleService {
  private static rules: any[] = [];

  static async migrateRules(): Promise<boolean> {
    console.log('CardRuleService.migrateRules called');
    // Implementation would normally load rules from storage
    // For now, we'll just return true to indicate success
    return true;
  }
  
  static async getDefaultRules(): Promise<any[]> {
    console.log('CardRuleService.getDefaultRules called');
    // Implementation would normally return a list of default rules
    // For now, we'll return an empty array
    return [];
  }
  
  static getAllRules(): any[] {
    // Return all rules
    return this.rules;
  }
}

export default CardRuleService;

================
File: components/expense/dialog/TransactionDetailsView.tsx
================
import { Transaction } from "@/types";
import { CurrencyService } from "@/services/currency";

import { CreditCardIcon, CoinsIcon } from "lucide-react";

interface TransactionDetailsViewProps {
  transaction: Transaction;
}

const TransactionDetailsView = ({
  transaction,
}: TransactionDetailsViewProps) => {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 py-4">
      <div className="space-y-4">
        <div>
          <h3 className="text-sm font-medium text-muted-foreground mb-1">
            Amount
          </h3>
          <p className="text-2xl font-semibold">
            {CurrencyService.format(transaction.amount, transaction.currency)}
          </p>
          {transaction.currency !== transaction.paymentCurrency && (
            <p className="text-sm text-muted-foreground">
              Paid as{" "}
              {CurrencyService.format(
                transaction.paymentAmount,
                transaction.paymentCurrency
              )}
            </p>
          )}
        </div>

        <div>
          <h3 className="text-sm font-medium text-muted-foreground mb-1">
            Payment Method
          </h3>
          <div className="flex items-center gap-2">
            <CreditCardIcon className="h-4 w-4" />
            <div>
              <p className="font-medium">{transaction.paymentMethod.name}</p>
              <p className="text-sm text-muted-foreground">
                {transaction.paymentMethod.issuer}
              </p>
            </div>
          </div>
        </div>

        {transaction.rewardPoints > 0 && (
          <div>
            <h3 className="text-sm font-medium text-muted-foreground mb-1">
              Reward Points
            </h3>
            <div className="flex items-center gap-2">
              <CoinsIcon className="h-4 w-4 text-amber-500" />
              <p className="font-medium">
                {transaction.rewardPoints.toLocaleString()} points
              </p>
            </div>
          </div>
        )}
      </div>

      <div className="space-y-4">
        {transaction.merchant.address && (
          <div>
            <h3 className="text-sm font-medium text-muted-foreground mb-1">
              Merchant Address
            </h3>
            <p>{transaction.merchant.address}</p>
          </div>
        )}

        {transaction.notes && (
          <div>
            <h3 className="text-sm font-medium text-muted-foreground mb-1">
              Notes
            </h3>
            <p>{transaction.notes}</p>
          </div>
        )}

        <div>
          <h3 className="text-sm font-medium text-muted-foreground mb-1">
            Transaction ID
          </h3>
          <p className="text-xs font-mono">{transaction.id}</p>
        </div>
      </div>
    </div>
  );
};

export default TransactionDetailsView;

================
File: components/expense/dialog/TransactionDialogActions.tsx
================
import { Transaction } from '@/types';
import { DialogFooter } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { EditIcon, TrashIcon } from 'lucide-react';

interface TransactionDialogActionsProps {
  transaction: Transaction;
  onDelete: (transaction: Transaction) => void;
  onEdit: () => void;
}

const TransactionDialogActions = ({
  transaction,
  onDelete,
  onEdit,
}: TransactionDialogActionsProps) => {
  return (
    <DialogFooter className="gap-2 sm:gap-0">
      <Button
        variant="destructive"
        className="gap-1"
        onClick={() => onDelete(transaction)}
      >
        <TrashIcon className="h-4 w-4" />
        Delete
      </Button>
      <Button
        className="gap-1"
        onClick={onEdit}
      >
        <EditIcon className="h-4 w-4" />
        Edit
      </Button>
    </DialogFooter>
  );
};

export default TransactionDialogActions;

================
File: components/expense/dialog/TransactionDialogHeader.tsx
================
import { Transaction } from '@/types';
import { formatDate } from '@/utils/dateUtils';
import {
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from '@/components/ui/dialog';
import { Badge } from '@/components/ui/badge';
import { CalendarIcon, MapPinIcon } from 'lucide-react';

interface TransactionDialogHeaderProps {
  transaction: Transaction;
}

const TransactionDialogHeader = ({ transaction }: TransactionDialogHeaderProps) => {
  return (
    <DialogHeader>
      <DialogTitle className="text-xl flex items-center gap-2">
        <span>{transaction.merchant.name}</span>
        {transaction.merchant.isOnline && (
          <Badge variant="outline" className="ml-2">Online</Badge>
        )}
        {transaction.isContactless && !transaction.merchant.isOnline && (
          <Badge variant="outline" className="ml-2">Contactless</Badge>
        )}
      </DialogTitle>
      <DialogDescription className="flex flex-col sm:flex-row gap-2 sm:gap-4 text-sm mt-2">
        <div className="flex items-center gap-1">
          <CalendarIcon className="h-3.5 w-3.5" />
          <span>{formatDate(transaction.date)}</span>
        </div>
        {transaction.merchant.mcc && (
          <div className="flex items-center gap-1">
            <MapPinIcon className="h-3.5 w-3.5" />
            <span>{transaction.merchant.mcc.description}</span>
          </div>
        )}
      </DialogDescription>
    </DialogHeader>
  );
};

export default TransactionDialogHeader;

================
File: components/expense/dialog/TransactionEditForm.tsx
================
import { Transaction, PaymentMethod } from '@/types';
import {
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import ExpenseForm from '../ExpenseForm';

interface TransactionEditFormProps {
  transaction: Transaction;
  paymentMethods: PaymentMethod[];
  onSubmit: (transaction: Omit<Transaction, 'id'>) => void;
  onCancel: () => void;
}

const TransactionEditForm = ({
  transaction,
  paymentMethods,
  onSubmit,
  onCancel,
}: TransactionEditFormProps) => {
  // Log transaction to debug
  console.log('Editing transaction with data:', transaction);
  
  // Safely access reimbursementAmount or default to 0
  const reimbursementAmount = transaction.reimbursementAmount || 0;
  console.log('Reimbursement amount:', reimbursementAmount);
  
  return (
    <>
      <DialogHeader>
        <DialogTitle>Edit Transaction</DialogTitle>
        <DialogDescription>
          Make changes to your transaction details.
        </DialogDescription>
      </DialogHeader>
      
      <ExpenseForm
        paymentMethods={paymentMethods}
        onSubmit={onSubmit}
        defaultValues={{
          merchantName: transaction.merchant.name,
          merchantAddress: transaction.merchant.address,
          isOnline: transaction.merchant.isOnline,
          isContactless: !!transaction.isContactless,
          amount: transaction.amount.toString(),
          currency: transaction.currency,
          paymentMethodId: transaction.paymentMethod.id,
          paymentAmount: transaction.paymentAmount.toString(),
          reimbursementAmount: reimbursementAmount ? reimbursementAmount.toString() : '0',
          date: new Date(transaction.date),
          notes: transaction.notes,
          mcc: transaction.merchant.mcc,
        }}
      />
      
      <DialogFooter className="gap-2 sm:gap-0 mt-4">
        <Button variant="outline" onClick={onCancel}>
          Cancel
        </Button>
      </DialogFooter>
    </>
  );
};

export default TransactionEditForm;

================
File: components/expense/form/ContactlessToggle.tsx
================
// components/expense/form/ContactlessToggle.tsx
import React from 'react';
import { useFormContext } from 'react-hook-form';
import { WifiIcon } from 'lucide-react';
import { Switch } from '@/components/ui/switch';
import {
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
} from '@/components/ui/form';

interface ContactlessToggleProps {
  isOnline: boolean;
  isCash: boolean;
}

const ContactlessToggle: React.FC<ContactlessToggleProps> = ({ isOnline, isCash }) => {
  const form = useFormContext();

  // Only show for credit card payments that are not online
  if (isOnline || isCash) {
    return null;
  }

  return (
    <FormField
      control={form.control}
      name="isContactless"
      render={({ field }) => (
        <FormItem className="flex flex-row items-center justify-between rounded-lg border p-3 shadow-sm">
          <div className="space-y-0.5">
            <FormLabel>Contactless Payment</FormLabel>
            <FormDescription>
              Toggle if the payment was made contactless
            </FormDescription>
          </div>
          <FormControl>
            <div className="flex items-center space-x-2">
              <WifiIcon className="h-4 w-4 text-muted-foreground" />
              <Switch
                checked={field.value}
                onCheckedChange={field.onChange}
              />
            </div>
          </FormControl>
        </FormItem>
      )}
    />
  );
};

export default ContactlessToggle;

================
File: components/expense/form/ConvertedAmountField.tsx
================
// components/expense/form/ConvertedAmountField.tsx
import React from 'react';
import { useFormContext } from 'react-hook-form';
import { Input } from '@/components/ui/input';
import { PaymentMethod } from '@/types';
import { 
  FormControl, 
  FormField, 
  FormItem, 
  FormLabel, 
  FormDescription, 
  FormMessage 
} from '@/components/ui/form';

interface ConvertedAmountFieldProps {
  shouldOverridePayment: boolean;
  selectedPaymentMethod: PaymentMethod | undefined;
}

const ConvertedAmountField: React.FC<ConvertedAmountFieldProps> = ({ 
  shouldOverridePayment, 
  selectedPaymentMethod 
}) => {
  const form = useFormContext();
  
  // Only show this field if we need currency conversion
  if (!shouldOverridePayment || !selectedPaymentMethod) {
    return null;
  }
  
  return (
    <FormField
      control={form.control}
      name="paymentAmount"
      render={({ field }) => (
        <FormItem>
          <FormLabel>Converted Amount ({selectedPaymentMethod?.currency})</FormLabel>
          <FormDescription>
            Currency differs from transaction currency. Enter the actual payment amount.
          </FormDescription>
          <FormControl>
            <Input
              type="number"
              min="0.01"
              step="0.01"
              placeholder="0.00"
              {...field}
            />
          </FormControl>
          <FormMessage />
        </FormItem>
      )}
    />
  );
};

export default ConvertedAmountField;

================
File: components/expense/form/MerchantCategorySelect.tsx
================
// components/expense/form/MerchantCategorySelect.tsx
import { useState, useEffect } from 'react';
import { MerchantCategoryCode } from '@/types';
import { MCC_CODES } from '@/utils/constants/mcc';
import { Label } from '@/components/ui/label';
import { TagIcon, SearchIcon } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { Button } from '@/components/ui/button';
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from '@/components/ui/command';
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from '@/components/ui/popover';

interface MerchantCategorySelectProps {
  selectedMCC?: MerchantCategoryCode | null | undefined;
  onSelectMCC: (mcc: MerchantCategoryCode) => void;
}

const MerchantCategorySelect: React.FC<MerchantCategorySelectProps> = ({ 
  selectedMCC, 
  onSelectMCC 
}) => {
  const [showMCCDialog, setShowMCCDialog] = useState(false);
  const [mccSearchQuery, setMccSearchQuery] = useState('');
  const [filteredMCC, setFilteredMCC] = useState<MerchantCategoryCode[]>([]);
  const { toast } = useToast();
  
  // Sort MCC_CODES in ascending order by code and set as initial state
  useEffect(() => {
    const sortedMccCodes = [...MCC_CODES].sort((a, b) => {
      return a.code.localeCompare(b.code);
    });
    setFilteredMCC(sortedMccCodes);
  }, []);
  
  // Filter MCC codes based on search query
  useEffect(() => {
    const sortedMccCodes = [...MCC_CODES].sort((a, b) => a.code.localeCompare(b.code));
    
    if (mccSearchQuery.trim() === '') {
      setFilteredMCC(sortedMccCodes);
    } else {
      const query = mccSearchQuery.toLowerCase();
      const filtered = sortedMccCodes.filter(
        mcc => 
          mcc.description.toLowerCase().includes(query) || 
          mcc.code.includes(query)
      );
      setFilteredMCC(filtered);
    }
  }, [mccSearchQuery]);

  // Determine if the selectedMCC is a valid MerchantCategoryCode object
  const isValidMCC = selectedMCC && 
    typeof selectedMCC === 'object' && 
    'code' in selectedMCC && 
    'description' in selectedMCC;

  const handleSelectMCC = (mcc: MerchantCategoryCode) => {
    onSelectMCC(mcc);
    setShowMCCDialog(false);

    toast({
      title: "Category selected",
      description: `Selected category: ${mcc.description} (${mcc.code})`,
    });
  };

  return (
    <div>
      <Label>Merchant Category</Label>
      <Popover open={showMCCDialog} onOpenChange={setShowMCCDialog}>
        <PopoverTrigger asChild>
          <Button 
            variant="outline" 
            role="combobox" 
            aria-expanded={showMCCDialog}
            className="w-full justify-between mt-1"
          >
            {isValidMCC ? `${selectedMCC.description} (${selectedMCC.code})` : "Select merchant category"}
            <SearchIcon className="ml-2 h-4 w-4 shrink-0 opacity-50" />
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-[300px] p-0">
          <Command>
            <CommandInput 
              placeholder="Search categories..." 
              value={mccSearchQuery}
              onValueChange={setMccSearchQuery}
            />
            <CommandList>
              <CommandEmpty>No categories found.</CommandEmpty>
              <CommandGroup>
                {filteredMCC.map((mcc) => (
                  <CommandItem
                    key={mcc.code}
                    onSelect={() => handleSelectMCC(mcc)}
                    className="cursor-pointer"
                  >
                    <span className="text-xs font-mono text-muted-foreground mr-2">{mcc.code}</span>
                    <span>{mcc.description}</span>
                  </CommandItem>
                ))}
              </CommandGroup>
            </CommandList>
          </Command>
        </PopoverContent>
      </Popover>
      <p className="text-sm text-muted-foreground mt-1">
        {isValidMCC ? (
          <span className="flex items-center">
            <TagIcon className="h-3.5 w-3.5 mr-1.5" />
            {selectedMCC.description} ({selectedMCC.code})
          </span>
        ) : (
          "Optional - Search and select a merchant category code"
        )}
      </p>
    </div>
  );
};

export default MerchantCategorySelect;

================
File: components/expense/form/MerchantDetailsForm.tsx
================
// components/expense/form/MerchantDetailsForm.tsx
import { useState, useEffect } from 'react';
import { useFormContext } from 'react-hook-form';
import { MerchantCategoryCode } from '@/types';
import { Input } from '@/components/ui/input';
import { StoreIcon } from 'lucide-react';
import { useDebounce } from '@/hooks/use-debounce';
import {
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form';
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { useToast } from '@/hooks/use-toast';
import { 
  hasMerchantCategorySuggestions, 
  getSuggestedMerchantCategory 
} from '@/utils/storage/merchants';
import MerchantCategorySelect from './MerchantCategorySelect';
import OnlineMerchantToggle from './OnlineMerchantToggle';

interface MerchantDetailsFormProps {
  onSelectMCC: (mcc: MerchantCategoryCode) => void;
  selectedMCC?: MerchantCategoryCode | null;
}

const MerchantDetailsForm: React.FC<MerchantDetailsFormProps> = ({ 
  onSelectMCC, 
  selectedMCC 
}) => {
  const form = useFormContext();
  const { toast } = useToast();
  const [suggestionsChecked, setSuggestionsChecked] = useState(false);
  
  // Get merchant name from form and debounce to reduce API calls
  const merchantName = form.watch('merchantName');
  const debouncedMerchantName = useDebounce(merchantName, 500);
  const isOnline = form.watch('isOnline');
  
  // Only check for suggestions once per merchant name and when no MCC is selected
  useEffect(() => {
    const checkMerchantSuggestions = async () => {
      if (debouncedMerchantName.trim().length >= 3 && !suggestionsChecked && !selectedMCC) {
        try {
          // Mark that we've checked suggestions for this merchant name
          setSuggestionsChecked(true);
          
          // Check if we have a suggestion for this merchant name
          const hasSuggestions = await hasMerchantCategorySuggestions(debouncedMerchantName);
          
          if (hasSuggestions) {
            const suggestedMCC = await getSuggestedMerchantCategory(debouncedMerchantName);
            
            if (suggestedMCC) {
              // Set the MCC in the form and update the parent
              onSelectMCC(suggestedMCC);
              form.setValue('mcc', suggestedMCC);
              
              // Show toast to inform user about the suggested category
              toast({
                title: "Merchant category suggested",
                description: `Using ${suggestedMCC.description} (${suggestedMCC.code}) based on previous entries`,
              });
            }
          }
        } catch (error) {
          console.error('Error checking merchant suggestions:', error);
        }
      }
    };
    
    checkMerchantSuggestions();
  }, [debouncedMerchantName, form, toast, onSelectMCC, selectedMCC, suggestionsChecked]);

  // Reset suggestion check when merchant name changes significantly
  useEffect(() => {
    if (merchantName.trim().length < 3) {
      setSuggestionsChecked(false);
    }
  }, [merchantName]);

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <StoreIcon className="h-5 w-5" />
          Merchant Details
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <FormField
          control={form.control}
          name="merchantName"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Merchant Name</FormLabel>
              <FormControl>
                <Input placeholder="Enter merchant name" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <OnlineMerchantToggle />
        
        {!isOnline && (
          <FormField
            control={form.control}
            name="merchantAddress"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Merchant Address</FormLabel>
                <FormControl>
                  <Input placeholder="Enter merchant address (optional)" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
        )}
        
        <MerchantCategorySelect 
          selectedMCC={selectedMCC}
          onSelectMCC={(mcc) => {
            onSelectMCC(mcc);
            setSuggestionsChecked(true); // Mark as checked when user manually selects
          }}
        />
      </CardContent>
    </Card>
  );
};

export default MerchantDetailsForm;

================
File: components/expense/form/OnlineMerchantToggle.tsx
================
// components/expense/form/OnlineMerchantToggle.tsx
import { useFormContext } from 'react-hook-form';
import { Switch } from '@/components/ui/switch';
import { FormControl, FormDescription, FormField, FormItem, FormLabel } from '@/components/ui/form';

const OnlineMerchantToggle = () => {
  const form = useFormContext();

  return (
    <div className="flex items-center space-x-2">
      <FormField
        control={form.control}
        name="isOnline"
        render={({ field }) => (
          <FormItem className="flex flex-row items-center justify-between rounded-lg border p-3 shadow-sm">
            <div className="space-y-0.5">
              <FormLabel>Online Merchant</FormLabel>
              <FormDescription>
                Toggle if this is an online merchant
              </FormDescription>
            </div>
            <FormControl>
              <Switch
                checked={field.value}
                onCheckedChange={(checked) => {
                  // When toggled to online, also disable contactless (they're mutually exclusive)
                  if (checked) {
                    console.log('Online toggle enabled, disabling contactless');
                    form.setValue('isContactless', false);
                  }
                  field.onChange(checked);
                }}
              />
            </FormControl>
          </FormItem>
        )}
      />
    </div>
  );
};

export default OnlineMerchantToggle;

================
File: components/expense/form/PaymentDetailsForm.tsx
================
// components/expense/form/PaymentDetailsForm.tsx
import React from 'react';
import { useFormContext } from 'react-hook-form';
import { PaymentMethod, Currency } from '@/types';
import { CreditCardIcon } from 'lucide-react';
import {
  Card,
  CardContent,
  CardFooter,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';

// Import sub-components
import PaymentMethodSelect from './PaymentMethodSelect';
import ContactlessToggle from './ContactlessToggle';
import PointsDisplay from './PointsDisplay';
import ConvertedAmountField from './ConvertedAmountField';
import { PointsCalculationResult } from '@/hooks/expense/useExpenseForm';

interface PaymentDetailsFormProps {
  paymentMethods: PaymentMethod[];
  selectedPaymentMethod: PaymentMethod | undefined;
  shouldOverridePayment: boolean;
  pointsCalculation: PointsCalculationResult;
}

/**
 * Payment details section of the expense form
 */
const PaymentDetailsForm: React.FC<PaymentDetailsFormProps> = ({ 
  paymentMethods, 
  selectedPaymentMethod, 
  shouldOverridePayment,
  pointsCalculation
}) => {
  const form = useFormContext();
  const isOnline = form.watch('isOnline');
  
  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <CreditCardIcon className="h-5 w-5" />
          Payment Details
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <PaymentMethodSelect paymentMethods={paymentMethods} />
        
        <ContactlessToggle 
          isOnline={isOnline} 
          isCash={selectedPaymentMethod?.type === 'cash' || false} 
        />
        
        <ConvertedAmountField 
          shouldOverridePayment={shouldOverridePayment} 
          selectedPaymentMethod={selectedPaymentMethod} 
        />
        
        <PointsDisplay 
          selectedPaymentMethod={selectedPaymentMethod}
          pointsCalculation={pointsCalculation}
        />
      </CardContent>
      <CardFooter className="flex justify-end space-x-2">
        <Button type="submit" className="w-full md:w-auto">
          Save Transaction
        </Button>
      </CardFooter>
    </Card>
  );
};

export default PaymentDetailsForm;

================
File: components/expense/form/PaymentMethodSelect.tsx
================
// components/expense/form/PaymentMethodSelect.tsx
import React from 'react';
import { PaymentMethod } from '@/types';
import { CreditCardIcon, BanknoteIcon } from 'lucide-react';
import { 
  SelectItem, 
  SelectContent, 
  SelectTrigger, 
  SelectValue, 
  Select 
} from '@/components/ui/select';
import { 
  FormControl, 
  FormField, 
  FormItem, 
  FormLabel, 
  FormMessage 
} from '@/components/ui/form';
import { useFormContext } from 'react-hook-form';

interface PaymentMethodSelectProps {
  paymentMethods: PaymentMethod[];
  onSelectPaymentMethod?: (value: string) => void;
}

const PaymentMethodSelect: React.FC<PaymentMethodSelectProps> = ({ 
  paymentMethods,
  onSelectPaymentMethod 
}) => {
  const form = useFormContext();
  
  return (
    <FormField
      control={form.control}
      name="paymentMethodId"
      render={({ field }) => (
        <FormItem>
          <FormLabel>Payment Method</FormLabel>
          <Select 
            value={field.value ? String(field.value) : ''} 
            onValueChange={(value) => {
              console.log('Payment method selected:', value);
              field.onChange(value);
              if (onSelectPaymentMethod) onSelectPaymentMethod(value);
              // Force form validation after selection
              setTimeout(() => form.trigger('paymentMethodId'), 100);
            }}
          >
            <FormControl>
              <SelectTrigger>
                <SelectValue placeholder="Select payment method" />
              </SelectTrigger>
            </FormControl>
            <SelectContent>
              {paymentMethods && paymentMethods.length > 0 ? (
                paymentMethods.map((method) => (
                  <SelectItem key={method.id} value={method.id}>
                    <div className="flex items-center gap-2">
                      {method.type === 'credit_card' ? (
                        <CreditCardIcon className="h-4 w-4" style={{ color: method.color || '#333' }} />
                      ) : (
                        <BanknoteIcon className="h-4 w-4" style={{ color: method.color || '#333' }} />
                      )}
                      <span>{method.name}</span>
                      {method.type === 'credit_card' && method.lastFourDigits && (
                        <span className="text-gray-500 text-xs">...{method.lastFourDigits}</span>
                      )}
                    </div>
                  </SelectItem>
                ))
              ) : (
                <SelectItem value="no-methods" disabled>No payment methods available</SelectItem>
              )}
            </SelectContent>
          </Select>
          <FormMessage />
        </FormItem>
      )}
    />
  );
};

export default PaymentMethodSelect;

================
File: components/expense/form/PointsDisplay.tsx
================
// components/expense/form/PointsDisplay.tsx
import React from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { CoinsIcon } from 'lucide-react';
import { PaymentMethod } from '@/types';
import { PointsCalculationResult } from '@/hooks/expense/expense-form/useRewardPointsStandalone';
import { rewardService } from '@/services/rewards';

interface PointsDisplayProps {
  selectedPaymentMethod: PaymentMethod | undefined;
  pointsCalculation: PointsCalculationResult;
}

/**
 * Component for displaying reward point calculations
 */
const PointsDisplay: React.FC<PointsDisplayProps> = ({
  selectedPaymentMethod,
  pointsCalculation
}) => {
  // Only hide for cash payment methods or if no payment method is selected
  if (!selectedPaymentMethod || selectedPaymentMethod.type === 'cash') {
    return null;
  }

  const { 
    totalPoints, 
    basePoints = 0, 
    bonusPoints = 0, 
    remainingMonthlyBonusPoints,
    messageText,
    pointsCurrency = selectedPaymentMethod ? 
      rewardService.getPointsCurrency(selectedPaymentMethod) : 
      'Points'
  } = pointsCalculation;

  // Render a card with the points information
  return (
    <Card className="border border-amber-200 bg-amber-50 dark:bg-amber-950/20 dark:border-amber-800">
      <CardContent className="pt-6 pb-4">
        <div className="flex items-start space-x-4">
          <div className="bg-amber-100 dark:bg-amber-900/30 p-2 rounded-full">
            <CoinsIcon className="h-6 w-6 text-amber-600 dark:text-amber-400" />
          </div>
          <div className="space-y-1">
            <h3 className="text-base font-semibold">
              {totalPoints.toLocaleString()} {pointsCurrency}
            </h3>
            {basePoints !== undefined && (
              <p className="text-sm text-gray-600 dark:text-gray-400">
                Base: {basePoints.toLocaleString()} {bonusPoints > 0 && 
                  `+ Bonus: ${bonusPoints.toLocaleString()}`}
              </p>
            )}
            {messageText && (
              <p className="text-sm text-amber-600 dark:text-amber-400">
                {messageText}
              </p>
            )}
            {remainingMonthlyBonusPoints !== undefined && remainingMonthlyBonusPoints > 0 && (
              <p className="text-xs text-gray-500 dark:text-gray-500">
                {remainingMonthlyBonusPoints.toLocaleString()} bonus points remaining this month
              </p>
            )}
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

export default PointsDisplay;

================
File: components/expense/form/TransactionDetailsForm.tsx
================
// components/expense/form/TransactionDetailsForm.tsx
import { useFormContext } from "react-hook-form";
import { format } from "date-fns";
import { Currency } from "@/types";
import { Input } from "@/components/ui/input";
import { CalendarIcon } from "lucide-react";
import {
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  FormDescription,
} from "@/components/ui/form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Button } from "@/components/ui/button";
import { Calendar } from "@/components/ui/calendar";
import { cn } from "@/lib/utils";
import { Textarea } from "@/components/ui/textarea";

// Import from our centralized currency service
import { CurrencyService } from "@/services/currency";

const TransactionDetailsForm = () => {
  const form = useFormContext();
  const currency = form.watch("currency");
  
  // Get currency options from our service
  const currencyOptions = CurrencyService.getCurrencyOptions();

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <CalendarIcon className="h-5 w-5" />
          Transaction Details
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <FormField
            control={form.control}
            name="amount"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Transaction Amount</FormLabel>
                <FormControl>
                  <Input
                    type="number"
                    min="0.01"
                    step="0.01"
                    placeholder="0.00"
                    {...field}
                    onChange={(e) => {
                      field.onChange(e);
                      // Update payment amount automatically when transaction amount changes
                      const currentPaymentMethod = form.getValues("paymentMethodId");
                      if (currentPaymentMethod) {
                        form.setValue("paymentAmount", e.target.value);
                      }
                    }}
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="currency"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Currency</FormLabel>
                <Select
                  value={field.value}
                  onValueChange={(value) => {
                    field.onChange(value);
                  }}
                >
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="Select currency" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    {currencyOptions.map((option) => (
                      <SelectItem key={option.value} value={option.value}>
                        {option.label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        {/* Reimbursement Amount Field */}
        <FormField
          control={form.control}
          name="reimbursementAmount"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Reimbursement Amount</FormLabel>
              <FormControl>
                <Input
                  type="number"
                  min="0"
                  step="0.01"
                  placeholder="0.00"
                  {...field}
                />
              </FormControl>
              <FormDescription>
                Amount reimbursed for this expense (in {currency})
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="date"
          render={({ field }) => (
            <FormItem className="flex flex-col">
              <FormLabel>Date</FormLabel>
              <Popover>
                <PopoverTrigger asChild>
                  <FormControl>
                    <Button
                      variant={"outline"}
                      className={cn(
                        "w-full pl-3 text-left font-normal",
                        !field.value && "text-muted-foreground"
                      )}
                    >
                      {field.value ? (
                        format(field.value, "PPP")
                      ) : (
                        <span>Pick a date</span>
                      )}
                      <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                    </Button>
                  </FormControl>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0" align="start">
                  <Calendar
                    mode="single"
                    selected={field.value}
                    onSelect={field.onChange}
                    disabled={(date) => date > new Date()}
                    initialFocus
                    className="pointer-events-auto"
                  />
                </PopoverContent>
              </Popover>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="notes"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Notes (Optional)</FormLabel>
              <FormControl>
                <Textarea
                  placeholder="Add any notes about this transaction"
                  className="resize-none"
                  {...field}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </CardContent>
    </Card>
  );
};

export default TransactionDetailsForm;

================
File: components/expense/merchant/MerchantAddressSelect.tsx
================
import { useState } from 'react';
import { useFormContext } from 'react-hook-form';
import { MapPinIcon, LucideLoader } from 'lucide-react';
import { Input } from '@/components/ui/input';
import { FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { useToast } from '@/hooks/use-toast';
import {
  CommandDialog,
  CommandGroup as CommandDialogGroup,
  CommandEmpty as CommandDialogEmpty,
  CommandInput as CommandDialogInput,
  CommandItem as CommandDialogItem,
  CommandList as CommandDialogList,
} from '@/components/ui/command';

interface Place {
  name: string;
  address: string;
  location?: {
    lat: number;
    lng: number;
  };
}

interface MerchantAddressSelectProps {
  places: Place[];
  isLoading: boolean;
  showDialog: boolean;
  setShowDialog: (show: boolean) => void;
}

const MerchantAddressSelect = ({ 
  places, 
  isLoading, 
  showDialog, 
  setShowDialog 
}: MerchantAddressSelectProps) => {
  const form = useFormContext();
  const { toast } = useToast();

  const handleSelectPlace = (place: Place) => {
    form.setValue('merchantAddress', place.address, { shouldValidate: true });
    setShowDialog(false);
    
    toast({
      title: "Address selected",
      description: `Selected address: ${place.address}`,
    });
  };

  return (
    <>
      <FormField
        control={form.control}
        name="merchantAddress"
        render={({ field }) => (
          <FormItem>
            <FormLabel>Merchant Address</FormLabel>
            <FormControl>
              <div className="relative">
                <Input 
                  placeholder="Enter merchant address" 
                  {...field}
                  onClick={() => {
                    if (places.length > 0) {
                      setShowDialog(true);
                    }
                  }}
                />
                {isLoading ? (
                  <div className="absolute right-3 top-1/2 transform -translate-y-1/2 animate-spin">
                    <LucideLoader className="h-4 w-4 text-gray-400" />
                  </div>
                ) : (
                  <MapPinIcon 
                    className="absolute right-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400 cursor-pointer" 
                    onClick={() => {
                      if (places.length > 0) {
                        setShowDialog(true);
                      }
                    }}
                  />
                )}
              </div>
            </FormControl>
            <FormMessage />
          </FormItem>
        )}
      />

      {/* Places Selection Dialog */}
      <CommandDialog open={showDialog} onOpenChange={setShowDialog}>
        <CommandDialogInput placeholder="Search places..." />
        <CommandDialogList>
          <CommandDialogEmpty>No places found.</CommandDialogEmpty>
          <CommandDialogGroup heading="Suggested Places">
            {places.map((place, index) => (
              <CommandDialogItem
                key={index}
                onSelect={() => handleSelectPlace(place)}
                className="cursor-pointer"
              >
                <div className="flex flex-col">
                  <span className="font-medium">{place.name}</span>
                  <span className="text-sm text-muted-foreground">{place.address}</span>
                </div>
              </CommandDialogItem>
            ))}
          </CommandDialogGroup>
        </CommandDialogList>
      </CommandDialog>
    </>
  );
};

export default MerchantAddressSelect;

================
File: components/expense/ErrorAlert.tsx
================
import React from 'react';
import { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';
import { AlertTriangle } from 'lucide-react';

interface ErrorAlertProps {
  error: string | null;
}

const ErrorAlert: React.FC<ErrorAlertProps> = ({ error }) => {
  if (!error) return null;

  return (
    <Alert className="mb-4 bg-red-50 text-red-700 border-red-200">
      <AlertTriangle className="h-5 w-5" />
      <AlertTitle>Error saving transaction</AlertTitle>
      <AlertDescription>{error}</AlertDescription>
    </Alert>
  );
};

export default ErrorAlert;

================
File: components/expense/ExpenseForm.tsx
================
// components/expense/ExpenseForm.tsx
import React from 'react';
import { Transaction, PaymentMethod } from '@/types';
import { useExpenseForm } from '@/hooks/expense/useExpenseForm';
import { addTransaction } from '@/services/storage';
import { useToast } from '@/hooks/use-toast';

// Import form sections correctly
import MerchantDetailsForm from './form/MerchantDetailsForm';
import TransactionDetailsForm from './form/TransactionDetailsForm';
import PaymentDetailsForm from './form/PaymentDetailsForm';
import { FormProvider } from 'react-hook-form';

interface ExpenseFormProps {
  paymentMethods: PaymentMethod[];
  onSubmit: (transaction: Transaction) => void;
  defaultValues?: Partial<any>;
  useLocalStorage?: boolean;
}

/**
 * Consolidated expense form component
 */
const ExpenseForm: React.FC<ExpenseFormProps> = ({ 
  paymentMethods, 
  onSubmit, 
  defaultValues,
  useLocalStorage = false
}) => {
  const { toast } = useToast();
  
  const {
    form,
    selectedMCC,
    setSelectedMCC,
    selectedPaymentMethod,
    shouldOverridePayment,
    pointsCalculation,
  } = useExpenseForm({ 
    paymentMethods, 
    defaultValues
  });
  
  const handleFormSubmit = async (values: any) => {
    try {
      if (!values.merchantName || values.merchantName.trim() === '') {
        toast({
          title: 'Error',
          description: 'Merchant name is required',
          variant: 'destructive',
        });
        return;
      }
      
      if (!values.paymentMethodId) {
        toast({
          title: 'Error',
          description: 'Payment method is required',
          variant: 'destructive',
        });
        return;
      }
      
      // Get payment method
      const paymentMethod = paymentMethods.find(pm => pm.id === values.paymentMethodId);
      if (!paymentMethod) {
        toast({
          title: 'Error',
          description: 'Invalid payment method',
          variant: 'destructive',
        });
        return;
      }
      
      // Prepare merchant data
      const merchantData = {
        id: '', // Will be assigned by storage service
        name: values.merchantName.trim(),
        address: values.merchantAddress?.trim(),
        isOnline: values.isOnline,
        mcc: selectedMCC,
      };
      
      // Determine amount to use for payment
      const paymentAmount = shouldOverridePayment && values.paymentAmount
        ? Number(values.paymentAmount)
        : Number(values.amount);
      
      // Reimbursement amount
      const reimbursementAmount = values.reimbursementAmount 
        ? Number(values.reimbursementAmount) 
        : 0;
      
      // Prepare transaction data
      const transactionData: Omit<Transaction, 'id'> = {
        date: values.date.toISOString().split('T')[0], // YYYY-MM-DD format
        merchant: merchantData,
        amount: Number(values.amount),
        currency: values.currency,
        paymentMethod: paymentMethod,
        paymentAmount: paymentAmount,
        paymentCurrency: paymentMethod.currency,
        rewardPoints: pointsCalculation.totalPoints,
        basePoints: pointsCalculation.basePoints,
        bonusPoints: pointsCalculation.bonusPoints,
        notes: values.notes,
        isContactless: !values.isOnline && values.isContactless,
        reimbursementAmount: reimbursementAmount,
      };
      
      // Save the transaction
      const savedTransaction = await addTransaction(transactionData);
      
      if (savedTransaction) {
        toast({
          title: 'Success',
          description: 'Transaction saved successfully',
        });
        
        onSubmit(savedTransaction);
      } else {
        toast({
          title: 'Error',
          description: 'Failed to save transaction',
          variant: 'destructive',
        });
      }
    } catch (error) {
      console.error('Error submitting form:', error);
      toast({
        title: 'Error',
        description: 'An unexpected error occurred',
        variant: 'destructive',
      });
    }
  };
  
  return (
    <FormProvider {...form}>
      <form onSubmit={form.handleSubmit(handleFormSubmit)} className="space-y-8">
        <MerchantDetailsForm 
          onSelectMCC={setSelectedMCC} 
          selectedMCC={selectedMCC} 
        />
        
        <TransactionDetailsForm />
        
        <PaymentDetailsForm 
          paymentMethods={paymentMethods}
          selectedPaymentMethod={selectedPaymentMethod}
          shouldOverridePayment={shouldOverridePayment}
          pointsCalculation={pointsCalculation}
        />
      </form>
    </FormProvider>
  );
};

export default ExpenseForm;

================
File: components/expense/PaymentCardDisplay.tsx
================
import React from 'react';
import { PaymentMethod } from '@/types';
import { CreditCardIcon, BanknoteIcon } from 'lucide-react';

interface PaymentCardDisplayProps {
  paymentMethod: PaymentMethod;
  customImage?: string;
  size?: 'default' | 'small';
}

const PaymentCardDisplay: React.FC<PaymentCardDisplayProps> = ({ 
  paymentMethod, 
  customImage,
  size = 'default' 
}) => {
  // Determine classes based on size
  const containerClasses = size === 'small' 
    ? "relative rounded-lg overflow-hidden w-24 h-14" 
    : "relative rounded-lg overflow-hidden w-48 h-28";
  
  const textClasses = size === 'small' ? "text-[8px]" : "text-xs";
  const iconClasses = size === 'small' ? "h-3 w-3" : "h-4 w-4";
  const lastFourClasses = size === 'small' ? "text-[8px]" : "text-xs";
  const issuerClasses = size === 'small' ? "text-[6px]" : "text-[10px]";
  const dotClasses = size === 'small' ? "w-3 h-2" : "w-6 h-4";
  
  // If there's a custom image, render that instead of the default card display
  if (customImage) {
    return (
      <div className={containerClasses}>
        <img 
          src={customImage} 
          alt={`${paymentMethod.name} card`} 
          className="w-full h-full object-cover rounded-lg"
        />
      </div>
    );
  }
  
  // Render a simplified card display with the payment method information
  return (
    <div
      className={`${containerClasses} p-3 flex flex-col justify-between`}
      style={{ backgroundColor: paymentMethod.color || '#4b5563' }}
    >
      <div className="flex justify-between items-start">
        <div className={`text-white ${textClasses} font-semibold line-clamp-2`}>
          {paymentMethod.name}
        </div>
        {paymentMethod.type === 'credit_card' ? (
          <CreditCardIcon className={`${iconClasses} text-white opacity-80`} />
        ) : (
          <BanknoteIcon className={`${iconClasses} text-white opacity-80`} />
        )}
      </div>
      
      <div className="text-white">
        {paymentMethod.type === 'credit_card' && paymentMethod.lastFourDigits && (
          <div className="flex items-center justify-between">
            <div className="flex gap-1">
              <div className={`${dotClasses} bg-white/20 rounded`} />
              <div className={`${dotClasses} bg-white/20 rounded`} />
              <div className={`${dotClasses} bg-white/20 rounded`} />
            </div>
            <div className={`${lastFourClasses} font-mono tracking-wider`}>{paymentMethod.lastFourDigits}</div>
          </div>
        )}
        {paymentMethod.issuer && (
          <div className={`${issuerClasses} text-white/70 mt-1 font-semibold uppercase`}>
            {paymentMethod.issuer}
          </div>
        )}
      </div>
    </div>
  );
};

export default PaymentCardDisplay;

================
File: components/expense/PaymentCardRender.tsx
================
import React from 'react';
import { PaymentMethod } from '@/types';
import { CreditCardIcon, BanknoteIcon } from 'lucide-react';
import { SelectItem, SelectContent, SelectTrigger, SelectValue, Select } from '@/components/ui/select';
import { FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { useFormContext } from 'react-hook-form';

interface PaymentMethodSelectProps {
  paymentMethods: PaymentMethod[];
  onSelectPaymentMethod?: (value: string) => void;
}

const PaymentMethodSelect: React.FC<PaymentMethodSelectProps> = ({ 
  paymentMethods,
  onSelectPaymentMethod 
}) => {
  const form = useFormContext();
  
  return (
    <FormField
      control={form.control}
      name="paymentMethodId"
      render={({ field }) => (
        <FormItem>
          <FormLabel>Payment Method</FormLabel>
          <Select 
            value={field.value ? String(field.value) : ''} 
            onValueChange={(value) => {
              console.log('Payment method selected:', value);
              field.onChange(value);
              if (onSelectPaymentMethod) onSelectPaymentMethod(value);
              // Force form validation after selection
              setTimeout(() => form.trigger('paymentMethodId'), 100);
            }}
          >
            <FormControl>
              <SelectTrigger>
                <SelectValue placeholder="Select payment method" />
              </SelectTrigger>
            </FormControl>
            <SelectContent>
              {paymentMethods && paymentMethods.length > 0 ? (
                paymentMethods.map((method) => (
                  <SelectItem key={method.id} value={method.id}>
                    <div className="flex items-center gap-2">
                      {method.type === 'credit_card' ? (
                        <CreditCardIcon className="h-4 w-4" style={{ color: method.color || '#333' }} />
                      ) : (
                        <BanknoteIcon className="h-4 w-4" style={{ color: method.color || '#333' }} />
                      )}
                      <span>{method.name}</span>
                      {method.type === 'credit_card' && method.lastFourDigits && (
                        <span className="text-gray-500 text-xs">...{method.lastFourDigits}</span>
                      )}
                    </div>
                  </SelectItem>
                ))
              ) : (
                <SelectItem value="no-methods" disabled>No payment methods available</SelectItem>
              )}
            </SelectContent>
          </Select>
          <FormMessage />
        </FormItem>
      )}
    />
  );
};

export default PaymentMethodSelect;

================
File: components/expense/PointsCurrencyAggregator.tsx
================
import React, { useMemo } from 'react';
import { Transaction } from '@/types';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { CoinsIcon } from 'lucide-react';
import { rewardService } from '@/services/rewards';

interface PointsCurrencyAggregatorProps {
  transactions: Transaction[];
}

interface PointsAggregate {
  [currency: string]: number;
}

const PointsCurrencyAggregator: React.FC<PointsCurrencyAggregatorProps> = ({ transactions }) => {
  const pointsByCurrency = useMemo(() => {
    return transactions.reduce<PointsAggregate>((acc, transaction) => {
      if (!transaction.paymentMethod || !transaction.rewardPoints) return acc;
      
      // Get points currency from the central reward calculation service
      const pointsCurrency = rewardService.getPointsCurrency(transaction.paymentMethod);
      
      acc[pointsCurrency] = (acc[pointsCurrency] || 0) + (transaction.rewardPoints || 0);
      return acc;
    }, {});
  }, [transactions]);

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center">
          <CoinsIcon className="mr-2" />
          Points by Currency
        </CardTitle>
      </CardHeader>
      <CardContent>
        {Object.keys(pointsByCurrency).length > 0 ? (
          Object.entries(pointsByCurrency).map(([currency, points]) => (
            <div key={currency} className="flex justify-between items-center mb-2 p-2 border-b">
              <span>{currency}</span>
              <span className="font-bold">{points.toLocaleString()}</span>
            </div>
          ))
        ) : (
          <div className="text-center py-6 text-gray-500">
            No reward points in this period
          </div>
        )}
      </CardContent>
    </Card>
  );
};

export default PointsCurrencyAggregator;

================
File: components/expense/StorageModeAlert.tsx
================
import React from 'react';
import { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';
import { AlertTriangle } from 'lucide-react';

interface StorageModeAlertProps {
  useLocalStorage: boolean;
}

const StorageModeAlert: React.FC<StorageModeAlertProps> = ({ useLocalStorage }) => {
  if (!useLocalStorage) return null;

  return (
    <Alert className="mb-4 bg-amber-50 text-amber-700 border-amber-200">
      <AlertTriangle className="h-5 w-5" />
      <AlertTitle>Using local storage</AlertTitle>
      <AlertDescription>
        Transactions will be saved to local storage. Your data will only be available on this device.
      </AlertDescription>
    </Alert>
  );
};

export default StorageModeAlert;

================
File: components/expense/TransactionCard.tsx
================
import { Transaction } from "@/types";
import { CurrencyService } from "@/services/currency";
import { formatDate } from "@/utils/dateUtils";
import {
  CreditCardIcon,
  BanknoteIcon,
  TagIcon,
  MapPinIcon,
} from "lucide-react";
import { cn } from "@/lib/utils";
import { CSSProperties } from "react";

interface TransactionCardProps {
  transaction: Transaction;
  onClick?: () => void;
  className?: string;
  style?: CSSProperties;
}

const TransactionCard = ({
  transaction,
  onClick,
  className,
  style,
}: TransactionCardProps) => {
  const { merchant, amount, currency, date, paymentMethod, rewardPoints } =
    transaction;

  const isPaymentDifferent =
    transaction.paymentAmount !== amount ||
    transaction.paymentCurrency !== currency;

  return (
    <div
      className={cn(
        "modern-card p-4 overflow-hidden",
        onClick &&
          "cursor-pointer hover:shadow-card-hover hover:-translate-y-1 transition-all duration-200",
        className
      )}
      onClick={onClick}
      style={style}
    >
      <div className="flex items-start justify-between">
        <div className="flex-1 min-w-0 pr-2">
          <h3
            className="font-semibold text-base md:text-lg truncate"
            title={merchant.name}
          >
            {merchant.name}
          </h3>
          <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
            {formatDate(date.toString())}
          </p>
        </div>
        <div className="text-right flex-shrink-0">
          <p
            className="font-semibold text-base md:text-lg whitespace-nowrap"
            title={CurrencyService.format(amount, currency)}
          >
            {CurrencyService.format(amount, currency)}
          </p>
          {isPaymentDifferent && (
            <p
              className="text-sm text-gray-500 dark:text-gray-400 mt-1 whitespace-nowrap"
              title={`Paid: ${CurrencyService.format(transaction.paymentAmount, transaction.paymentCurrency)}`}
            >
              Paid:{" "}
              {CurrencyService.format(
                transaction.paymentAmount,
                transaction.paymentCurrency
              )}
            </p>
          )}
        </div>
      </div>

      <div className="mt-3 pt-3 border-t border-gray-100 dark:border-gray-800 flex flex-wrap gap-2">
        <div className="inline-flex items-center text-xs rounded-full px-3 py-1 bg-blue-50 dark:bg-blue-900/30 max-w-full">
          {paymentMethod.type === "credit_card" ? (
            <CreditCardIcon
              className="h-3.5 w-3.5 mr-1.5 flex-shrink-0"
              style={{ color: paymentMethod.color }}
            />
          ) : (
            <BanknoteIcon
              className="h-3.5 w-3.5 mr-1.5 flex-shrink-0"
              style={{ color: paymentMethod.color }}
            />
          )}
          <span className="truncate" title={paymentMethod.name}>
            {paymentMethod.name}
          </span>
        </div>

        {merchant.mcc && (
          <div className="inline-flex items-center text-xs rounded-full px-3 py-1 bg-purple-50 dark:bg-purple-900/30 max-w-full">
            <TagIcon className="h-3.5 w-3.5 mr-1.5 flex-shrink-0 text-purple-500" />
            <span className="truncate" title={merchant.mcc.description}>
              {merchant.mcc.description}
            </span>
          </div>
        )}

        {rewardPoints > 0 && (
          <div className="inline-flex items-center text-xs rounded-full px-3 py-1 bg-amber-50 dark:bg-amber-900/30 text-amber-700 dark:text-amber-300 whitespace-nowrap">
            <span>+{rewardPoints} points</span>
          </div>
        )}

        {merchant.address && (
          <div className="inline-flex items-center text-xs rounded-full px-3 py-1 bg-red-50 dark:bg-red-900/30 max-w-full">
            <MapPinIcon className="h-3.5 w-3.5 mr-1.5 flex-shrink-0 text-red-500" />
            <span className="truncate" title={merchant.address}>
              {merchant.address}
            </span>
          </div>
        )}
      </div>
    </div>
  );
};

export default TransactionCard;

================
File: components/expense/TransactionDialog.tsx
================
import { useState } from 'react';
import { Transaction, PaymentMethod } from '@/types';
import {
  Dialog,
  DialogContent,
} from '@/components/ui/dialog';

// Import our new components
import TransactionDialogHeader from './dialog/TransactionDialogHeader';
import TransactionDetailsView from './dialog/TransactionDetailsView';
import TransactionDialogActions from './dialog/TransactionDialogActions';
import TransactionEditForm from './dialog/TransactionEditForm';

interface TransactionDialogProps {
  transaction: Transaction | null;
  paymentMethods: PaymentMethod[];
  allTransactions: Transaction[];
  isOpen: boolean;
  mode: 'view' | 'edit';
  onClose: () => void;
  onEdit: (transaction: Transaction) => void;
  onDelete: (transaction: Transaction) => void;
  onSave: (transaction: Omit<Transaction, 'id'>) => void;
}

const TransactionDialog = ({
  transaction,
  paymentMethods,
  allTransactions,
  isOpen,
  mode,
  onClose,
  onEdit,
  onDelete,
  onSave,
}: TransactionDialogProps) => {
  const [dialogMode, setDialogMode] = useState<'view' | 'edit'>(mode);
  
  if (!transaction) return null;
  
  const handleSaveEdit = (updatedTransaction: Omit<Transaction, 'id'>) => {
    onSave(updatedTransaction);
    setDialogMode('view');
  };
  
  const handleCancelEdit = () => {
    setDialogMode('view');
  };
  
  return (
    <Dialog open={isOpen} onOpenChange={(open) => {
      if (!open) {
        onClose();
        setDialogMode(mode);
      }
    }}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-auto">
        {dialogMode === 'view' ? (
          <>
            <TransactionDialogHeader transaction={transaction} />
            <TransactionDetailsView transaction={transaction} />
            <TransactionDialogActions 
              transaction={transaction} 
              onDelete={onDelete} 
              onEdit={() => setDialogMode('edit')} 
            />
          </>
        ) : (
          <TransactionEditForm 
            transaction={transaction}
            paymentMethods={paymentMethods}
            onSubmit={handleSaveEdit}
            onCancel={handleCancelEdit}
          />
        )}
      </DialogContent>
    </Dialog>
  );
};

export default TransactionDialog;

================
File: components/expense/TransactionTable.tsx
================
import { useState, useMemo } from "react";
import {
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Transaction, PaymentMethod } from "@/types";
import { CurrencyService } from "@/services/currency";
import { formatDate } from "@/utils/dateUtils";
import { EditIcon, TrashIcon, DownloadIcon, EyeIcon } from "lucide-react";
import { exportTransactionsToCSV } from "@/services/storage";
import { withResolvedStringPromise } from "@/utils/storage/fileUtils";
import {
  getCategoryFromMCC,
  getCategoryFromMerchantName,
} from "@/utils/categoryMapping";

interface TransactionTableProps {
  transactions: Transaction[];
  paymentMethods: PaymentMethod[];
  onEdit: (transaction: Transaction) => void;
  onDelete: (transaction: Transaction) => void;
  onView: (transaction: Transaction) => void;
}

const TransactionTable = ({
  transactions,
  paymentMethods,
  onEdit,
  onDelete,
  onView,
}: TransactionTableProps) => {
  // Memoize CSV export to prevent recalculation on every render
  const handleExportCSV = useMemo(
    () => async () => {
      const csvPromise = exportTransactionsToCSV(transactions);
      
      // Use the utility function to handle the string promise safely
      await withResolvedStringPromise(async (csvContent) => {
        // Create a blob and download link
        const url = URL.createObjectURL(new Blob([csvContent], { type: "text/csv;charset=utf-8;" }));
        const link = document.createElement("a");

        link.setAttribute("href", url);
        link.setAttribute(
          "download",
          `transactions_export_${new Date().toISOString().slice(0, 10)}.csv`
        );
        link.style.visibility = "hidden";

        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url); // Clean up
      }, csvPromise);
    },
    [transactions]
  );

  // Precompute all categories for display - only recalculate when transactions change
  const transactionCategories = useMemo(() => {
    return transactions.reduce(
      (acc, transaction) => {
        const txId = transaction.id;

        // Use transaction's stored category if available
        if (transaction.category && transaction.category !== "Uncategorized") {
          acc[txId] = transaction.category;
          return acc;
        }

        // Try to determine from MCC
        if (transaction.merchant.mcc?.code) {
          acc[txId] = getCategoryFromMCC(transaction.merchant.mcc.code);
          return acc;
        }

        // Try to determine from merchant name
        const nameBasedCategory = getCategoryFromMerchantName(
          transaction.merchant.name
        );
        if (nameBasedCategory) {
          acc[txId] = nameBasedCategory;
          return acc;
        }

        acc[txId] = "Uncategorized";
        return acc;
      },
      {} as Record<string, string>
    );
  }, [transactions]);

  return (
    <div className="w-full">
      <div className="flex justify-end mb-4">
        <Button
          variant="outline"
          size="sm"
          className="flex items-center gap-1"
          onClick={handleExportCSV}
        >
          <DownloadIcon className="h-4 w-4" />
          Export CSV
        </Button>
      </div>

      <div className="rounded-md border overflow-hidden">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Date</TableHead>
              <TableHead>Merchant</TableHead>
              <TableHead>Category</TableHead>
              <TableHead>Amount</TableHead>
              <TableHead>Payment Method</TableHead>
              <TableHead>Points</TableHead>
              <TableHead className="w-[100px] text-right">Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {transactions.length === 0 ? (
              <TableRow>
                <TableCell colSpan={7} className="h-24 text-center">
                  No transactions found.
                </TableCell>
              </TableRow>
            ) : (
              transactions.map((transaction) => (
                <TableRow key={transaction.id}>
                  <TableCell>{formatDate(transaction.date)}</TableCell>
                  <TableCell>
                    <div className="font-medium">
                      {transaction.merchant.name}
                    </div>
                    <div className="text-xs text-muted-foreground">
                      {transaction.merchant.isOnline ? "Online" : "In-store"}
                      {transaction.isContactless &&
                        !transaction.merchant.isOnline &&
                        "  Contactless"}
                    </div>
                  </TableCell>
                  <TableCell>{transactionCategories[transaction.id]}</TableCell>
                  <TableCell>
                    <div>
                      {CurrencyService.format(
                        transaction.amount,
                        transaction.currency
                      )}
                    </div>
                    {transaction.currency !== transaction.paymentCurrency && (
                      <div className="text-xs text-muted-foreground">
                        {CurrencyService.format(
                          transaction.paymentAmount,
                          transaction.paymentCurrency
                        )}
                      </div>
                    )}
                  </TableCell>
                  <TableCell>
                    <div className="font-medium">
                      {transaction.paymentMethod.name}
                    </div>
                    <div className="text-xs text-muted-foreground">
                      {transaction.paymentMethod.issuer}
                    </div>
                  </TableCell>
                  <TableCell>
                    {transaction.rewardPoints > 0 ? (
                      <div className="font-medium">
                        {transaction.rewardPoints.toLocaleString()}
                      </div>
                    ) : transaction.paymentMethod.type === "credit_card" ? (
                      <div className="text-amber-600 font-medium">
                        {Math.round(transaction.amount * 0.4).toLocaleString()}*
                      </div>
                    ) : (
                      <div className="text-muted-foreground">-</div>
                    )}
                  </TableCell>
                  <TableCell className="text-right">
                    <div className="flex justify-end gap-2">
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={() => onView(transaction)}
                      >
                        <EyeIcon className="h-4 w-4" />
                        <span className="sr-only">View</span>
                      </Button>
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={() => onEdit(transaction)}
                      >
                        <EditIcon className="h-4 w-4" />
                        <span className="sr-only">Edit</span>
                      </Button>
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={() => onDelete(transaction)}
                      >
                        <TrashIcon className="h-4 w-4" />
                        <span className="sr-only">Delete</span>
                      </Button>
                    </div>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>
    </div>
  );
};

export default TransactionTable;

================
File: components/rewards/BonusTierEditor.tsx
================
// components/rewards/BonusTierEditor.tsx
import React, { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardFooter } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Trash, Edit } from 'lucide-react';
import { BonusTier, RuleCondition } from '@/services/rewards/types';
import { ConditionEditor } from './ConditionEditor';

interface BonusTierEditorProps {
  tier: BonusTier;
  onChange: (tier: BonusTier) => void;
  onDelete: () => void;
}

export const BonusTierEditor: React.FC<BonusTierEditorProps> = ({
  tier,
  onChange,
  onDelete
}) => {
  const [isEditing, setIsEditing] = useState(false);
  
  // Handle tier name change
  const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onChange({
      ...tier,
      name: e.target.value
    });
  };
  
  // Handle tier multiplier change
  const handleMultiplierChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = parseFloat(e.target.value);
    if (isNaN(value)) return;
    
    onChange({
      ...tier,
      multiplier: value
    });
  };
  
  // Handle tier priority change
  const handlePriorityChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = parseInt(e.target.value);
    if (isNaN(value)) return;
    
    onChange({
      ...tier,
      priority: value
    });
  };
  
  // Handle condition change
  const handleConditionChange = (condition: RuleCondition) => {
    onChange({
      ...tier,
      condition
    });
  };
  
  return (
    <Card>
      <CardHeader className="p-4 pb-2">
        <div className="flex justify-between items-center">
          {isEditing ? (
            <Input
              value={tier.name}
              onChange={handleNameChange}
              placeholder="Tier Name"
              className="font-semibold"
            />
          ) : (
            <CardTitle className="text-base">{tier.name}</CardTitle>
          )}
          <div className="flex space-x-1">
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => setIsEditing(!isEditing)}
              className="h-7 w-7 p-0"
            >
              <Edit size={16} />
            </Button>
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={onDelete}
              className="h-7 w-7 p-0"
            >
              <Trash size={16} />
            </Button>
          </div>
        </div>
      </CardHeader>
      <CardContent className="p-4 pt-0">
        <div className="space-y-3">
          {isEditing ? (
            <>
              <div>
                <Label htmlFor="multiplier" className="text-xs">Bonus Multiplier</Label>
                <Input
                  id="multiplier"
                  type="number"
                  step="0.1"
                  value={tier.multiplier}
                  onChange={handleMultiplierChange}
                  placeholder="e.g., 1.8 for 9x per $5"
                  className="h-8"
                />
              </div>
              <div>
                <Label htmlFor="priority" className="text-xs">Priority</Label>
                <Input
                  id="priority"
                  type="number"
                  value={tier.priority}
                  onChange={handlePriorityChange}
                  placeholder="Higher values take precedence"
                  className="h-8"
                />
              </div>
              <div>
                <Label className="text-xs">Condition</Label>
                <ConditionEditor
                  condition={tier.condition}
                  onChange={handleConditionChange}
                />
              </div>
            </>
          ) : (
            <>
              <div className="text-sm">
                <span className="font-medium">Multiplier:</span> {tier.multiplier}x
              </div>
              <div className="text-sm">
                <span className="font-medium">Priority:</span> {tier.priority}
              </div>
              <div>
                <span className="font-medium text-sm">Condition Type:</span>
                <div className="pl-2 mt-1 text-sm">
                  {tier.condition.type === 'compound' 
                    ? `Compound (${tier.condition.operation === 'all' ? 'AND' : 'OR'})` 
                    : tier.condition.type}
                </div>
              </div>
            </>
          )}
        </div>
      </CardContent>
    </Card>
  );
};

================
File: components/rewards/ConditionEditor.tsx
================
// components/rewards/ConditionEditor.tsx
import React, { useState } from 'react';
import { 
  Card, CardContent, CardHeader, CardTitle 
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { 
  Select, SelectContent, SelectItem, 
  SelectTrigger, SelectValue 
} from '@/components/ui/select';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { PlusCircle, Trash, ChevronDown, ChevronRight } from 'lucide-react';
import { RuleCondition, TransactionType } from '@/services/rewards/types';

interface ConditionEditorProps {
  condition: RuleCondition;
  onChange: (condition: RuleCondition) => void;
  onDelete?: () => void;
  isNested?: boolean;
}

export const ConditionEditor: React.FC<ConditionEditorProps> = ({
  condition,
  onChange,
  onDelete,
  isNested = false
}) => {
  const [expanded, setExpanded] = useState(!isNested);
  const [newValue, setNewValue] = useState('');

  const handleTypeChange = (type: string) => {
    let newCondition: RuleCondition;
    if (type === 'compound') {
      newCondition = {
        type: 'compound',
        operation: 'all',
        subConditions: []
      };
    } else {
      newCondition = {
        type: type as any,
        operation: 'equals',
        values: []
      };
    }
    onChange(newCondition);
  };

  const handleOperationChange = (operation: string) => {
    onChange({
      ...condition,
      operation: operation as any
    });
  };

  const handleAddValue = () => {
    if (!newValue.trim()) return;
  
    if (
      condition.type === 'mcc' || 
      condition.type === 'currency' || 
      condition.type === 'merchant' || 
      condition.type === 'category'
    ) {
      const newValues = [...(condition.values as string[] || [])];
      newValues.push(newValue);
      onChange({
        ...condition,
        values: newValues
      });
  
    } else if (
      condition.type === 'amount' || 
      condition.type === 'spend_threshold'
    ) {
      const parsed = parseFloat(newValue);
      if (isNaN(parsed)) return;
      const newValues = [...(condition.values as number[] || [])];
      newValues.push(parsed);
      onChange({
        ...condition,
        values: newValues
      });
  
    } else if (condition.type === 'transaction_type') {
      const newValues = [...(condition.values as TransactionType[] || [])];
      newValues.push(newValue as TransactionType);
      onChange({
        ...condition,
        values: newValues
      });
    }
  
    setNewValue('');
  };  

  const handleRemoveValue = (index: number) => {
    if (!condition.values) return;
  
    let newValues;
  
    if (
      condition.type === 'mcc' || 
      condition.type === 'currency' || 
      condition.type === 'merchant' || 
      condition.type === 'category'
    ) {
      newValues = [...(condition.values as string[])];
    } else if (
      condition.type === 'amount' || 
      condition.type === 'spend_threshold'
    ) {
      newValues = [...(condition.values as number[])];
    } else if (condition.type === 'transaction_type') {
      newValues = [...(condition.values as TransactionType[])];
    } else {
      return; // unexpected type
    }
  
    newValues.splice(index, 1);
  
    onChange({
      ...condition,
      values: newValues
    });
  };
  
  const handleSubConditionChange = (index: number, subCondition: RuleCondition) => {
    if (!condition.subConditions) return;

    const newSubConditions = [...condition.subConditions];
    newSubConditions[index] = subCondition;

    onChange({
      ...condition,
      subConditions: newSubConditions
    });
  };

  const handleAddSubCondition = () => {
    if (condition.type !== 'compound') return;

    const newSubConditions = [...(condition.subConditions || [])];

    newSubConditions.push({
      type: 'mcc',
      operation: 'include',
      values: []
    });

    onChange({
      ...condition,
      subConditions: newSubConditions
    });
  };

  const handleRemoveSubCondition = (index: number) => {
    if (!condition.subConditions) return;

    const newSubConditions = [...condition.subConditions];
    newSubConditions.splice(index, 1);

    onChange({
      ...condition,
      subConditions: newSubConditions
    });
  };

  return (
    <Card className={isNested ? "border-dashed border-gray-300 mt-2" : ""}>
      <CardHeader className="p-3 flex flex-row items-center justify-between">
        <div className="flex items-center">
          {isNested && (
            <Button 
              type="button" 
              variant="ghost" 
              size="sm"
              onClick={() => setExpanded(!expanded)}
              className="p-0 h-6 w-6 mr-2"
            >
              {expanded ? <ChevronDown size={16} /> : <ChevronRight size={16} />}
            </Button>
          )}
          <CardTitle className="text-sm">
            {condition.type === 'compound' 
              ? `Group (${condition.operation === 'all' ? 'AND' : 'OR'})` 
              : condition.type.toUpperCase()}
          </CardTitle>
        </div>
        
        {onDelete && (
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={onDelete}
            className="p-1 h-7 w-7"
          >
            <Trash size={14} />
          </Button>
        )}
      </CardHeader>
      
      {(expanded || !isNested) && (
        <CardContent className="p-3 pt-0">
          <div className="space-y-3">
            {/* Condition Type */}
            <div>
              <Label htmlFor="conditionType" className="text-xs">Condition Type</Label>
              <Select
                value={condition.type}
                onValueChange={handleTypeChange}
              >
                <SelectTrigger id="conditionType" className="h-8">
                  <SelectValue placeholder="Select condition type" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="mcc">MCC Code</SelectItem>
                  <SelectItem value="merchant">Merchant Name</SelectItem>
                  <SelectItem value="transaction_type">Transaction Type</SelectItem>
                  <SelectItem value="currency">Currency</SelectItem>
                  <SelectItem value="amount">Amount</SelectItem>
                  <SelectItem value="category">Category</SelectItem>
                  <SelectItem value="spend_threshold">Spend Threshold</SelectItem>
                  <SelectItem value="compound">Compound (Group)</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            {/* Operation Selection */}
            {condition.type !== 'compound' ? (
              <div>
                <Label htmlFor="operation" className="text-xs">Operation</Label>
                <Select
                  value={condition.operation}
                  onValueChange={handleOperationChange}
                >
                  <SelectTrigger id="operation" className="h-8">
                    <SelectValue placeholder="Select operation" />
                  </SelectTrigger>
                  <SelectContent>
                    {condition.type === 'mcc' || condition.type === 'currency' || 
                    condition.type === 'category' || condition.type === 'merchant' ? (
                      <>
                        <SelectItem value="include">Include</SelectItem>
                        <SelectItem value="exclude">Exclude</SelectItem>
                        <SelectItem value="equals">Equals</SelectItem>
                      </>
                    ) : condition.type === 'amount' || condition.type === 'spend_threshold' ? (
                      <>
                        <SelectItem value="equals">Equals</SelectItem>
                        <SelectItem value="greater_than">Greater Than</SelectItem>
                        <SelectItem value="less_than">Less Than</SelectItem>
                        <SelectItem value="between">Between</SelectItem>
                      </>
                    ) : condition.type === 'transaction_type' ? (
                      <>
                        <SelectItem value="equals">Equals</SelectItem>
                        <SelectItem value="not_equals">Not Equals</SelectItem>
                      </>
                    ) : (
                      <SelectItem value="equals">Equals</SelectItem>
                    )}
                  </SelectContent>
                </Select>
              </div>
            ) : (
              <div>
                <Label htmlFor="compoundOperation" className="text-xs">Logic</Label>
                <RadioGroup
                  value={condition.operation}
                  onValueChange={handleOperationChange}
                  className="flex space-x-4"
                >
                  <div className="flex items-center space-x-1">
                    <RadioGroupItem value="all" id="all" />
                    <Label htmlFor="all" className="text-xs">AND (All conditions must match)</Label>
                  </div>
                  <div className="flex items-center space-x-1">
                    <RadioGroupItem value="any" id="any" />
                    <Label htmlFor="any" className="text-xs">OR (Any condition can match)</Label>
                  </div>
                </RadioGroup>
              </div>
            )}
            
            {/* Value Input (for non-compound conditions) */}
            {condition.type !== 'compound' && (
              <div>
                <Label htmlFor="conditionValue" className="text-xs">
                  {condition.type === 'transaction_type' ? 'Transaction Type' : 'Value'}
                </Label>
                
                {condition.type === 'transaction_type' ? (
                  <Select
                    value={newValue}
                    onValueChange={setNewValue}
                  >
                    <SelectTrigger id="transactionType" className="h-8">
                      <SelectValue placeholder="Select transaction type" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value={TransactionType.ONLINE}>Online</SelectItem>
                      <SelectItem value={TransactionType.CONTACTLESS}>Contactless</SelectItem>
                      <SelectItem value={TransactionType.IN_STORE}>In-Store</SelectItem>
                    </SelectContent>
                  </Select>
                ) : (
                  <div className="flex space-x-2">
                    <Input
                      id="conditionValue"
                      value={newValue}
                      onChange={(e) => setNewValue(e.target.value)}
                      placeholder={condition.type === 'amount' ? 'Enter amount' : 
                                  condition.type === 'mcc' ? 'Enter MCC code' :
                                  condition.type === 'merchant' ? 'Enter merchant name' :
                                  condition.type === 'currency' ? 'Enter currency code' :
                                  condition.type === 'category' ? 'Enter category' :
                                  'Enter value'}
                      className="h-8"
                    />
                    <Button
                      type="button"
                      size="sm"
                      onClick={handleAddValue}
                      className="h-8"
                    >
                      Add
                    </Button>
                  </div>
                )}
              </div>
            )}
            
            {/* Values Display */}
            {condition.type !== 'compound' && condition.values && condition.values.length > 0 && (
              <div>
                <Label className="text-xs">Current Values</Label>
                <div className="flex flex-wrap gap-1 p-2 border rounded-md">
                  {condition.values.map((value, index) => (
                    <div
                      key={index}
                      className="bg-blue-100 text-blue-800 px-2 py-0.5 rounded-full flex items-center"
                    >
                      <span className="text-xs">
                        {condition.type === 'transaction_type' 
                          ? (value === TransactionType.ONLINE 
                              ? 'Online' 
                              : value === TransactionType.CONTACTLESS 
                                ? 'Contactless' 
                                : 'In-Store')
                          : value.toString()}
                      </span>
                      <button
                        type="button"
                        className="ml-1 text-blue-600 hover:text-blue-800"
                        onClick={() => handleRemoveValue(index)}
                      >
                        
                      </button>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Sub-conditions (for compound conditions) */}
            {condition.type === 'compound' && (
              <div className="space-y-2">
                {condition.subConditions && condition.subConditions.length > 0 ? (
                  <div className="space-y-2">
                    {condition.subConditions.map((subCondition, index) => (
                      <ConditionEditor
                        key={index}
                        condition={subCondition}
                        onChange={(newSubCondition) => handleSubConditionChange(index, newSubCondition)}
                        onDelete={() => handleRemoveSubCondition(index)}
                        isNested={true}
                      />
                    ))}
                  </div>
                ) : (
                  <div className="text-center p-2 border border-dashed rounded-md">
                    <p className="text-xs text-gray-500">No conditions added yet</p>
                  </div>
                )}
                
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={handleAddSubCondition}
                  className="w-full"
                >
                  <PlusCircle size={14} className="mr-2" />
                  Add Condition
                </Button>
              </div>
            )}
          </div>
        </CardContent>
      )}
    </Card>
  );
};

================
File: components/rewards/RewardRuleEditor.tsx
================
// components/rewards/RewardRuleEditor.tsx
import React, { useState, useEffect } from 'react';
import { v4 as uuidv4 } from 'uuid';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Switch } from '@/components/ui/switch';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { useToast } from '@/hooks/use-toast';
import { PlusCircle } from 'lucide-react';
import { 
  RewardRule, 
  RuleCondition, 
  BonusTier,
  CalculationMethod,
  RoundingStrategy,
  SpendingPeriodType
} from '@/services/rewards/types';
import { ConditionEditor } from './ConditionEditor';
import { BonusTierEditor } from './BonusTierEditor';
import { Card, CardHeader, CardTitle, CardContent } from '../ui/card';

interface RewardRuleEditorProps {
  rule?: RewardRule;
  cardTypeId: string;
  onSave: (rule: RewardRule) => void;
  onCancel: () => void;
}

export const RewardRuleEditor: React.FC<RewardRuleEditorProps> = ({
  rule,
  cardTypeId,
  onSave,
  onCancel
}) => {
  const { toast } = useToast();
  const [activeTab, setActiveTab] = useState('general');
  
  // Initialize state with default or existing rule
  const [formData, setFormData] = useState<RewardRule>(() => {
    if (rule) {
      return { ...rule };
    }
    
    // Default rule template
    return {
      id: uuidv4(),
      cardTypeId,
      name: '',
      description: '',
      enabled: true,
      priority: 10,
      conditions: [],
      reward: {
        calculationMethod: 'standard',
        baseMultiplier: 0.2,
        bonusMultiplier: 1.8,
        pointsRoundingStrategy: 'floor',
        amountRoundingStrategy: 'floor5',
        blockSize: 5,
        pointsCurrency: 'Points'
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  });
  
  // Handle adding a root-level condition
  const handleAddCondition = () => {
    setFormData(prev => ({
      ...prev,
      conditions: [
        ...prev.conditions,
        {
          type: 'mcc',
          operation: 'include',
          values: []
        }
      ]
    }));
  };
  
  // Handle removing a root-level condition
  const handleRemoveCondition = (index: number) => {
    setFormData(prev => ({
      ...prev,
      conditions: prev.conditions.filter((_, i) => i !== index)
    }));
  };
  
  // Handle updating a root-level condition
  const handleUpdateCondition = (index: number, condition: RuleCondition) => {
    setFormData(prev => {
      const newConditions = [...prev.conditions];
      newConditions[index] = condition;
      return {
        ...prev,
        conditions: newConditions
      };
    });
  };
  
  // Handle adding a new bonus tier
  const handleAddBonusTier = () => {
    const newTier: BonusTier = {
      name: `New Tier ${(formData.reward.bonusTiers?.length || 0) + 1}`,
      multiplier: formData.reward.bonusMultiplier,
      priority: 1,
      condition: {
        type: 'mcc',
        operation: 'include',
        values: []
      }
    };
    
    setFormData(prev => ({
      ...prev,
      reward: {
        ...prev.reward,
        bonusTiers: [...(prev.reward.bonusTiers || []), newTier]
      }
    }));
  };
  
  // Handle removing a bonus tier
  const handleRemoveBonusTier = (index: number) => {
    setFormData(prev => ({
      ...prev,
      reward: {
        ...prev.reward,
        bonusTiers: prev.reward.bonusTiers?.filter((_, i) => i !== index)
      }
    }));
  };
  
  // Handle updating a bonus tier
  const handleUpdateBonusTier = (index: number, tier: BonusTier) => {
    setFormData(prev => {
      if (!prev.reward.bonusTiers) return prev;
      
      const newTiers = [...prev.reward.bonusTiers];
      newTiers[index] = tier;
      
      return {
        ...prev,
        reward: {
          ...prev.reward,
          bonusTiers: newTiers
        }
      };
    });
  };
  
  // Input change handlers
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };
  
  // Handle reward setting changes
  const handleRewardChange = (field: keyof RewardRule['reward'], value: any) => {
    setFormData(prev => ({
      ...prev,
      reward: {
        ...prev.reward,
        [field]: value
      }
    }));
  };
  
  // Handle boolean switches
  const handleSwitchChange = (name: 'enabled', checked: boolean) => {
    setFormData(prev => ({ ...prev, [name]: checked }));
  };
  
  // Form submission
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!formData.name.trim()) {
      toast({
        title: "Error",
        description: "Rule name is required",
        variant: "destructive"
      });
      return;
    }
    
    // Update timestamps
    const updatedRule: RewardRule = {
      ...formData,
      updatedAt: new Date()
    };
    
    onSave(updatedRule);
  };
  
  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <Tabs defaultValue="general" value={activeTab} onValueChange={setActiveTab}>
        <TabsList className="grid grid-cols-4">
          <TabsTrigger value="general">General</TabsTrigger>
          <TabsTrigger value="conditions">Conditions</TabsTrigger>
          <TabsTrigger value="reward">Reward</TabsTrigger>
          <TabsTrigger value="tiers">Bonus Tiers</TabsTrigger>
        </TabsList>
        
        <TabsContent value="general" className="space-y-4">
          <div>
            <Label htmlFor="name">Rule Name</Label>
            <Input
              id="name"
              name="name"
              value={formData.name}
              onChange={handleInputChange}
              placeholder="E.g., Online Bonus Points"
            />
          </div>
          
          <div>
            <Label htmlFor="description">Description</Label>
            <Textarea
              id="description"
              name="description"
              value={formData.description}
              onChange={handleInputChange}
              placeholder="E.g., 10X points on online transactions"
            />
          </div>
          
          <div>
            <Label htmlFor="priority">Priority</Label>
            <Input
              id="priority"
              name="priority"
              type="number"
              value={formData.priority}
              onChange={(e) => setFormData(prev => ({ 
                ...prev, 
                priority: parseInt(e.target.value) 
              }))}
              placeholder="Higher values have higher priority"
            />
            <p className="text-sm text-muted-foreground mt-1">
              Rules with higher priority will be applied first
            </p>
          </div>
          
          <div className="flex items-center space-x-2">
            <Switch
              id="enabled"
              checked={formData.enabled}
              onCheckedChange={(checked) => handleSwitchChange('enabled', checked)}
            />
            <Label htmlFor="enabled">Enabled</Label>
          </div>
        </TabsContent>
        
        <TabsContent value="conditions" className="space-y-4">
          <div className="space-y-3">
            {formData.conditions.length > 0 ? (
              <div className="space-y-3">
                {formData.conditions.map((condition, index) => (
                  <ConditionEditor
                    key={index}
                    condition={condition}
                    onChange={(newCondition) => handleUpdateCondition(index, newCondition)}
                    onDelete={() => handleRemoveCondition(index)}
                  />
                ))}
              </div>
            ) : (
              <div className="text-center p-4 border border-dashed rounded-md">
                <p className="text-sm text-gray-500">
                  No conditions added yet. Add conditions to define when this rule applies.
                </p>
                <p className="text-xs text-gray-400 mt-1">
                  If no conditions are specified, the rule will apply to all transactions.
                </p>
              </div>
            )}
            
            <Button
              type="button"
              variant="outline"
              onClick={handleAddCondition}
              className="w-full"
            >
              <PlusCircle size={16} className="mr-2" />
              Add Condition
            </Button>
          </div>
        </TabsContent>
        
        <TabsContent value="reward" className="space-y-4">
          {/* Calculation Method */}
          <div>
            <Label htmlFor="calculationMethod">Calculation Method</Label>
            <Select
              value={formData.reward.calculationMethod}
              onValueChange={(value: CalculationMethod) => 
                handleRewardChange('calculationMethod', value)
              }
            >
              <SelectTrigger id="calculationMethod">
                <SelectValue placeholder="Select calculation method" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="standard">Standard (Round amount first, then calculate)</SelectItem>
                <SelectItem value="direct">Direct (Calculate first, then round)</SelectItem>
              </SelectContent>
            </Select>
            <p className="text-xs text-gray-500 mt-1">
              Standard: Round amount  Divide by block size  Multiply by rate<br />
              Direct: Multiply amount by rate  Round result
            </p>
          </div>
          
          {/* Block Size */}
          <div>
            <Label htmlFor="blockSize">Block Size</Label>
            <Select
              value={formData.reward.blockSize.toString()}
              onValueChange={(value) => 
                handleRewardChange('blockSize', parseInt(value))
              }
            >
              <SelectTrigger id="blockSize">
                <SelectValue placeholder="Select block size" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="1">$1 (Points per dollar)</SelectItem>
                <SelectItem value="5">$5 (Points per $5 block)</SelectItem>
              </SelectContent>
            </Select>
            <p className="text-xs text-gray-500 mt-1">
              For cards like UOB/OCBC that use $5 blocks, or $1 for direct point calculations
            </p>
          </div>
          
          {/* Bonus Multiplier */}
          <div>
            <Label htmlFor="bonusMultiplier">Bonus Multiplier</Label>
            <Input
              id="bonusMultiplier"
              type="number"
              step="0.1"
              value={formData.reward.bonusMultiplier}
              onChange={(e) => 
                handleRewardChange('bonusMultiplier', parseFloat(e.target.value))
              }
              placeholder="Bonus points per dollar or per block"
            />
            <p className="text-xs text-gray-500 mt-1">
              E.g., 1.8 = 9 points per $5 with block size of 5 (after 1 base point)
            </p>
          </div>
          
          {/* Monthly Cap */}
          <div>
            <Label htmlFor="monthlyCap">Monthly Bonus Points Cap</Label>
            <Input
              id="monthlyCap"
              type="number"
              value={formData.reward.monthlyCap || ''}
              onChange={(e) => 
                handleRewardChange('monthlyCap', e.target.value ? parseInt(e.target.value) : undefined)
              }
              placeholder="Leave empty for no cap"
            />
            <p className="text-xs text-gray-500 mt-1">
              Maximum bonus points that can be earned per month
            </p>
          </div>
          
          {/* Minimum Monthly Spend */}
          <div>
            <Label htmlFor="monthlyMinSpend">Minimum Monthly Spend</Label>
            <Input
              id="monthlyMinSpend"
              type="number"
              value={formData.reward.monthlyMinSpend || ''}
              onChange={(e) => 
                handleRewardChange('monthlyMinSpend', e.target.value ? parseInt(e.target.value) : undefined)
              }
              placeholder="Leave empty for no minimum"
            />
          </div>
          
          {/* Monthly Spend Period Type */}
          {formData.reward.monthlyMinSpend && (
            <div>
              <Label htmlFor="monthlySpendPeriodType">Spending Period Type</Label>
              <Select
                value={formData.reward.monthlySpendPeriodType || 'calendar_month'}
                onValueChange={(value: SpendingPeriodType) => 
                  handleRewardChange('monthlySpendPeriodType', value)
                }
              >
                <SelectTrigger id="monthlySpendPeriodType">
                  <SelectValue placeholder="Select period type" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="calendar_month">Calendar Month</SelectItem>
                  <SelectItem value="statement_month">Statement Month</SelectItem>
                </SelectContent>
              </Select>
            </div>
          )}
          
          {/* Amount Rounding Strategy */}
          <div>
            <Label htmlFor="amountRoundingStrategy">Amount Rounding Strategy</Label>
            <Select
              value={formData.reward.amountRoundingStrategy}
              onValueChange={(value: RoundingStrategy) => 
                handleRewardChange('amountRoundingStrategy', value)
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="Select rounding strategy" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="floor">Round Down (Floor)</SelectItem>
                <SelectItem value="ceiling">Round Up (Ceiling)</SelectItem>
                <SelectItem value="nearest">Round to Nearest</SelectItem>
                <SelectItem value="floor5">Round Down to Nearest $5</SelectItem>
                <SelectItem value="none">No Rounding</SelectItem>
              </SelectContent>
            </Select>
          </div>
          
          {/* Points Rounding Strategy */}
          <div>
            <Label htmlFor="pointsRoundingStrategy">Points Rounding Strategy</Label>
            <Select
              value={formData.reward.pointsRoundingStrategy}
              onValueChange={(value: RoundingStrategy) => 
                handleRewardChange('pointsRoundingStrategy', value)
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="Select rounding strategy" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="floor">Round Down (Floor)</SelectItem>
                <SelectItem value="ceiling">Round Up (Ceiling)</SelectItem>
                <SelectItem value="nearest">Round to Nearest</SelectItem>
                <SelectItem value="floor5">Round Down to Nearest $5</SelectItem>
                <SelectItem value="none">No Rounding</SelectItem>
              </SelectContent>
            </Select>
          </div>
          
          {/* Points Currency */}
          <div>
            <Label htmlFor="pointsCurrency">Points Currency</Label>
            <Input
              id="pointsCurrency"
              value={formData.reward.pointsCurrency}
              onChange={(e) => 
                handleRewardChange('pointsCurrency', e.target.value)
              }
              placeholder="E.g., UNI$, ThankYou Points, DBS Points"
            />
          </div>
          
          {/* Preview */}
          <Card className="mt-6">
            <CardHeader>
              <CardTitle>Rate Preview</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                <div className="text-2xl font-bold">
                  {(formData.reward.baseMultiplier + formData.reward.bonusMultiplier).toFixed(1)}x
                </div>
                <div className="text-sm text-muted-foreground">
                  Base: {formData.reward.baseMultiplier.toFixed(1)}x + 
                  Bonus: {formData.reward.bonusMultiplier.toFixed(1)}x
                </div>
                {formData.reward.blockSize > 1 && (
                  <div className="text-sm text-muted-foreground">
                    Per ${formData.reward.blockSize} block
                  </div>
                )}
                {formData.reward.monthlyCap && (
                  <div className="text-sm text-muted-foreground">
                    Monthly cap: {formData.reward.monthlyCap.toLocaleString()} bonus points
                  </div>
                )}
              </div>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
      
      <div className="flex justify-end space-x-2 pt-4">
        <Button type="button" variant="outline" onClick={onCancel}>
          Cancel
        </Button>
        <Button type="submit">
          {rule ? 'Update Rule' : 'Create Rule'}
        </Button>
      </div>
    </form>
  );
};

export default RewardRuleEditor;

================
File: components/rewards/RewardRuleManager.tsx
================
// components/rewards/RewardRuleManager.tsx

import React, { useEffect, useState } from 'react';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Card, CardContent, CardFooter, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { CoinsIcon, Plus, PencilIcon, TrashIcon } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { RewardRule } from '@/services/rewards/types';
import { RuleRepository } from '@/services/rewards/RuleRepository';
import { CardRegistry } from '@/services/rewards/CardRegistry';
import RewardRuleEditor from './RewardRuleEditor';

interface RewardRuleManagerProps {
  cardTypeId: string;
}

export const RewardRuleManager: React.FC<RewardRuleManagerProps> = ({ cardTypeId }) => {
  const [rules, setRules] = useState<RewardRule[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [editingRule, setEditingRule] = useState<RewardRule | undefined>(undefined);
  const { toast } = useToast();
  
  const ruleRepository = RuleRepository.getInstance();
  const cardRegistry = CardRegistry.getInstance();
  
  // Load rules when component mounts
  useEffect(() => {
    const loadRules = async () => {
      try {
        setIsLoading(true);
        const loadedRules = await ruleRepository.getRulesForCardType(cardTypeId);
        setRules(loadedRules);
      } catch (error) {
        console.error('Error loading rules:', error);
        toast({
          title: 'Error',
          description: 'Failed to load reward rules',
          variant: 'destructive',
        });
      } finally {
        setIsLoading(false);
      }
    };
    
    loadRules();
  }, [cardTypeId, toast]);
  
  // Get card name for display
  const getCardName = (): string => {
    const cardType = cardRegistry.getCardType(cardTypeId);
    if (cardType) {
      return `${cardType.issuer} ${cardType.name}`;
    }
    return cardTypeId;
  };
  
  // Handle adding a new rule
  const handleAddRule = () => {
    setEditingRule(undefined);
    setIsDialogOpen(true);
  };
  
  // Handle editing an existing rule
  const handleEditRule = (rule: RewardRule) => {
    setEditingRule(rule);
    setIsDialogOpen(true);
  };
  
  // Handle saving a rule
  const handleSaveRule = async (rule: RewardRule) => {
    try {
      const savedRule = await ruleRepository.saveRule(rule);
      
      if (savedRule) {
        // Update local rules state
        const isNewRule = !rules.some(r => r.id === savedRule.id);
        
        if (isNewRule) {
          setRules(prev => [...prev, savedRule]);
        } else {
          setRules(prev => prev.map(r => r.id === savedRule.id ? savedRule : r));
        }
        
        toast({
          title: 'Success',
          description: `Rule ${isNewRule ? 'created' : 'updated'} successfully`,
        });
        
        setIsDialogOpen(false);
      } else {
        toast({
          title: 'Error',
          description: 'Failed to save rule',
          variant: 'destructive',
        });
      }
    } catch (error) {
      console.error('Error saving rule:', error);
      toast({
        title: 'Error',
        description: 'Failed to save rule',
        variant: 'destructive',
      });
    }
  };
  
  // Handle deleting a rule
  const handleDeleteRule = async (ruleId: string) => {
    // Confirm deletion
    if (!window.confirm('Are you sure you want to delete this rule?')) {
      return;
    }
    
    try {
      const success = await ruleRepository.deleteRule(ruleId);
      
      if (success) {
        // Update local rules state
        setRules(prev => prev.filter(r => r.id !== ruleId));
        
        toast({
          title: 'Success',
          description: 'Rule deleted successfully',
        });
      } else {
        toast({
          title: 'Error',
          description: 'Failed to delete rule',
          variant: 'destructive',
        });
      }
    } catch (error) {
      console.error('Error deleting rule:', error);
      toast({
        title: 'Error',
        description: 'Failed to delete rule',
        variant: 'destructive',
      });
    }
  };
  
  // Format condition for display
  const formatCondition = (rule: RewardRule): string => {
    const conditions = rule.conditions;
    
    if (!conditions || conditions.length === 0) {
      return 'All transactions';
    }
    
    const parts: string[] = [];
    
    // Check for transaction type
    const transactionTypeCondition = conditions.find(c => c.type === 'transaction_type');
    if (transactionTypeCondition && transactionTypeCondition.values && transactionTypeCondition.values.length > 0) {
      const type = transactionTypeCondition.values[0];
      if (type === 'online') {
        parts.push('Online transactions');
      } else if (type === 'contactless') {
        parts.push('Contactless payments');
      } else if (type === 'in_store') {
        parts.push('In-store transactions');
      }
    }
    
    // Check for MCC codes
    const mccCondition = conditions.find(c => c.type === 'mcc');
    if (mccCondition && mccCondition.values && mccCondition.values.length > 0) {
      const mccCount = mccCondition.values.length;
      parts.push(`${mccCount} MCC code${mccCount > 1 ? 's' : ''}`);
    }
    
    // Check for merchant names
    const merchantCondition = conditions.find(c => c.type === 'merchant');
    if (merchantCondition && merchantCondition.values && merchantCondition.values.length > 0) {
      const merchantCount = merchantCondition.values.length;
      parts.push(`${merchantCount} merchant${merchantCount > 1 ? 's' : ''}`);
    }
    
    return parts.join(', ') || 'Custom conditions';
  };
  
  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h2 className="text-xl font-semibold flex items-center gap-2">
          <CoinsIcon className="h-5 w-5" />
          Reward Rules for {getCardName()}
        </h2>
        <Button onClick={handleAddRule}>
          <Plus className="h-4 w-4 mr-2" />
          Add Rule
        </Button>
      </div>
      
      {isLoading ? (
        <div className="flex justify-center py-8">
          <div className="animate-spin h-8 w-8 border-4 border-primary border-t-transparent rounded-full"></div>
        </div>
      ) : rules.length === 0 ? (
        <Card>
          <CardContent className="py-8 text-center">
            <CoinsIcon className="h-12 w-12 mx-auto mb-4 text-gray-400" />
            <p className="text-gray-500">No reward rules defined for this card type.</p>
            <Button className="mt-4" onClick={handleAddRule}>
              <Plus className="h-4 w-4 mr-2" />
              Add First Rule
            </Button>
          </CardContent>
        </Card>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {rules.map(rule => (
            <Card key={rule.id} className={rule.enabled ? undefined : 'opacity-60'}>
              <CardHeader className="pb-2">
                <div className="flex justify-between items-start">
                  <div>
                    <CardTitle>{rule.name}</CardTitle>
                    <CardDescription>{rule.description}</CardDescription>
                  </div>
                  <Badge 
                    className={rule.enabled ? 'bg-green-500' : 'bg-gray-500'}
                  >
                    {(rule.reward.baseMultiplier + rule.reward.bonusMultiplier).toFixed(1)}x
                  </Badge>
                </div>
              </CardHeader>
              <CardContent className="py-2">
                <div className="space-y-2 text-sm">
                  <div>
                    <span className="font-medium">Conditions:</span> {formatCondition(rule)}
                  </div>
                  <div>
                    <span className="font-medium">Calculation:</span> 
                    {rule.reward.baseMultiplier.toFixed(1)}x base + 
                    {rule.reward.bonusMultiplier.toFixed(1)}x bonus
                    {rule.reward.blockSize > 1 ? ` per $${rule.reward.blockSize}` : ' per $1'}
                  </div>
                  {rule.reward.monthlyCap && (
                    <div>
                      <span className="font-medium">Monthly Cap:</span> 
                      {rule.reward.monthlyCap.toLocaleString()} bonus points
                    </div>
                  )}
                  {rule.reward.monthlyMinSpend && (
                    <div>
                      <span className="font-medium">Minimum Spend:</span> 
                      ${rule.reward.monthlyMinSpend.toLocaleString()} per 
                      {rule.reward.monthlySpendPeriodType === 'statement_month' 
                        ? ' statement month' 
                        : ' calendar month'}
                    </div>
                  )}
                </div>
              </CardContent>
              <CardFooter className="pt-0 flex justify-end space-x-2">
                <Button variant="outline" size="sm" onClick={() => handleEditRule(rule)}>
                  <PencilIcon className="h-4 w-4 mr-1" />
                  Edit
                </Button>
                <Button size="sm" variant="destructive" onClick={() => handleDeleteRule(rule.id)}>
                  <TrashIcon className="h-4 w-4 mr-1" />
                  Delete
                </Button>
              </CardFooter>
            </Card>
          ))}
        </div>
      )}
      
      <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
        <DialogContent className="max-w-3xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>{editingRule ? 'Edit Rule' : 'Create Rule'}</DialogTitle>
          </DialogHeader>
          <RewardRuleEditor
            rule={editingRule}
            cardTypeId={cardTypeId}
            onSave={handleSaveRule}
            onCancel={() => setIsDialogOpen(false)}
          />
        </DialogContent>
      </Dialog>
    </div>
  );
};

export default RewardRuleManager;

================
File: hooks/useExpenseForm.ts
================
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { PaymentMethod, MerchantCategoryCode } from '@/types';
import { useToast } from '@/hooks/use-toast';
import { FormValues, formSchema } from '@/hooks/expense/expense-form/formSchema';
import { useMerchantData } from '@/hooks/expense/expense-form/useMerchantData';
import { usePaymentMethodLogic } from '@/hooks/expense/expense-form/usePaymentMethodLogic';
import { useRewardPointsStandalone } from '@/hooks/expense/expense-form/useRewardPointsStandalone';
import { useState, useEffect } from 'react';

interface UseExpenseFormProps {
  paymentMethods: PaymentMethod[];
  defaultValues?: Partial<FormValues>;
}

// Change regular export to type export
export type { FormValues } from '@/hooks/expense/expense-form/formSchema';

export const useExpenseForm = ({ paymentMethods, defaultValues }: UseExpenseFormProps) => {
  const { toast } = useToast();
  const [estimatedPoints, setEstimatedPoints] = useState<number | {
    totalPoints: number;
    basePoints?: number;
    bonusPoints?: number;
    remainingMonthlyBonusPoints?: number;
    pointsCurrency?: string;
    messageText?: string;
  }>(0);
  
  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      merchantName: defaultValues?.merchantName || '',
      merchantAddress: defaultValues?.merchantAddress || '',
      isOnline: defaultValues?.isOnline ?? false,
      isContactless: defaultValues?.isContactless ?? false,
      amount: defaultValues?.amount || '',
      currency: defaultValues?.currency || 'SGD',
      paymentMethodId: defaultValues?.paymentMethodId || '',
      paymentAmount: defaultValues?.paymentAmount || '',
      date: defaultValues?.date || new Date(),
      notes: defaultValues?.notes || '',
      mcc: defaultValues?.mcc || null,
    },
  });
  
  const merchantName = form.watch('merchantName');
  const currency = form.watch('currency') as any;
  const amount = Number(form.watch('amount')) || 0;
  const paymentAmount = Number(form.watch('paymentAmount')) || 0;
  const isOnline = form.watch('isOnline');
  const isContactless = form.watch('isContactless');
  const paymentMethodId = form.watch('paymentMethodId');
  
  // Updated to properly handle null MCC
  const [selectedMCC, setSelectedMCC] = useState<MerchantCategoryCode | null>(null);
  
  // Initialize selectedMCC from form default values if available
  useEffect(() => {
    if (defaultValues?.mcc) {
      setSelectedMCC(defaultValues.mcc);
    }
  }, [defaultValues?.mcc]);
  
  const { selectedPaymentMethod, shouldOverridePayment } = usePaymentMethodLogic(
    form,
    paymentMethods,
    currency,
    amount,
    isOnline
  );
  
  // Use the standalone simulatePoints from our hook - passing the full array of paymentMethods
  const { estimatedPoints: calculatedPoints } = useRewardPointsStandalone(
    shouldOverridePayment ? paymentAmount : amount,
    paymentMethodId,
    paymentMethods,
    selectedMCC?.code,
    merchantName,
    isOnline,
    isContactless
  );
  
  // Update the local state when the calculated points change
  useEffect(() => {
    setEstimatedPoints(calculatedPoints);
  }, [calculatedPoints]);

  return {
    form,
    selectedMCC,
    setSelectedMCC,
    selectedPaymentMethod,
    shouldOverridePayment,
    estimatedPoints,
  };
};

================
File: hooks/useSupabaseConnectionCheck.ts
================
import { useState, useEffect } from 'react';
import { supabase, USE_LOCAL_STORAGE_DEFAULT } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';

export const useSupabaseConnectionCheck = () => {
  const [supabaseConnected, setSupabaseConnected] = useState<boolean | null>(null);
  const [useLocalStorage, setUseLocalStorage] = useState<boolean>(USE_LOCAL_STORAGE_DEFAULT);
  const { toast } = useToast();

  useEffect(() => {
    if (!USE_LOCAL_STORAGE_DEFAULT) {
      const checkSupabaseConnection = async () => {
        try {
          console.log('Checking Supabase connection...');
          const { data, error } = await supabase.from('payment_methods').select('id').limit(1);
          
          if (error) {
            console.error('Supabase connection error:', error);
            setSupabaseConnected(false);
            setUseLocalStorage(true);
            toast({
              title: 'Warning',
              description: 'Supabase connection failed. Using local storage fallback.',
              variant: 'destructive',
            });
          } else {
            console.log('Supabase connection successful');
            setSupabaseConnected(true);
            setUseLocalStorage(false);
          }
        } catch (error) {
          console.error('Error checking Supabase connection:', error);
          setSupabaseConnected(false);
          setUseLocalStorage(true);
          toast({
            title: 'Warning',
            description: 'Supabase connection failed. Using local storage fallback.',
            variant: 'destructive',
          });
        }
      };
      
      checkSupabaseConnection();
    } else {
      // Default to local storage without checking Supabase
      setSupabaseConnected(false);
      setUseLocalStorage(true);
      console.log('Using local storage by default.');
    }
  }, [toast]);

  return { supabaseConnected, useLocalStorage };
};

================
File: hooks/useTransactionList.ts
================
import { useTransactionData } from './transaction-list/useTransactionData';
import { useTransactionFilters } from './transaction-list/useTransactionFilters';
import { FilterOptions, SortOption } from './transaction-list/types';

export type { FilterOptions, SortOption };

export const useTransactionList = () => {
  // Get transaction data
  const { 
    transactions, 
    setTransactions, 
    paymentMethods, 
    isLoading,
    refreshTransactions
  } = useTransactionData();

  // Apply filters and sorting
  const {
    filteredTransactions,
    sortOption,
    setSortOption,
    searchQuery,
    setSearchQuery,
    filterOptions,
    handleFilterChange,
    activeFilters,
    resetFilters
  } = useTransactionFilters(transactions, isLoading);

  return {
    transactions,
    setTransactions,
    paymentMethods,
    filteredTransactions,
    sortOption,
    setSortOption,
    searchQuery,
    setSearchQuery,
    filterOptions,
    handleFilterChange,
    activeFilters,
    resetFilters,
    isLoading,
    refreshTransactions
  };
};

================
File: hooks/useTransactionSubmit.ts
================
// hooks/useTransactionSubmit.ts
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Transaction } from '@/types';
import { addTransaction, storageService } from '@/services/storage';
import { useToast } from '@/hooks/use-toast';

/**
 * Hook for submitting transaction data with proper error handling and navigation
 */
export const useTransactionSubmit = (useLocalStorage: boolean = false) => {
  const [isLoading, setIsLoading] = useState(false);
  const [saveError, setSaveError] = useState<string | null>(null);
  const navigate = useNavigate();
  const { toast } = useToast();

  // Set storage mode for the service
  storageService.setLocalStorageMode(useLocalStorage);

  /**
   * Submit a transaction
   */
  const handleSubmit = async (transactionData: Omit<Transaction, 'id'>) => {
    try {
      console.log('Starting transaction save process...');
      console.log('Initial transaction data:', JSON.stringify(transactionData, null, 2));
      
      setSaveError(null);
      setIsLoading(true);
      
      // Validate merchant information
      if (!transactionData.merchant || !transactionData.merchant.name) {
        console.error('Merchant validation failed:', transactionData.merchant);
        throw new Error('Merchant information is missing');
      }
      
      // Validate payment method
      if (!transactionData.paymentMethod || !transactionData.paymentMethod.id) {
        console.error('Payment method validation failed:', transactionData.paymentMethod);
        throw new Error('Payment method is missing or invalid');
      }
      
      // Validate payment amount
      if (isNaN(transactionData.paymentAmount) || transactionData.paymentAmount <= 0) {
        console.error('Payment amount validation failed:', transactionData.paymentAmount);
        throw new Error('Invalid payment amount');
      }
      
      console.log('Validated transaction data:', {
        merchant: transactionData.merchant.name,
        merchantId: transactionData.merchant.id,
        amount: transactionData.amount,
        currency: transactionData.currency,
        paymentMethod: transactionData.paymentMethod.name,
        paymentMethodId: transactionData.paymentMethod.id,
        date: transactionData.date
      });
      
      // Save the transaction
      const result = await addTransaction(transactionData);
      
      console.log('Transaction saved successfully:', result);
      
      toast({
        title: 'Success',
        description: 'Transaction saved successfully',
      });
      
      // Navigate back to the dashboard to see updated metrics
      navigate('/');
      return result;
    } catch (error) {
      console.error('Error saving transaction:', error);
      
      let errorMessage = 'Failed to save transaction';
      
      // Detailed error information for debugging
      if (error instanceof Error) {
        errorMessage = error.message;
        console.error('Error instance details:', {
          message: error.message,
          stack: error.stack
        });
        
        // Check for specific errors
        if (error.message.includes('duplicate key') || error.message.includes('constraint')) {
          errorMessage = 'A merchant with this name already exists';
        } else if (error.message.includes('network')) {
          errorMessage = 'Network error - please check your connection';
        }
      }
      
      setSaveError(errorMessage);
      
      toast({
        title: 'Error',
        description: errorMessage,
        variant: 'destructive',
      });
      
      // Don't navigate when there's an error, let user fix and try again
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  return { handleSubmit, isLoading, saveError };
};

================
File: services/currency/index.ts
================
// services/currency/index.ts
import { Currency, PaymentMethod } from "@/types";

/**
 * Centralized Currency Service for handling all currency-related operations
 * including formatting, conversion, and currency information.
 */
export class CurrencyService {
  /**
   * List of currencies that don't use decimal places
   */
  private static readonly NO_DECIMAL_CURRENCIES = ["JPY", "VND", "IDR", "TWD"];

  /**
   * Currency symbols mapping
   */
  private static readonly CURRENCY_SYMBOLS: Record<Currency, string> = {
    USD: "$",
    EUR: "",
    GBP: "",
    JPY: "",
    AUD: "A$",
    CAD: "C$",
    CNY: "",
    INR: "",
    TWD: "NT$",
    SGD: "S$",
    VND: "",
    IDR: "Rp",
    THB: "",
    MYR: "RM",
  };

  /**
   * Default exchange rates - in a real app, these would come from an API
   */
  private static readonly DEFAULT_EXCHANGE_RATES: Record<
    Currency,
    Record<Currency, number>
  > = {
    USD: {
      USD: 1,
      EUR: 0.93,
      GBP: 0.79,
      JPY: 151.77,
      AUD: 1.53,
      CAD: 1.37,
      CNY: 7.26,
      INR: 83.42,
      TWD: 32.27,
      SGD: 1.35,
      VND: 25305,
      IDR: 16158,
      THB: 36.17,
      MYR: 4.72,
    },
    EUR: {
      USD: 1.08,
      EUR: 1,
      GBP: 0.85,
      JPY: 163.59,
      AUD: 1.65,
      CAD: 1.47,
      CNY: 7.83,
      INR: 89.93,
      TWD: 34.78,
      SGD: 1.45,
      VND: 27276,
      IDR: 17416,
      THB: 38.99,
      MYR: 5.09,
    },
    GBP: {
      USD: 1.27,
      EUR: 1.18,
      GBP: 1,
      JPY: 192.96,
      AUD: 1.94,
      CAD: 1.74,
      CNY: 9.24,
      INR: 106.06,
      TWD: 41.04,
      SGD: 1.71,
      VND: 32179,
      IDR: 20548,
      THB: 46.0,
      MYR: 6.0,
    },
    JPY: {
      USD: 0.0066,
      EUR: 0.0061,
      GBP: 0.0052,
      JPY: 1,
      AUD: 0.01,
      CAD: 0.009,
      CNY: 0.048,
      INR: 0.55,
      TWD: 0.21,
      SGD: 0.0089,
      VND: 166.73,
      IDR: 106.43,
      THB: 0.24,
      MYR: 0.031,
    },
    AUD: {
      USD: 0.65,
      EUR: 0.61,
      GBP: 0.52,
      JPY: 99.06,
      AUD: 1,
      CAD: 0.89,
      CNY: 4.74,
      INR: 54.47,
      TWD: 21.08,
      SGD: 0.88,
      VND: 16524,
      IDR: 10551,
      THB: 23.61,
      MYR: 3.08,
    },
    CAD: {
      USD: 0.73,
      EUR: 0.68,
      GBP: 0.58,
      JPY: 111.31,
      AUD: 1.12,
      CAD: 1,
      CNY: 5.32,
      INR: 61.2,
      TWD: 23.68,
      SGD: 0.99,
      VND: 18564,
      IDR: 11854,
      THB: 26.53,
      MYR: 3.46,
    },
    CNY: {
      USD: 0.14,
      EUR: 0.13,
      GBP: 0.11,
      JPY: 20.9,
      AUD: 0.21,
      CAD: 0.19,
      CNY: 1,
      INR: 11.49,
      TWD: 4.45,
      SGD: 0.19,
      VND: 3486,
      IDR: 2225,
      THB: 4.98,
      MYR: 0.65,
    },
    INR: {
      USD: 0.012,
      EUR: 0.011,
      GBP: 0.0094,
      JPY: 1.82,
      AUD: 0.018,
      CAD: 0.016,
      CNY: 0.087,
      INR: 1,
      TWD: 0.39,
      SGD: 0.016,
      VND: 303.33,
      IDR: 193.69,
      THB: 0.43,
      MYR: 0.057,
    },
    TWD: {
      USD: 0.031,
      EUR: 0.029,
      GBP: 0.024,
      JPY: 4.71,
      AUD: 0.047,
      CAD: 0.042,
      CNY: 0.22,
      INR: 2.59,
      TWD: 1,
      SGD: 0.042,
      VND: 784.16,
      IDR: 500.71,
      THB: 1.12,
      MYR: 0.15,
    },
    SGD: {
      USD: 0.74,
      EUR: 0.69,
      GBP: 0.58,
      JPY: 112.8,
      AUD: 1.14,
      CAD: 1.01,
      CNY: 5.39,
      INR: 61.97,
      TWD: 23.98,
      SGD: 1,
      VND: 18796,
      IDR: 12005,
      THB: 26.88,
      MYR: 3.51,
    },
    VND: {
      USD: 0.00004,
      EUR: 0.000037,
      GBP: 0.000031,
      JPY: 0.006,
      AUD: 0.000061,
      CAD: 0.000054,
      CNY: 0.00029,
      INR: 0.0033,
      TWD: 0.0013,
      SGD: 0.000053,
      VND: 1,
      IDR: 0.64,
      THB: 0.0014,
      MYR: 0.00019,
    },
    IDR: {
      USD: 0.000062,
      EUR: 0.000057,
      GBP: 0.000049,
      JPY: 0.0094,
      AUD: 0.000095,
      CAD: 0.000084,
      CNY: 0.00045,
      INR: 0.0052,
      TWD: 0.002,
      SGD: 0.000083,
      VND: 1.57,
      IDR: 1,
      THB: 0.0022,
      MYR: 0.00029,
    },
    THB: {
      USD: 0.028,
      EUR: 0.026,
      GBP: 0.022,
      JPY: 4.2,
      AUD: 0.042,
      CAD: 0.038,
      CNY: 0.2,
      INR: 2.31,
      TWD: 0.89,
      SGD: 0.037,
      VND: 699.81,
      IDR: 446.86,
      THB: 1,
      MYR: 0.13,
    },
    MYR: {
      USD: 0.21,
      EUR: 0.2,
      GBP: 0.17,
      JPY: 32.15,
      AUD: 0.32,
      CAD: 0.29,
      CNY: 1.54,
      INR: 17.67,
      TWD: 6.84,
      SGD: 0.29,
      VND: 5360,
      IDR: 3423,
      THB: 7.66,
      MYR: 1,
    },
  };

  /**
   * Currency options for dropdown selects
   */
  private static readonly CURRENCY_OPTIONS: {
    value: Currency;
    label: string;
  }[] = [
    { value: "USD", label: "USD - US Dollar ($)" },
    { value: "EUR", label: "EUR - Euro ()" },
    { value: "GBP", label: "GBP - British Pound ()" },
    { value: "JPY", label: "JPY - Japanese Yen ()" },
    { value: "AUD", label: "AUD - Australian Dollar (A$)" },
    { value: "CAD", label: "CAD - Canadian Dollar (C$)" },
    { value: "CNY", label: "CNY - Chinese Yuan ()" },
    { value: "INR", label: "INR - Indian Rupee ()" },
    { value: "TWD", label: "TWD - New Taiwan Dollar (NT$)" },
    { value: "SGD", label: "SGD - Singapore Dollar (S$)" },
    { value: "VND", label: "VND - Vietnamese Dong ()" },
    { value: "IDR", label: "IDR - Indonesian Rupiah (Rp)" },
    { value: "THB", label: "THB - Thai Baht ()" },
    { value: "MYR", label: "MYR - Malaysian Ringgit (RM)" },
  ];

  /**
   * Formats a currency amount with the appropriate symbol and formatting rules
   *
   * @param amount - Amount to format
   * @param currency - Currency code
   * @returns Formatted currency string (e.g., "$123.45")
   */
  public static format(amount: number, currency: Currency): string {
    // Handle edge cases where currency might be undefined or invalid
    if (!currency || !Object.keys(this.CURRENCY_SYMBOLS).includes(currency)) {
      console.warn(
        `Invalid currency provided: ${currency}, using USD as fallback`
      );
      currency = "USD" as Currency;
    }

    // Get decimal places based on currency type
    const decimalPlaces = this.NO_DECIMAL_CURRENCIES.includes(currency) ? 0 : 2;

    // Format the number part with appropriate decimal places
    const formatter = new Intl.NumberFormat("en-US", {
      style: "decimal", // Use decimal style to avoid built-in currency symbols
      minimumFractionDigits: decimalPlaces,
      maximumFractionDigits: decimalPlaces,
    });

    // Get the correct currency symbol from our mapping
    const symbol = this.CURRENCY_SYMBOLS[currency];

    // Return the formatted string with our custom symbol
    return `${symbol}${formatter.format(amount)}`;
  }

  /**
   * Converts an amount from one currency to another
   *
   * @param amount - Amount to convert
   * @param fromCurrency - Source currency code
   * @param toCurrency - Target currency code
   * @param paymentMethod - Optional payment method with custom conversion rates
   * @returns Converted amount in the target currency
   */
  public static convert(
    amount: number,
    fromCurrency: Currency,
    toCurrency: Currency,
    paymentMethod?: PaymentMethod
  ): number {
    if (fromCurrency === toCurrency) return amount;

    // Check if payment method exists before trying to access its properties
    if (
      paymentMethod?.conversionRate &&
      paymentMethod.conversionRate[toCurrency] !== undefined
    ) {
      return amount * paymentMethod.conversionRate[toCurrency];
    }

    // Add validation for currency codes to prevent accessing undefined rates
    if (!this.DEFAULT_EXCHANGE_RATES[fromCurrency]) {
      console.error(`Invalid source currency: ${fromCurrency}`);
      return amount; // Return original amount if conversion not possible
    }

    if (!this.DEFAULT_EXCHANGE_RATES[fromCurrency][toCurrency]) {
      console.error(
        `Invalid target currency or exchange rate not available: ${fromCurrency} to ${toCurrency}`
      );
      return amount; // Return original amount if conversion not possible
    }

    // Now we can safely access the exchange rate
    return amount * this.DEFAULT_EXCHANGE_RATES[fromCurrency][toCurrency];
  }

  /**
   * Gets the symbol for a given currency
   *
   * @param currency - Currency code
   * @returns Currency symbol (e.g., "$" for USD)
   */
  public static getSymbol(currency: Currency): string {
    return this.CURRENCY_SYMBOLS[currency] || currency;
  }

  /**
   * Gets the list of currency options for dropdown menus
   *
   * @returns Array of currency options with value and label
   */
  public static getCurrencyOptions(): { value: Currency; label: string }[] {
    return [...this.CURRENCY_OPTIONS];
  }

  /**
   * Gets the exchange rate between two currencies
   *
   * @param fromCurrency - Source currency code
   * @param toCurrency - Target currency code
   * @returns Exchange rate or 1 if conversion not possible
   */
  public static getExchangeRate(fromCurrency: Currency, toCurrency: Currency): number {
    if (fromCurrency === toCurrency) return 1;

    if (
      !this.DEFAULT_EXCHANGE_RATES[fromCurrency] ||
      !this.DEFAULT_EXCHANGE_RATES[fromCurrency][toCurrency]
    ) {
      console.error(
        `Exchange rate not available: ${fromCurrency} to ${toCurrency}`
      );
      return 1;
    }

    return this.DEFAULT_EXCHANGE_RATES[fromCurrency][toCurrency];
  }
}

================
File: services/rewards/CardRegistry.ts
================
// services/rewards/CardRegistry.ts

import { CardType, RewardRule, TransactionType } from './types';
import { v4 as uuidv4 } from 'uuid';

/**
 * Registry for all card types and their default rules
 */
export class CardRegistry {
  private static instance: CardRegistry;
  private cardTypes: Map<string, CardType> = new Map();
  
  private constructor() {
    this.initializeDefaultCards();
  }
  
  /**
   * Get singleton instance
   */
  public static getInstance(): CardRegistry {
    if (!CardRegistry.instance) {
      CardRegistry.instance = new CardRegistry();
    }
    return CardRegistry.instance;
  }
  
  /**
   * Register a card type
   */
  public registerCardType(cardType: CardType): void {
    this.cardTypes.set(cardType.id, cardType);
  }
  
  /**
   * Get a card type by ID
   */
  public getCardType(id: string): CardType | undefined {
    return this.cardTypes.get(id);
  }
  
  /**
   * Get a card type by issuer and name
   */
  public getCardTypeByIssuerAndName(issuer: string, name: string): CardType | undefined {
    const normalizedIssuer = issuer.toLowerCase();
    const normalizedName = name.toLowerCase();
    
    for (const cardType of this.cardTypes.values()) {
      if (cardType.issuer.toLowerCase() === normalizedIssuer && 
          cardType.name.toLowerCase() === normalizedName) {
        return cardType;
      }
    }
    
    return undefined;
  }
  
  /**
   * Get all card types
   */
  public getAllCardTypes(): CardType[] {
    return Array.from(this.cardTypes.values());
  }
  
  /**
   * Get card types by issuer
   */
  public getCardTypesByIssuer(issuer: string): CardType[] {
    const normalizedIssuer = issuer.toLowerCase();
    
    return Array.from(this.cardTypes.values())
      .filter(cardType => cardType.issuer.toLowerCase() === normalizedIssuer);
  }
  
  /**
   * Initialize default card types
   */
  private initializeDefaultCards(): void {
    // 1. DBS Woman's World Card
    this.registerCardType({
      id: 'dbs-womans-world-mastercard',
      issuer: 'DBS',
      name: 'Woman\'s World MasterCard',
      pointsCurrency: 'DBS Points',
      defaultRules: [
        this.createDBSWomansWorldCardRule()
      ]
    });
    
    // 2. Citibank Rewards Card
    this.registerCardType({
      id: 'citibank-rewards-visa-signature',
      issuer: 'Citibank',
      name: 'Rewards Visa Signature',
      pointsCurrency: 'ThankYou Points',
      defaultRules: [
        this.createCitibankRewardsCardRule()
      ]
    });
    
    // 3. UOB Preferred Platinum Card
    this.registerCardType({
      id: 'uob-preferred-visa-platinum',
      issuer: 'UOB',
      name: 'Preferred Visa Platinum',
      pointsCurrency: 'UNI$',
      defaultRules: [
        this.createUOBPlatinumCardRule()
      ]
    });
    
    // 4. UOB Lady's Solitaire Card
    this.registerCardType({
      id: 'uob-ladys-solitaire-world-mastercard',
      issuer: 'UOB',
      name: 'Lady\'s Solitaire',
      pointsCurrency: 'UNI$',
      hasCategories: true,
      availableCategories: [
        'Beauty & Wellness',
        'Dining',
        'Entertainment',
        'Family',
        'Fashion',
        'Transport',
        'Travel'
      ],
      maxCategoriesSelectable: 2,
      defaultRules: [
        this.createUOBLadysSolitaireCardRule()
      ]
    });
    
    // 5. UOB Visa Signature Card
    this.registerCardType({
      id: 'uob-visa-signature',
      issuer: 'UOB',
      name: 'Visa Signature',
      pointsCurrency: 'UNI$',
      defaultRules: [
        this.createUOBVisaSignatureCardRule()
      ]
    });
    
    // 6. OCBC Rewards World Card
    this.registerCardType({
      id: 'ocbc-rewards-world-mastercard',
      issuer: 'OCBC',
      name: 'Rewards World Mastercard',
      pointsCurrency: 'OCBC$',
      defaultRules: [
        this.createOCBCRewardsWorldCardRule()
      ]
    });
    
    // 7. Amex Platinum Credit
    this.registerCardType({
      id: 'amex-platinum-credit-sg',
      issuer: 'American Express',
      name: 'Platinum Credit',
      pointsCurrency: 'Membership Rewards Points',
      defaultRules: [
        this.createAmexPlatinumCreditCardRule()
      ]
    });
    
    // 8. Amex Platinum Singapore
    this.registerCardType({
      id: 'amex-platinum-sg',
      issuer: 'American Express',
      name: 'Platinum Singapore',
      pointsCurrency: 'Membership Rewards Points',
      defaultRules: [
        this.createAmexPlatinumSingaporeCardRule()
      ]
    });
    
    // 9. Amex Platinum Canada
    this.registerCardType({
      id: 'amex-platinum-ca',
      issuer: 'American Express',
      name: 'Platinum Canada',
      pointsCurrency: 'Membership Rewards Points',
      defaultRules: [
        this.createAmexPlatinumCanadaCardRule()
      ]
    });
    
    // 10. Amex Cobalt
    this.registerCardType({
      id: 'amex-cobalt',
      issuer: 'American Express',
      name: 'Cobalt',
      pointsCurrency: 'Membership Rewards Points',
      defaultRules: [
        this.createAmexCobaltCardRule()
      ]
    });
    
    // 11. TD Aeroplan Visa Infinite
    this.registerCardType({
      id: 'td-aeroplan-visa-infinite',
      issuer: 'TD',
      name: 'Aeroplan Visa Infinite',
      pointsCurrency: 'Aeroplan Points',
      defaultRules: [
        this.createTDAeroplanVisaInfiniteCardRule()
      ]
    });
  }
  
  /**
   * 1. DBS Woman's World Card Rule
   * 10X DBS Points (20 miles) on online spend, capped at 2,000 bonus points monthly
   */
  private createDBSWomansWorldCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'dbs-womans-world-mastercard',
      name: 'Online Shopping 10X',
      description: '10X DBS Points (20 miles) on online spend',
      enabled: true,
      priority: 10,
      conditions: [
        {
          type: 'transaction_type',
          operation: 'equals',
          values: [TransactionType.ONLINE]
        }
      ],
      reward: {
        calculationMethod: 'standard',
        baseMultiplier: 1,
        bonusMultiplier: 9, // 9 additional points per $5
        pointsRoundingStrategy: 'floor',
        amountRoundingStrategy: 'floor5',
        blockSize: 5,
        monthlyCap: 2700, // Cap at 2,700 bonus points per month
        pointsCurrency: 'DBS Points'
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 2. Citibank Rewards Card Rule
   * 10X points on online or department store spend, capped at 4,000 bonus points monthly
   */
  private createCitibankRewardsCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'citibank-rewards-visa-signature',
      name: 'Citibank Rewards 10X',
      description: '10X ThankYou Points on online & department store shopping',
      enabled: true,
      priority: 10,
      conditions: [
        {
          type: 'compound',
          operation: 'any', // OR logic
          subConditions: [
            // Online transactions excluding airlines and travel
            {
              type: 'compound',
              operation: 'all', // AND logic
              subConditions: [
                {
                  type: 'transaction_type',
                  operation: 'equals',
                  values: [TransactionType.ONLINE]
                },
                {
                  type: 'mcc',
                  operation: 'exclude',
                  values: [
                    // Airlines (3000-3999)
                    ...[...Array(1000)].map((_, i) => `${3000 + i}`),
                    // Other excluded travel categories
                    '4511', '7512', '7011', '4111', '4112', '4789', 
                    '4411', '4722', '4723', '5962', '7012'
                  ]
                }
              ]
            },
            // Department store transactions
            {
              type: 'mcc',
              operation: 'include',
              values: [
                '5311', '5611', '5621', '5631', '5641', '5651', 
                '5655', '5661', '5691', '5699', '5948'
              ]
            }
          ]
        }
      ],
      reward: {
        calculationMethod: 'standard',
        baseMultiplier: 1,
        bonusMultiplier: 9, // 9x bonus points
        pointsRoundingStrategy: 'floor',
        amountRoundingStrategy: 'floor',
        blockSize: 1,
        monthlyCap: 9000, // Cap at 9,000 bonus points per month
        pointsCurrency: 'ThankYou Points'
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 3. UOB Preferred Platinum Card Rule
   * 10X UNI$ on online or contactless spending (with eligible MCCs), capped at 4,000 bonus points monthly
   */
  private createUOBPlatinumCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'uob-preferred-visa-platinum',
      name: 'UOB Platinum 10X',
      description: '10X UNI$ (4 miles) on online or contactless spending',
      enabled: true,
      priority: 10,
      conditions: [],
      reward: {
        calculationMethod: 'standard',
        baseMultiplier: 1,
        bonusMultiplier: 0, // No default bonus
        pointsRoundingStrategy: 'floor',
        amountRoundingStrategy: 'floor5',
        blockSize: 5,
        monthlyCap: 2000, // Shared cap: 2,000 bonus points per month
        pointsCurrency: 'UNI$',
        bonusTiers: [
          {
            name: 'Contactless Payments',
            priority: 1,
            multiplier: 9, // 9 additional points per $5
            condition: {
              type: 'transaction_type',
              operation: 'equals',
              values: [TransactionType.CONTACTLESS]
            }
          },
          {
            name: 'Online with Eligible MCCs',
            priority: 1,
            multiplier: 9, // 9 additional points per $5
            condition: {
              type: 'compound',
              operation: 'all', // AND logic
              subConditions: [
                {
                  type: 'transaction_type',
                  operation: 'equals',
                  values: [TransactionType.ONLINE]
                },
                {
                  type: 'mcc',
                  operation: 'include',
                  values: [
                    '4816', '5262', '5306', '5309', '5310', '5311', '5331', '5399', 
                    '5611', '5621', '5631', '5641', '5651', '5661', '5691', '5699',
                    '5732', '5733', '5734', '5735', '5912', '5942', '5944', '5945',
                    '5946', '5947', '5948', '5949', '5964', '5965', '5966', '5967',
                    '5968', '5969', '5970', '5992', '5999', '5811', '5812', '5814',
                    '5333', '5411', '5441', '5462', '5499', '8012', '9751', '7278',
                    '7832', '7841', '7922', '7991', '7996', '7998', '7999'
                  ]
                }
              ]
            }
          }
        ]
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 4. UOB Lady's Solitaire Card Rule
   * 10X UNI$ on spending in selected categories, capped at 3,600 bonus points monthly
   */
  private createUOBLadysSolitaireCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'uob-ladys-solitaire-world-mastercard',
      name: 'Selected Categories 10X',
      description: '10X UNI$ (4 miles) on spending in selected categories',
      enabled: true,
      priority: 10,
      conditions: [
        {
          type: 'category',
          operation: 'include',
          values: [] // This will be populated based on user selection
        }
      ],
      reward: {
        calculationMethod: 'standard',
        baseMultiplier: 1,
        bonusMultiplier: 9, // 9 additional points per $5
        pointsRoundingStrategy: 'floor',
        amountRoundingStrategy: 'floor5',
        blockSize: 5,
        monthlyCap: 3600, // Cap at 3,600 bonus points per month
        pointsCurrency: 'UNI$'
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 5. UOB Visa Signature Card Rule
   * 10X UNI$ on all foreign currency spending, capped at 8,000 points monthly
   * Minimum spend $1,000 in foreign currency per statement month to activate
   */
  private createUOBVisaSignatureCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'uob-visa-signature',
      name: 'Foreign Currency 10X',
      description: '10X UNI$ (4 miles) on all foreign currency spend',
      enabled: true,
      priority: 10,
      conditions: [
        {
          type: 'currency',
          operation: 'exclude',
          values: ['SGD'] // Any currency except SGD
        }
      ],
      reward: {
        calculationMethod: 'standard',
        baseMultiplier: 1,
        bonusMultiplier: 9, // 9 additional points per $5
        pointsRoundingStrategy: 'floor',
        amountRoundingStrategy: 'floor5',
        blockSize: 5,
        monthlyCap: 3600, // Cap at 3,600 bonus points per month
        monthlyMinSpend: 1000, // Min $1,000 foreign currency spend to qualify
        monthlySpendPeriodType: 'statement_month',
        pointsCurrency: 'UNI$'
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 6. OCBC Rewards World Card Rule
   * Tiered earning rates with shared monthly cap of 10,000 bonus points:
   * - Tier 1: 28X points on selected department stores/Watsons
   * - Tier 2: 18X points on other retail/dining
   */
  private createOCBCRewardsWorldCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'ocbc-rewards-world-mastercard',
      name: 'OCBC Rewards World Tiered Bonus',
      description: 'Tiered bonus points on shopping, dining, and e-commerce',
      enabled: true,
      priority: 10,
      conditions: [], // Base rule applies to all transactions
      reward: {
        calculationMethod: 'standard',
        baseMultiplier: 1,
        bonusMultiplier: 0, // Base rule has 0 bonus by default
        pointsRoundingStrategy: 'floor',
        amountRoundingStrategy: 'floor5',
        blockSize: 5,
        monthlyCap: 10000, // Shared cap across all tiers: 10,000 bonus points
        pointsCurrency: 'OCBC$',
        // Define multiple bonus tiers with different rates
        bonusTiers: [
          {
            name: 'Tier 1 - Selected Retail',
            priority: 1,
            multiplier: 14, // 28x points per $5 (base 2x + bonus 26x)
            condition: {
              type: 'compound',
              operation: 'any', // OR logic
              subConditions: [
                {
                  // Department store MCC
                  type: 'mcc',
                  operation: 'include',
                  values: ['5311']
                },
                {
                  // Watsons merchant name
                  type: 'merchant',
                  operation: 'include',
                  values: ['Watsons']
                }
              ]
            }
          },
          {
            name: 'Tier 2 - Shopping & Dining',
            priority: 2,
            multiplier: 9, // 18x points per $5 (base 2x + bonus 16x)
            condition: {
              type: 'mcc',
              operation: 'include',
              values: [
                '5309', '5611', '5621', '5641', '5651', '5655', '5661', '5691', 
                '5699', '5941', '5948'
              ]
            }
          }
        ]
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 7. Amex Platinum Credit Card Rule
   * Fixed rate: 2 MR points for every $1.60 spent
   */
  private createAmexPlatinumCreditCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'amex-platinum-credit-sg',
      name: 'Amex Platinum Credit Base Earning',
      description: '2 Membership Rewards points for every $1.60 spent',
      enabled: true,
      priority: 10,
      conditions: [], // Applies to all transactions
      reward: {
        calculationMethod: 'direct',
        baseMultiplier: 2,
        bonusMultiplier: 0, // No bonus multiplier
        pointsRoundingStrategy: 'nearest',
        amountRoundingStrategy: 'none',
        blockSize: 1.6, // 2 points per $1.6
        pointsCurrency: 'Membership Rewards Points'
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 8. Amex Platinum Singapore Card Rule
   * Fixed rate: 2 MR points for every $1.60 spent
   */
  private createAmexPlatinumSingaporeCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'amex-platinum-sg',
      name: 'Amex Platinum Singapore Base Earning',
      description: '2 Membership Rewards points for every $1.60 spent',
      enabled: true,
      priority: 10,
      conditions: [], // Applies to all transactions
      reward: {
        calculationMethod: 'direct',
        baseMultiplier: 1,
        bonusMultiplier: 0, // No bonus multiplier
        pointsRoundingStrategy: 'nearest',
        amountRoundingStrategy: 'none',
        blockSize: 1.6, // $1.60 per 2 points
        pointsCurrency: 'Membership Rewards Points'
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 9. Amex Platinum Canada Card Rule
   * - Base: 1 point per dollar for all transactions
   * - Bonus tiers with different multipliers for different categories
   */
  private createAmexPlatinumCanadaCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'amex-platinum-ca',
      name: 'Amex Platinum Canada Tiered Earning',
      description: 'Up to 3X MR points on travel and dining',
      enabled: true,
      priority: 10,
      conditions: [], // Base rule applies to all transactions
      reward: {
        calculationMethod: 'direct',
        baseMultiplier: 1,
        bonusMultiplier: 0, // Base rate is 1x, set in the calculation
        pointsRoundingStrategy: 'nearest',
        amountRoundingStrategy: 'none',
        blockSize: 1,
        pointsCurrency: 'Membership Rewards Points',
        // Multiple tiers with different rates
        bonusTiers: [
          {
            name: 'Amex Travel',
            priority: 1,
            multiplier: 2, // 3x total (1x base + 2x bonus)
            condition: {
              type: 'merchant',
              operation: 'include',
              values: ['Amex Travel']
            }
          },
          {
            name: 'Dining & Food Delivery in Canada',
            priority: 2,
            multiplier: 1, // 2x total (1x base + 1x bonus)
            condition: {
              type: 'compound',
              operation: 'all', // AND logic
              subConditions: [
                {
                  type: 'mcc',
                  operation: 'include',
                  values: [
                    '5811', '5812', '5813', '5814', // Restaurants and dining
                    '5499' // Food delivery
                  ]
                },
                {
                  type: 'currency',
                  operation: 'equals',
                  values: ['CAD']
                }
              ]
            }
          },
          {
            name: 'Travel',
            priority: 3,
            multiplier: 1, // 2x total (1x base + 1x bonus)
            condition: {
              type: 'mcc',
              operation: 'include',
              values: [
                // Airlines
                ...[...Array(200)].map((_, i) => `${3000 + i}`),
                // Hotels
                '7011',
                // Car rentals
                '7512',
                // Travel agencies
                '4722',
                // Transportation services
                '4111', '4112', '4121', '4131', '4411', '4457', '4468', '4789'
              ]
            }
          }
        ]
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 10. Amex Cobalt Card Rule
   * Multiple tiers with monthly spending caps per category
   */
  private createAmexCobaltCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'amex-cobalt',
      name: 'Amex Cobalt Tiered Earning',
      description: 'Up to 5X MR points on eats & drinks, 2-3X on other categories',
      enabled: true,
      priority: 10,
      conditions: [], // Base rule applies to all transactions
      reward: {
        calculationMethod: 'direct',
        baseMultiplier: 1,
        bonusMultiplier: 0, // Base rate is 1x, set in the calculation
        pointsRoundingStrategy: 'nearest',
        amountRoundingStrategy: 'none',
        blockSize: 1,
        pointsCurrency: 'Membership Rewards Points',
        // Multiple tiers with different rates
        bonusTiers: [
          {
            name: 'Dining & Grocery',
            priority: 1,
            multiplier: 4, // 5x total (1x base + 4x bonus)
            condition: {
              type: 'mcc',
              operation: 'include',
              values: [
                '5811', '5812', '5814', // Restaurants
                '5411' // Grocery stores
              ]
            }
          },
          {
            name: 'Food Delivery',
            priority: 1,
            multiplier: 4, // 5x total (1x base + 4x bonus)
            condition: {
              type: 'mcc',
              operation: 'include',
              values: ['5499'] // Food delivery
            }
          },
          {
            name: 'Streaming Services',
            priority: 2,
            multiplier: 2, // 3x total (1x base + 2x bonus)
            condition: {
              type: 'merchant',
              operation: 'include',
              values: [
                'Apple TV+', 'Apple Music', 'Crave', 'Disney+', 'fuboTV',
                'hayu', 'Netflix', 'RDS', 'SiriusXM Canada', 'Spotify', 'TSN'
              ]
            }
          },
          {
            name: 'Travel & Transit',
            priority: 3,
            multiplier: 1, // 2x total (1x base + 1x bonus)
            condition: {
              type: 'compound',
              operation: 'any', // OR logic
              subConditions: [
                {
                  type: 'mcc',
                  operation: 'include',
                  values: [
                    // Airlines (first 300 codes for brevity)
                    ...[...Array(300)].map((_, i) => `${3000 + i}`),
                    // Hotels
                    '7011',
                    // Car rentals
                    '7512',
                    // Travel agencies
                    '4722'
                  ]
                },
                {
                  type: 'mcc',
                  operation: 'include',
                  values: [
                    '4111', '4121', '4789', // Local transit, taxis, transportation
                    '7299', '5734', '4214'  // Other services (ride-sharing apps)
                  ]
                },
                {
                  type: 'mcc',
                  operation: 'include',
                  values: [
                    '5541', '5542' // Gas stations
                  ]
                }
              ]
            }
          }
        ]
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * 11. TD Aeroplan Visa Infinite Card Rule
   * 1.5X Aeroplan points on gas, grocery, and Air Canada purchases
   */
  private createTDAeroplanVisaInfiniteCardRule(): RewardRule {
    return {
      id: uuidv4(),
      cardTypeId: 'td-aeroplan-visa-infinite',
      name: 'TD Aeroplan Visa Infinite 1.5X',
      description: '1.5X Aeroplan points on gas, grocery, and Air Canada purchases',
      enabled: true,
      priority: 10,
      conditions: [
        {
          type: 'compound',
          operation: 'any', // OR logic
          subConditions: [
            // Gas stations
            {
              type: 'mcc',
              operation: 'include',
              values: ['5541', '5542'] // Gas stations
            },
            // Grocery stores
            {
              type: 'mcc',
              operation: 'include',
              values: ['5411', '5422', '5441', '5451', '5462'] // Grocery stores
            },
            // Air Canada purchases
            {
              type: 'merchant',
              operation: 'include',
              values: ['Air Canada']
            }
          ]
        }
      ],
      reward: {
        calculationMethod: 'direct',
        baseMultiplier: 1,
        bonusMultiplier: 0.5, // 0.5x bonus points (1x base + 0.5x bonus = 1.5x total)
        pointsRoundingStrategy: 'nearest',
        amountRoundingStrategy: 'nearest',
        blockSize: 1,
        pointsCurrency: 'Aeroplan Points'
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
}

// Export a singleton instance
export const cardRegistry = CardRegistry.getInstance();

================
File: services/rewards/index.ts
================
// services/rewards/index.ts
import { Transaction, PaymentMethod } from '@/types';
import {
  CalculationInput,
  CalculationResult,
  RewardRule,
  TransactionType
} from './types';
import { RuleEngine } from './RuleEngine';
import { RuleRepository } from './RuleRepository';
import { CardRegistry } from './CardRegistry';
import { MonthlySpendingTracker } from './MonthlySpendingTracker';
import { rewardService } from './RewardCalculatorService';

/**
 * Initialize the reward system with read-only mode for expense submission
 * This ensures we don't accidentally modify rules during expense operations
 */
export const initializeRewardSystem = async (readOnly: boolean = false): Promise<void> => {
  try {
    console.log(`Initializing reward system (read-only: ${readOnly})`);
    // Set read-only mode on the repository
    const ruleRepository = RuleRepository.getInstance();
    ruleRepository.setReadOnly(readOnly);
    
    // Initialize the reward service
    await rewardService.initialize();
    console.log('Reward system initialized successfully');
  } catch (error) {
    console.error('Failed to initialize reward system:', error);
    throw error;
  }
};

/**
 * Calculate reward points for a transaction
 */
export async function calculateRewardPoints(transaction: Transaction): Promise<CalculationResult> {
  return rewardService.calculatePoints(transaction, 0);
}

/**
 * Simulate reward points for a transaction in the expense form
 * This is a READ-ONLY operation and should never modify rules
 */
export async function simulateRewardPoints(
  amount: number,
  currency: string,
  paymentMethod: PaymentMethod,
  mcc?: string,
  merchantName?: string,
  isOnline?: boolean,
  isContactless?: boolean
): Promise<CalculationResult> {
  return rewardService.simulatePoints(
    amount,
    currency,
    paymentMethod,
    mcc,
    merchantName,
    isOnline,
    isContactless
  );
}

// Format reward points message
export function formatRewardPointsMessage(
  points: number,
  bonusPoints: number = 0,
  remainingMonthlyBonusPoints?: number
): string | undefined {
  if (bonusPoints === 0 && remainingMonthlyBonusPoints === 0) {
    return "Monthly bonus points cap reached";
  } else if (bonusPoints === 0) {
    return "Not eligible for bonus points";
  } else if (bonusPoints > 0) {
    return `Earning ${bonusPoints} bonus points`;
  } else if (remainingMonthlyBonusPoints !== undefined) {
    return `${remainingMonthlyBonusPoints.toLocaleString()} bonus points remaining this month`;
  }
  return undefined;
}

// Re-export the types for easier access
export * from './types';

// Re-export the singleton instances
export { rewardService };
export { RuleRepository, CardRegistry, MonthlySpendingTracker };

================
File: services/rewards/MonthlySpendingTracker.ts
================
// services/rewards/MonthlySpendingTracker.ts

import { PaymentMethod, Transaction } from '@/types';
import { supabase } from '@/integrations/supabase/client';
import { SpendingPeriodType } from './types';

/**
 * Service for tracking monthly spending for reward rules
 */
export class MonthlySpendingTracker {
  private static instance: MonthlySpendingTracker;
  private spendingCache: Map<string, number> = new Map();
  
  private constructor() {}
  
  /**
   * Get singleton instance
   */
  public static getInstance(): MonthlySpendingTracker {
    if (!MonthlySpendingTracker.instance) {
      MonthlySpendingTracker.instance = new MonthlySpendingTracker();
    }
    return MonthlySpendingTracker.instance;
  }
  
  /**
   * Get total monthly spending for a payment method
   */
  public async getMonthlySpending(
    paymentMethodId: string,
    periodType: SpendingPeriodType = 'calendar_month',
    date: Date = new Date(),
    statementDay: number = 1
  ): Promise<number> {
    // Create a cache key
    const cacheKey = this.createCacheKey(paymentMethodId, periodType, date, statementDay);
    
    // Check cache first
    if (this.spendingCache.has(cacheKey)) {
      return this.spendingCache.get(cacheKey) || 0;
    }
    
    try {
      // Calculate date range
      const { startDate, endDate } = this.calculateDateRange(date, periodType, statementDay);
      
      // Query database for transactions in this period
      const { data, error } = await supabase
        .from('transactions')
        .select('amount')
        .eq('payment_method_id', paymentMethodId)
        .gte('date', startDate.toISOString())
        .lt('date', endDate.toISOString())
        .eq('is_deleted', false);
        
      if (error) {
        console.error('Error fetching monthly spending:', error);
        return 0;
      }
      
      // Calculate total
      const totalSpending = data.reduce((sum, tx) => sum + (tx.amount || 0), 0);
      
      // Cache the result
      this.spendingCache.set(cacheKey, totalSpending);
      
      return totalSpending;
    } catch (error) {
      console.error('Error calculating monthly spending:', error);
      return 0;
    }
  }
  
  /**
   * Calculate monthly spending from an array of transactions
   * Useful when we don't have direct database access
   */
  public calculateMonthlySpendingFromTransactions(
    transactions: Transaction[],
    paymentMethodId: string,
    periodType: SpendingPeriodType = 'calendar_month',
    date: Date = new Date(),
    statementDay: number = 1
  ): number {
    try {
      // Calculate date range
      const { startDate, endDate } = this.calculateDateRange(date, periodType, statementDay);
      
      // Filter transactions by date range and payment method
      const relevantTransactions = transactions.filter(tx => {
        const txDate = new Date(tx.date);
        return tx.paymentMethod.id === paymentMethodId &&
               txDate >= startDate &&
               txDate < endDate;
      });
      
      // Calculate total
      return relevantTransactions.reduce((sum, tx) => sum + tx.amount, 0);
    } catch (error) {
      console.error('Error calculating monthly spending from transactions:', error);
      return 0;
    }
  }
  
  /**
   * Update monthly spending when a new transaction is added
   */
  public updateMonthlySpending(transaction: Transaction): void {
    // Clear all cache entries for this payment method
    // This is a simple approach - in a real implementation, you might
    // want to be more selective about which cache entries to invalidate
    this.clearCacheForPaymentMethod(transaction.paymentMethod.id);
  }
  
  /**
   * Clear cache for a payment method
   */
  public clearCacheForPaymentMethod(paymentMethodId: string): void {
    const keysToDelete: string[] = [];
    
    // Find all cache keys for this payment method
    for (const key of this.spendingCache.keys()) {
      if (key.startsWith(`${paymentMethodId}-`)) {
        keysToDelete.push(key);
      }
    }
    
    // Delete from cache
    keysToDelete.forEach(key => this.spendingCache.delete(key));
  }
  
  /**
   * Clear all cache
   */
  public clearCache(): void {
    this.spendingCache.clear();
  }
  
  /**
   * Create a cache key
   */
  private createCacheKey(
    paymentMethodId: string,
    periodType: SpendingPeriodType,
    date: Date,
    statementDay: number
  ): string {
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    return `${paymentMethodId}-${periodType}-${year}-${month}-${statementDay}`;
  }
  
  /**
   * Calculate date range for a period
   */
  private calculateDateRange(
    date: Date,
    periodType: SpendingPeriodType,
    statementDay: number
  ): { startDate: Date; endDate: Date } {
    const year = date.getFullYear();
    const month = date.getMonth();
    
    if (periodType === 'calendar_month') {
      // Calendar month: 1st day of month to last day of month
      const startDate = new Date(year, month, 1);
      const endDate = new Date(year, month + 1, 1);
      
      return { startDate, endDate };
    } else {
      // Statement month: statementDay of month to statementDay of next month
      let startMonth = month;
      let startYear = year;
      
      // If the current date is before statement day, use previous month's statement day
      if (date.getDate() < statementDay) {
        startMonth = month - 1;
        if (startMonth < 0) {
          startMonth = 11; // December
          startYear = year - 1;
        }
      }
      
      const startDate = new Date(startYear, startMonth, statementDay);
      
      // End date is the next statement day
      let endMonth = startMonth + 1;
      let endYear = startYear;
      if (endMonth > 11) {
        endMonth = 0; // January
        endYear += 1;
      }
      
      const endDate = new Date(endYear, endMonth, statementDay);
      
      return { startDate, endDate };
    }
  }
}

// Export a singleton instance
export const monthlySpendingTracker = MonthlySpendingTracker.getInstance();

================
File: services/rewards/RewardCalculatorService.ts
================
// services/rewards/RewardCalculatorService.ts

import { Transaction, PaymentMethod } from '@/types';
import { 
  CalculationInput, 
  CalculationResult, 
  RewardRule,
  RuleCondition,
  TransactionType
} from './types';
import { v4 as uuidv4 } from 'uuid';
import { RuleEngine } from './RuleEngine';
import { RuleRepository } from './RuleRepository';
import { CardRegistry } from './CardRegistry';
import { MonthlySpendingTracker } from './MonthlySpendingTracker';

/**
 * Central service for all reward calculations
 */
export class RewardCalculatorService {
  private static instance: RewardCalculatorService;
  private ruleEngine: RuleEngine;
  private ruleRepository: RuleRepository;
  private cardRegistry: CardRegistry;
  private monthlySpendingTracker: MonthlySpendingTracker;
  private initialized = false;
  
  private constructor() {
    this.ruleEngine = new RuleEngine();
    this.ruleRepository = RuleRepository.getInstance();
    this.cardRegistry = CardRegistry.getInstance();
    this.monthlySpendingTracker = MonthlySpendingTracker.getInstance();
  }
  
  /**
   * Get singleton instance
   */
  public static getInstance(): RewardCalculatorService {
    if (!RewardCalculatorService.instance) {
      RewardCalculatorService.instance = new RewardCalculatorService();
    }
    return RewardCalculatorService.instance;
  }
  
  /**
   * Initialize service by loading all rules
   */
  public async initialize(): Promise<void> {
    if (!this.initialized) {
      console.log('RewardCalculatorService: Initializing...');
      await this.ruleRepository.loadRules();
      this.initialized = true;
      console.log('RewardCalculatorService: Initialized successfully');
    }
  }

  /**
   * Check if the service is initialized
   */
  public isInitialized(): boolean {
    return this.initialized;
  }
  
  /**
   * Calculate reward points for a transaction
   */
  public async calculatePoints(
    transaction: Transaction,
    usedBonusPoints: number = 0
  ): Promise<CalculationResult> {
    // Ensure the service is initialized
    if (!this.initialized) {
      await this.initialize();
    }
    
    // Create calculation input from transaction
    const input = await this.createCalculationInput(
      transaction,
      usedBonusPoints
    );
    
    // Get rules for this payment method - READ ONLY OPERATION
    const rules = await this.getRulesForPaymentMethod(transaction.paymentMethod);
    
    // Calculate rewards using the rule engine
    return this.ruleEngine.calculateRewards(input, rules);
  }
  
  /**
   * Simulate reward points for a hypothetical transaction
   * This is READ-ONLY and should never modify rules
   */
  public async simulatePoints(
    amount: number,
    currency: string,
    paymentMethod: PaymentMethod,
    mcc?: string,
    merchantName?: string,
    isOnline?: boolean,
    isContactless?: boolean,
    usedBonusPoints: number = 0
  ): Promise<CalculationResult> {
    // Ensure the service is initialized
    if (!this.initialized) {
      console.log('RewardCalculatorService: Initializing for simulation...');
      await this.initialize();
    }
    
    // Determine transaction type from isOnline and isContactless
    let transactionType: TransactionType;
    if (isOnline) {
      transactionType = TransactionType.ONLINE;
    } else if (isContactless) {
      transactionType = TransactionType.CONTACTLESS;
    } else {
      transactionType = TransactionType.IN_STORE;
    }
    
    // Get monthly spending for minimum spend threshold
    const monthlySpend = await this.monthlySpendingTracker.getMonthlySpending(
      paymentMethod.id,
      'calendar_month',
      new Date(),
      paymentMethod.statementStartDay
    );
    
    // Create calculation input
    const input: CalculationInput = {
      amount,
      currency,
      mcc,
      merchantName,
      transactionType,
      usedBonusPoints,
      monthlySpend,
      paymentMethod,
      date: new Date(),
      statementDay: paymentMethod.statementStartDay
    };
    
    console.log('RewardCalculatorService: Simulation input:', {
      amount,
      currency,
      mcc,
      merchantName,
      transactionType,
      paymentMethod: paymentMethod.id
    });
    
    // Get rules for this payment method - READ ONLY OPERATION
    const rules = await this.getRulesForPaymentMethod(paymentMethod);
    console.log(`RewardCalculatorService: Loaded ${rules.length} rules for simulation`);
    
    // Calculate rewards using the rule engine
    return this.ruleEngine.calculateRewards(input, rules);
  }
  
  /**
   * Get point currency for a payment method
   */
  public getPointsCurrency(paymentMethod: PaymentMethod): string {
    // Try to get from card registry first
    const cardType = this.cardRegistry.getCardTypeByIssuerAndName(
      paymentMethod.issuer || '',
      paymentMethod.name || ''
    );
    
    if (cardType) {
      return cardType.pointsCurrency;
    }
    
    // Fallback to payment method properties
    if (paymentMethod.issuer) {
      return `${paymentMethod.issuer} Points`;
    }
    
    return 'Points';
  }
  
  /**
   * Create calculation input from transaction
   */
  private async createCalculationInput(
    transaction: Transaction,
    usedBonusPoints: number
  ): Promise<CalculationInput> {
    // Determine transaction type
    let transactionType: TransactionType;
    if (transaction.merchant?.isOnline) {
      transactionType = TransactionType.ONLINE;
    } else if (transaction.isContactless) {
      transactionType = TransactionType.CONTACTLESS;
    } else {
      transactionType = TransactionType.IN_STORE;
    }
    
    // Get monthly spending for minimum spend threshold
    const monthlySpend = await this.monthlySpendingTracker.getMonthlySpending(
      transaction.paymentMethod.id,
      'calendar_month',
      new Date(transaction.date),
      transaction.paymentMethod.statementStartDay
    );
    
    // Create input object
    return {
      amount: transaction.amount,
      currency: transaction.currency,
      mcc: transaction.merchant?.mcc?.code,
      merchantName: transaction.merchant?.name,
      transactionType,
      usedBonusPoints,
      monthlySpend,
      paymentMethod: transaction.paymentMethod,
      date: new Date(transaction.date),
      statementDay: transaction.paymentMethod.statementStartDay
    };
  }
  
  /**
   * Get rules for a payment method - READ ONLY OPERATION
   * This should never modify any rules
   */
  private async getRulesForPaymentMethod(paymentMethod: PaymentMethod): Promise<RewardRule[]> {
    // Try to get card type ID
    let cardTypeId: string | undefined;
    
    if (paymentMethod.issuer && paymentMethod.name) {
      const cardType = this.cardRegistry.getCardTypeByIssuerAndName(
        paymentMethod.issuer,
        paymentMethod.name
      );
      
      if (cardType) {
        cardTypeId = cardType.id;
      } else {
        // Fallback to a normalized ID
        cardTypeId = `${paymentMethod.issuer.toLowerCase()}-${paymentMethod.name.toLowerCase().replace(/\s+/g, '-')}`;
      }
    } else {
      // Use payment method ID as fallback
      cardTypeId = paymentMethod.id;
    }
    
    console.log(`RewardCalculatorService: Getting rules for card type ${cardTypeId}`);
    
    // Get rules for this card type from reward_rules table - READ ONLY
    const rules = await this.ruleRepository.getRulesForCardType(cardTypeId);
    console.log(`RewardCalculatorService: Found ${rules.length} rules in database for ${cardTypeId}`);
    
    // If no rules found, but we have legacy rules, do NOT save them to database from here
    // This is a READ-ONLY operation
    if (rules.length === 0 && paymentMethod.rewardRules && paymentMethod.rewardRules.length > 0) {
      console.log(`RewardCalculatorService: Using ${paymentMethod.rewardRules.length} legacy rules from payment method`);
      return paymentMethod.rewardRules.map(legacyRule => 
        this.convertLegacyRule(legacyRule, cardTypeId || 'unknown')
      );
    }
    
    // If no rules found, use default rules from card registry as fallback
    if (rules.length === 0) {
      console.log(`RewardCalculatorService: No rules found in database, trying card registry`);
      const cardType = this.cardRegistry.getCardTypeByIssuerAndName(
        paymentMethod.issuer || '',
        paymentMethod.name || ''
      );
      
      if (cardType && cardType.defaultRules && cardType.defaultRules.length > 0) {
        console.log(`RewardCalculatorService: Using ${cardType.defaultRules.length} default rules from card registry`);
        return cardType.defaultRules;
      } else {
        console.log('RewardCalculatorService: No default rules found in card registry');
      }
    }
    
    // Handle category selection for cards with selectable categories
    if (paymentMethod.selectedCategories && paymentMethod.selectedCategories.length > 0) {
      return this.applySelectedCategories(rules, paymentMethod.selectedCategories);
    }
    
    return rules;
  }
  
  /**
   * Convert a legacy rule to the new format
   * This is used when no rules are found in the database but legacy rules exist
   */
  private convertLegacyRule(legacyRule: any, cardTypeId: string): RewardRule {
    const now = new Date();
    return {
      id: legacyRule.id || crypto.randomUUID(),
      cardTypeId,
      name: legacyRule.name || 'Legacy Rule',
      description: legacyRule.description || '',
      enabled: true,
      priority: legacyRule.priority || 10,
      conditions: this.convertLegacyConditions(legacyRule),
      reward: {
        calculationMethod: 'standard',
        baseMultiplier: legacyRule.baseMultiplier || 1,
        bonusMultiplier: legacyRule.bonusMultiplier || 0,
        pointsRoundingStrategy: 'floor',
        amountRoundingStrategy: 'floor',
        blockSize: legacyRule.blockSize || 1,
        monthlyCap: legacyRule.monthlyCap,
        pointsCurrency: legacyRule.pointsCurrency || 'Points'
      },
      createdAt: now,
      updatedAt: now
    };
  }
  
  /**
   * Convert legacy conditions to the new format
   */
  private convertLegacyConditions(legacyRule: any): any[] {
    const conditions: any[] = [];
    
    if (legacyRule.conditionType === 'online') {
      conditions.push({
        type: 'transaction_type',
        operation: 'equals',
        values: [TransactionType.ONLINE]
      });
    } else if (legacyRule.conditionType === 'mcc') {
      conditions.push({
        type: 'mcc',
        operation: 'include',
        values: Array.isArray(legacyRule.mccCodes) ? legacyRule.mccCodes : []
      });
    }
    
    return conditions;
  }
  
  /**
   * Apply selected categories to rules
   */
  private applySelectedCategories(rules: RewardRule[], selectedCategories: string[]): RewardRule[] {
    return rules.map(rule => {
      // Create a deep copy of the rule
      const updatedRule = JSON.parse(JSON.stringify(rule));
      
      // Update conditions that have a category type
      updatedRule.conditions = rule.conditions.map((condition: RuleCondition) => {
        if (condition.type === 'category') {
          return {
            ...condition,
            values: selectedCategories
          };
        }
        return condition;
      });
      
      return updatedRule;
    });
  }
}

// Export a singleton instance
export const rewardService = RewardCalculatorService.getInstance();

================
File: services/rewards/RuleEngine.ts
================
// services/rewards/RuleEngine.ts

import { 
  CalculationInput, 
  CalculationResult, 
  RewardRule, 
  RuleCondition,
  RoundingStrategy,
  TransactionType,
  SpendingPeriodType,
  BonusTier
} from './types';

export class RuleEngine {
  /**
   * Calculate reward points for a given input based on rules
   */
  public calculateRewards(input: CalculationInput, rules: RewardRule[]): CalculationResult {
    // Filter for enabled rules only
    const enabledRules = rules.filter(rule => rule.enabled);
    
    // Sort by priority (highest first)
    enabledRules.sort((a, b) => b.priority - a.priority);
    
    // Find applicable rules
    const applicableRules = enabledRules.filter(rule => 
      this.evaluateConditions(rule.conditions, input)
    );
    
    // If no rules apply, return default calculation
    if (applicableRules.length === 0) {
      return {
        totalPoints: Math.round(input.amount),
        basePoints: Math.round(input.amount),
        bonusPoints: 0,
        pointsCurrency: input.paymentMethod.issuer ? `${input.paymentMethod.issuer} Points` : 'Points',
        minSpendMet: false,
        messages: ['No specific reward rules applied']
      };
    }
    
    // Use the highest priority matching rule
    const rule = applicableRules[0];
    
    // Check if minimum monthly spend threshold is met
    const minSpendMet = this.isMinimumSpendMet(rule, input);
    
    // Find the applicable bonus tier if any exist
    let appliedTier: BonusTier | undefined;
    let effectiveMultiplier = rule.reward.bonusMultiplier;

    if (rule.reward.bonusTiers && rule.reward.bonusTiers.length > 0 && minSpendMet) {
      // Filter tiers that match the input
      const matchingTiers = rule.reward.bonusTiers
        .filter(tier => {
          // Check if the tier has a compound condition
          if (tier.condition.type === 'compound') {
            return this.evaluateCondition(tier.condition, input);
          } else {
            // Single condition
            return this.evaluateCondition(tier.condition, input);
          }
        })
        .sort((a, b) => b.priority - a.priority); // Sort by priority (highest first)
      
      // If we have a matching tier, use its multiplier
      if (matchingTiers.length > 0) {
        appliedTier = matchingTiers[0];
        effectiveMultiplier = appliedTier.multiplier;
      }
    }
    
    // Calculate points based on rule's calculation method
    let basePoints: number, bonusPoints: number;
    
    if (rule.reward.calculationMethod === 'standard') {
      // Standard method:
      // 1. Round amount according to strategy
      // 2. Divide by block size
      // 3. Multiply by rates
      const roundedAmount = this.applyRounding(
        input.amount, 
        rule.reward.amountRoundingStrategy
      );
      
      // Calculate points per block
      const pointsPerBlock = roundedAmount / rule.reward.blockSize;
      
      // Apply base rate (always 1x)
      basePoints = this.applyRounding(
        pointsPerBlock * rule.reward.baseMultiplier, 
        rule.reward.pointsRoundingStrategy
      );
      
      // Only apply bonus rate if minimum spend threshold is met
      if (minSpendMet) {
        bonusPoints = this.applyRounding(
          pointsPerBlock * effectiveMultiplier,
          rule.reward.pointsRoundingStrategy
        );
      } else {
        bonusPoints = 0;
      }
    } else {
      // Direct method:
      // 1. Multiply amount by total rate (base=1 + bonus multiplier)
      // 2. Round the result
      
      // Base points calculation 
      basePoints = this.applyRounding(
        input.amount * rule.reward.baseMultiplier,
        rule.reward.pointsRoundingStrategy
      );
      
      // Only apply bonus if minimum spend threshold is met
      if (minSpendMet) {
        // Calculate total points with multiplier
        const totalPoints = this.applyRounding(
          input.amount * (rule.reward.baseMultiplier + effectiveMultiplier),
          rule.reward.pointsRoundingStrategy
        );
        
        // Bonus is the difference between total and base
        bonusPoints = totalPoints - basePoints;
      } else {
        bonusPoints = 0;
      }
    }
    
    // Apply monthly cap if specified
    let actualBonusPoints = bonusPoints;
    let remainingMonthlyBonusPoints;
    
    if (rule.reward.monthlyCap && rule.reward.monthlyCap > 0 && minSpendMet) {
      const usedBonusPoints = input.usedBonusPoints || 0;
      
      // Check if already reached the cap
      if (usedBonusPoints >= rule.reward.monthlyCap) {
        actualBonusPoints = 0;
        remainingMonthlyBonusPoints = 0;
      } else {
        // Check if this would exceed the cap
        const remainingCap = rule.reward.monthlyCap - usedBonusPoints;
        if (bonusPoints > remainingCap) {
          actualBonusPoints = remainingCap;
          remainingMonthlyBonusPoints = 0;
        } else {
          remainingMonthlyBonusPoints = remainingCap - bonusPoints;
        }
      }
    }
    
    // Create messages
    const messages: string[] = [];
    
    if (!minSpendMet && rule.reward.monthlyMinSpend) {
      messages.push(`Minimum monthly spend of ${rule.reward.monthlyMinSpend} not met for bonus points`);
    } else if (bonusPoints > 0 && actualBonusPoints === 0) {
      messages.push('Monthly bonus points cap reached');
    } else if (appliedTier) {
      messages.push(`Applied tier: ${appliedTier.name} (${effectiveMultiplier}x)`);
    } else if (rule.description) {
      messages.push(`Applied rule: ${rule.description}`);
    }
    
    // Return the result
    return {
      totalPoints: basePoints + actualBonusPoints,
      basePoints,
      bonusPoints: actualBonusPoints,
      pointsCurrency: rule.reward.pointsCurrency,
      remainingMonthlyBonusPoints,
      minSpendMet,
      appliedRule: rule,
      appliedTier,
      messages
    };
  }
  
  /**
   * Check if minimum monthly spend threshold is met
   */
  private isMinimumSpendMet(rule: RewardRule, input: CalculationInput): boolean {
    // If no minimum spend requirement, always return true
    if (!rule.reward.monthlyMinSpend || rule.reward.monthlyMinSpend <= 0) {
      return true;
    }
    
    // If monthly spend data is not provided, assume threshold is not met
    if (!input.monthlySpend) {
      return false;
    }
    
    // Check if spend meets or exceeds threshold
    return input.monthlySpend >= rule.reward.monthlyMinSpend;
  }
  
  /**
   * Evaluate if all conditions in a rule apply to the input
   */
  private evaluateConditions(conditions: RuleCondition[], input: CalculationInput): boolean {
    // If no conditions, the rule applies
    if (!conditions || conditions.length === 0) {
      return true;
    }
    
    // All conditions must be satisfied (AND logic)
    for (const condition of conditions) {
      if (!this.evaluateCondition(condition, input)) {
        return false;
      }
    }
    
    return true;
  }
  
  /**
   * Evaluate a single condition
   */
  public evaluateCondition(condition: RuleCondition, input: CalculationInput): boolean {
    // For compound conditions
    if (condition.type === 'compound') {
      if (!condition.subConditions || condition.subConditions.length === 0) {
        return true;
      }
      
      if (condition.operation === 'all') {
        // AND logic - all must be true
        return condition.subConditions.every(subCondition => 
          this.evaluateCondition(subCondition, input)
        );
      } else if (condition.operation === 'any') {
        // OR logic - any can be true
        return condition.subConditions.some(subCondition => 
          this.evaluateCondition(subCondition, input)
        );
      }
      
      return false;
    }
    
    // Handle specific condition types
    switch (condition.type) {
      case 'mcc':
        return this.evaluateMccCondition(condition, input);
      
      case 'merchant':
        return this.evaluateMerchantCondition(condition, input);
      
      case 'transaction_type':
        return this.evaluateTransactionTypeCondition(condition, input);
      
      case 'currency':
        return this.evaluateCurrencyCondition(condition, input);
      
      case 'amount':
        return this.evaluateAmountCondition(condition, input);
      
      case 'date':
        return this.evaluateDateCondition(condition, input);
      
      case 'category':
        return this.evaluateCategoryCondition(condition, input);
      
      case 'spend_threshold':
        return this.evaluateSpendThresholdCondition(condition, input);
      
      default:
        return false;
    }
  }
  
  /**
   * Evaluate MCC code condition
   */
  private evaluateMccCondition(condition: RuleCondition, input: CalculationInput): boolean {
    if (!input.mcc || !condition.values) {
      return false;
    }
    
    if (condition.operation === 'include') {
      return (condition.values as string[]).includes(input.mcc);
    } else if (condition.operation === 'exclude') {
      return !(condition.values as string[]).includes(input.mcc);
    }
    
    return false;
  }
  
  /**
   * Evaluate merchant name condition
   */
  private evaluateMerchantCondition(condition: RuleCondition, input: CalculationInput): boolean {
    if (!input.merchantName || !condition.values) {
      return false;
    }
    
    const merchantNameLower = input.merchantName.toLowerCase();
    
    if (condition.operation === 'include') {
      return (condition.values as string[]).some(name => 
        merchantNameLower.includes(name.toLowerCase())
      );
    } else if (condition.operation === 'exclude') {
      return !(condition.values as string[]).some(name => 
        merchantNameLower.includes(name.toLowerCase())
      );
    } else if (condition.operation === 'equals') {
      return (condition.values as string[]).some(name => 
        merchantNameLower === name.toLowerCase()
      );
    }
    
    return false;
  }
  
  /**
   * Evaluate transaction type condition (online/contactless/in-store)
   */
  private evaluateTransactionTypeCondition(condition: RuleCondition, input: CalculationInput): boolean {
    if (!condition.values) {
      return false;
    }
    
    if (condition.operation === 'equals') {
      return (condition.values as TransactionType[]).includes(input.transactionType);
    } else if (condition.operation === 'not_equals') {
      return !(condition.values as TransactionType[]).includes(input.transactionType);
    }
    
    return false;
  }
  
  /**
   * Evaluate currency condition
   */
  private evaluateCurrencyCondition(condition: RuleCondition, input: CalculationInput): boolean {
    if (!condition.values) {
      return false;
    }
    
    if (condition.operation === 'include') {
      return (condition.values as string[]).includes(input.currency);
    } else if (condition.operation === 'exclude') {
      return !(condition.values as string[]).includes(input.currency);
    } else if (condition.operation === 'equals') {
      return input.currency === condition.values[0];
    } else if (condition.operation === 'not_equals') {
      return input.currency !== condition.values[0];
    }
    
    return false;
  }
  
  /**
   * Evaluate amount condition
   */
  private evaluateAmountCondition(condition: RuleCondition, input: CalculationInput): boolean {
    if (!condition.values) {
      return false;
    }
    
    const amount = input.amount;
    
    if (condition.operation === 'greater_than') {
      return amount > (condition.values[0] as number);
    } else if (condition.operation === 'less_than') {
      return amount < (condition.values[0] as number);
    } else if (condition.operation === 'between') {
      return amount >= (condition.values[0] as number) && 
             amount <= (condition.values[1] as number);
    } else if (condition.operation === 'equals') {
      return amount === (condition.values[0] as number);
    }
    
    return false;
  }
  
  /**
   * Evaluate date condition
   */
  private evaluateDateCondition(condition: RuleCondition, input: CalculationInput): boolean {
    if (!condition.values || !input.date) {
      return false;
    }
    
    // Implementation depends on your needs
    return true;
  }
  
  /**
   * Evaluate category condition
   */
  private evaluateCategoryCondition(condition: RuleCondition, input: CalculationInput): boolean {
    if (!input.category || !condition.values) {
      return false;
    }
    
    if (condition.operation === 'include') {
      return (condition.values as string[]).includes(input.category);
    } else if (condition.operation === 'exclude') {
      return !(condition.values as string[]).includes(input.category);
    } else if (condition.operation === 'equals') {
      return input.category === condition.values[0];
    }
    
    return false;
  }
  
  /**
   * Evaluate spend threshold condition
   */
  private evaluateSpendThresholdCondition(condition: RuleCondition, input: CalculationInput): boolean {
    if (!condition.values || !input.monthlySpend) {
      return false;
    }
    
    const monthlySpend = input.monthlySpend;
    
    if (condition.operation === 'greater_than') {
      return monthlySpend > (condition.values[0] as number);
    } else if (condition.operation === 'less_than') {
      return monthlySpend < (condition.values[0] as number);
    } else if (condition.operation === 'between') {
      return monthlySpend >= (condition.values[0] as number) && 
             monthlySpend <= (condition.values[1] as number);
    } else if (condition.operation === 'equals') {
      return monthlySpend === (condition.values[0] as number);
    }
    
    return false;
  }
  
  /**
   * Apply rounding strategy to a number
   */
  private applyRounding(value: number, strategy: RoundingStrategy): number {
    switch (strategy) {
      case 'floor':
        return Math.floor(value);
      
      case 'ceiling':
        return Math.ceil(value);
      
      case 'nearest':
        return Math.round(value);
      
      case 'floor5':
        return Math.floor(value / 5) * 5;
      
      case 'none':
      default:
        return value;
    }
  }
}

================
File: services/rewards/RuleRepository.ts
================
// services/rewards/RuleRepository.ts

import { RewardRule, BonusTier } from './types';
import { supabase } from '@/integrations/supabase/client';

/**
 * Repository for storing and retrieving reward rules
 */
export class RuleRepository {
  private static instance: RuleRepository;
  private rules: Map<string, RewardRule> = new Map();
  private rulesByCardType: Map<string, RewardRule[]> = new Map();
  private lastRuleLoadTime: number = 0;
  private CACHE_TTL = 5 * 60 * 1000; // 5 minutes cache
  private readonly = false; // Flag to control write operations
  
  private constructor() {}
  
  /**
   * Get singleton instance
   */
  public static getInstance(): RuleRepository {
    if (!RuleRepository.instance) {
      RuleRepository.instance = new RuleRepository();
    }
    return RuleRepository.instance;
  }

  /**
   * Set repository to read-only mode
   * This should be called when starting expense submission
   */
  public setReadOnly(readOnly: boolean): void {
    this.readonly = readOnly;
    console.log(`RuleRepository: Read-only mode ${readOnly ? 'enabled' : 'disabled'}`);
  }
  
  /**
   * Load all rules from the database
   */
  public async loadRules(): Promise<RewardRule[]> {
    try {
      console.log('RuleRepository: Loading all rules from database...');
      const { data, error } = await supabase
        .from('reward_rules')
        .select('*');
        
      if (error) {
        console.error('Error loading rules:', error);
        return [];
      }
      
      console.log(`RuleRepository: Loaded ${data.length} rules from database`);
      
      const rules: RewardRule[] = data.map(this.mapDbRuleToRewardRule);
      
      // Store rules in memory
      this.rules.clear();
      this.rulesByCardType.clear();
      this.lastRuleLoadTime = Date.now();
      
      rules.forEach(rule => {
        this.rules.set(rule.id, rule);
        
        // Group by card type
        if (!this.rulesByCardType.has(rule.cardTypeId)) {
          this.rulesByCardType.set(rule.cardTypeId, []);
        }
        
        this.rulesByCardType.get(rule.cardTypeId)?.push(rule);
      });
      
      return rules;
    } catch (error) {
      console.error('Error loading rules:', error);
      return [];
    }
  }
  
  /**
   * Get rules for a specific card type - READ ONLY operation
   * This is used during expense submission to calculate points
   */
  public async getRulesForCardType(cardTypeId: string): Promise<RewardRule[]> {
    // Check if cache is expired
    const isCacheExpired = Date.now() - this.lastRuleLoadTime > this.CACHE_TTL;
    
    // If cache is expired or we don't have rules for this card type, reload from database
    if (isCacheExpired || !this.rulesByCardType.has(cardTypeId)) {
      console.log('RuleRepository: Cache expired or no rules for card type, reloading...');
      await this.loadRules();
    }
    
    // Check cache first
    if (this.rulesByCardType.has(cardTypeId)) {
      return this.rulesByCardType.get(cardTypeId) || [];
    }
    
    try {
      // Query Supabase reward_rules table
      console.log(`RuleRepository: Querying database for rules with card_type_id=${cardTypeId}`);
      const { data, error } = await supabase
        .from('reward_rules')
        .select('*')
        .eq('card_type_id', cardTypeId)
        .eq('enabled', true);
        
      if (error) {
        console.error('Error loading rules for card type:', error);
        return [];
      }
      
      if (!data || data.length === 0) {
        console.log(`No rules found in Supabase for card type ${cardTypeId}`);
        return [];
      }
      
      console.log(`Loaded ${data.length} rules from Supabase for card type ${cardTypeId}`);
      
      const rules: RewardRule[] = data.map(this.mapDbRuleToRewardRule);
      
      // Cache results
      this.rulesByCardType.set(cardTypeId, rules);
      rules.forEach(rule => this.rules.set(rule.id, rule));
      
      return rules;
    } catch (error) {
      console.error('Error loading rules for card type:', error);
      return [];
    }
  }
  
  /**
   * Get a rule by ID - READ ONLY operation
   */
  public async getRule(id: string): Promise<RewardRule | null> {
    // Check cache first
    if (this.rules.has(id)) {
      return this.rules.get(id) || null;
    }
    
    try {
      console.log(`RuleRepository: Fetching rule with id=${id}`);
      const { data, error } = await supabase
        .from('reward_rules')
        .select('*')
        .eq('id', id)
        .single();
        
      if (error || !data) {
        console.error('Error loading rule:', error);
        return null;
      }
      
      const rule = this.mapDbRuleToRewardRule(data);
      
      // Cache the result
      this.rules.set(rule.id, rule);
      
      // Add to card type mapping
      if (!this.rulesByCardType.has(rule.cardTypeId)) {
        this.rulesByCardType.set(rule.cardTypeId, []);
      }
      this.rulesByCardType.get(rule.cardTypeId)?.push(rule);
      
      return rule;
    } catch (error) {
      console.error('Error loading rule:', error);
      return null;
    }
  }
  
  /**
   * Save a rule - ADMIN OPERATION
   * This should only be used in the reward rule editor, not during expense submission
   */
  public async saveRule(rule: RewardRule): Promise<RewardRule | null> {
    // Prevent modifications if in read-only mode
    if (this.readonly) {
      console.warn('RuleRepository: Cannot save rule in read-only mode');
      return null;
    }
    
    try {
      console.log('RuleRepository: Saving rule...', rule.id);
      const dbRule = this.mapRewardRuleToDbRule(rule);
      
      const { data, error } = await supabase
        .from('reward_rules')
        .upsert(dbRule)
        .select()
        .single();
        
      if (error) {
        console.error('Error saving rule:', error);
        return null;
      }
      
      const savedRule = this.mapDbRuleToRewardRule(data);
      
      // Update cache
      this.rules.set(savedRule.id, savedRule);
      
      // Update card type mapping
      if (!this.rulesByCardType.has(savedRule.cardTypeId)) {
        this.rulesByCardType.set(savedRule.cardTypeId, []);
      }
      
      const cardRules = this.rulesByCardType.get(savedRule.cardTypeId) || [];
      const existingIndex = cardRules.findIndex(r => r.id === savedRule.id);
      
      if (existingIndex >= 0) {
        cardRules[existingIndex] = savedRule;
      } else {
        cardRules.push(savedRule);
      }
      
      this.rulesByCardType.set(savedRule.cardTypeId, cardRules);
      
      return savedRule;
    } catch (error) {
      console.error('Error saving rule:', error);
      return null;
    }
  }
  
  /**
   * Delete a rule - ADMIN OPERATION
   * This should only be used in the reward rule editor, not during expense submission
   */
  public async deleteRule(id: string): Promise<boolean> {
    // Prevent modifications if in read-only mode
    if (this.readonly) {
      console.warn('RuleRepository: Cannot delete rule in read-only mode');
      return false;
    }
    
    try {
      console.log(`RuleRepository: Deleting rule with id=${id}`);
      const { error } = await supabase
        .from('reward_rules')
        .delete()
        .eq('id', id);
        
      if (error) {
        console.error('Error deleting rule:', error);
        return false;
      }
      
      // Get rule from cache to get its card type
      const rule = this.rules.get(id);
      
      // Remove from cache
      this.rules.delete(id);
      
      // Remove from card type mapping
      if (rule) {
        const cardRules = this.rulesByCardType.get(rule.cardTypeId) || [];
        this.rulesByCardType.set(
          rule.cardTypeId,
          cardRules.filter(r => r.id !== id)
        );
      }
      
      return true;
    } catch (error) {
      console.error('Error deleting rule:', error);
      return false;
    }
  }
  
  /**
   * Map database rule to RewardRule
   */
  private mapDbRuleToRewardRule(dbRule: any): RewardRule {
    // Parse JSON fields
    const conditions = typeof dbRule.conditions === 'string' ? 
      JSON.parse(dbRule.conditions) : dbRule.conditions || [];
    
    // Parse bonus tiers if present
    let bonusTiers: BonusTier[] | undefined;
    if (dbRule.bonus_tiers) {
      try {
        bonusTiers = typeof dbRule.bonus_tiers === 'string' ?
          JSON.parse(dbRule.bonus_tiers) : dbRule.bonus_tiers;
        
        // Make sure compound conditions are properly parsed
        if (bonusTiers) {
          bonusTiers = bonusTiers.map((tier: any) => {
            // If it's a compound condition, ensure subConditions are properly formatted
            if (tier.condition?.type === 'compound' && typeof tier.condition.subConditions === 'string') {
              tier.condition.subConditions = JSON.parse(tier.condition.subConditions);
            }
            return tier;
          });
        }
      } catch (e) {
        console.error('Error parsing bonus tiers:', e);
      }
    }
    
    return {
      id: dbRule.id,
      cardTypeId: dbRule.card_type_id,
      name: dbRule.name,
      description: dbRule.description || '',
      enabled: dbRule.enabled,
      priority: dbRule.priority || 0,
      conditions,
      reward: {
        calculationMethod: dbRule.calculation_method || 'standard',
        baseMultiplier: dbRule.base_multiplier || 0,
        bonusMultiplier: dbRule.bonus_multiplier || 0,
        pointsRoundingStrategy: dbRule.points_rounding_strategy || 'floor',
        amountRoundingStrategy: dbRule.amount_rounding_strategy || 'floor',
        blockSize: dbRule.block_size || 1,
        bonusTiers,
        monthlyCap: dbRule.monthly_cap,
        monthlyMinSpend: dbRule.monthly_min_spend,
        monthlySpendPeriodType: dbRule.monthly_spend_period_type,
        pointsCurrency: dbRule.points_currency || 'Points'
      },
      createdAt: new Date(dbRule.created_at),
      updatedAt: new Date(dbRule.updated_at || dbRule.created_at)
    };
  }
  
  /**
   * Map RewardRule to database rule
   */
  private mapRewardRuleToDbRule(rule: RewardRule): any {
    return {
      id: rule.id,
      card_type_id: rule.cardTypeId,
      name: rule.name,
      description: rule.description,
      enabled: rule.enabled,
      priority: rule.priority,
      conditions: JSON.stringify(rule.conditions),
      calculation_method: rule.reward.calculationMethod,
      base_multiplier: rule.reward.baseMultiplier,
      bonus_multiplier: rule.reward.bonusMultiplier,
      points_rounding_strategy: rule.reward.pointsRoundingStrategy,
      amount_rounding_strategy: rule.reward.amountRoundingStrategy,
      block_size: rule.reward.blockSize,
      bonus_tiers: rule.reward.bonusTiers ? JSON.stringify(rule.reward.bonusTiers) : null,
      monthly_cap: rule.reward.monthlyCap,
      monthly_min_spend: rule.reward.monthlyMinSpend,
      monthly_spend_period_type: rule.reward.monthlySpendPeriodType,
      points_currency: rule.reward.pointsCurrency,
      created_at: rule.createdAt.toISOString(),
      updated_at: rule.updatedAt.toISOString()
    };
  }
}

// Export a singleton instance
export const ruleRepository = RuleRepository.getInstance();

================
File: services/rewards/types.ts
================
// services/rewards/types.ts

import { PaymentMethod } from "@/types";

/**
 * Transaction type enum (mutually exclusive types)
 */
export enum TransactionType {
  ONLINE = 'online',
  CONTACTLESS = 'contactless',
  IN_STORE = 'in_store' // Neither online nor contactless
}

/**
 * Condition types supported by the rule engine
 */
export type ConditionType = 
  | 'mcc' 
  | 'merchant' 
  | 'transaction_type' // For online/contactless/in_store
  | 'currency'
  | 'amount'
  | 'date'
  | 'category'
  | 'spend_threshold' // For minimum monthly spend
  | 'compound';

/**
 * Condition interface - defines what makes a transaction eligible for a rule
 */
export interface RuleCondition {
  type: ConditionType;
  operation: 'include' | 'exclude' | 'equals' | 'not_equals' | 'greater_than' | 'less_than' | 'between' | 'any' | 'all';
  values?: string[] | number[] | boolean[] | TransactionType[];
  subConditions?: RuleCondition[]; // For compound conditions (AND/OR)
  field?: string; // For dynamic field conditions
}

/**
 * Reward calculation method
 */
export type CalculationMethod = 
  | 'standard'      // Amount is rounded first, then divided by blockSize, then multiplied by rate
  | 'direct';       // Amount is multiplied by rate first, then rounded

/**
 * Rounding strategy for amount and points
 */
export type RoundingStrategy = 
  | 'floor'     // Round down
  | 'ceiling'   // Round up
  | 'nearest'   // Round to nearest
  | 'floor5'    // Round down to nearest $5
  | 'none';     // No rounding

/**
 * Period type for minimum spend threshold
 */
export type SpendingPeriodType = 
  | 'statement_month'  // Based on card's statement cycle
  | 'calendar_month';  // Based on calendar month

/**
 * Bonus tier definition
 */
export interface BonusTier {
  name: string;
  multiplier: number;
  priority: number;
  // Modify the condition to support compound conditions
  condition: RuleCondition | {
    type: 'compound',
    operation: 'any' | 'all', // 'any' for OR logic, 'all' for AND logic
    subConditions: RuleCondition[]
  };
}

/**
 * Reward definition - defines how points are calculated
 */
export interface RuleReward {
  calculationMethod: CalculationMethod;
  baseMultiplier: number // Default base multiplier
  bonusMultiplier: number; // Default bonus multiplier
  pointsRoundingStrategy: RoundingStrategy; // How to round the calculated points
  amountRoundingStrategy: RoundingStrategy; // How to round the amount before calculation
  blockSize: number; // Amount per point block (usually 1 or 5)
  bonusTiers?: BonusTier[]; // Multiple bonus tiers with different multipliers
  monthlyCap?: number; // Maximum bonus points per month (shared across all tiers)
  monthlyMinSpend?: number; // Minimum spend required to activate bonus rate
  monthlySpendPeriodType?: SpendingPeriodType; // Whether minimum spend is per statement or calendar month
  pointsCurrency: string; // What kind of points this earns
}

/**
 * Complete rule definition
 */
export interface RewardRule {
  id: string;
  cardTypeId: string;
  name: string;
  description: string;
  enabled: boolean;
  priority: number; // Higher priority rules are applied first
  conditions: RuleCondition[];
  reward: RuleReward;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Input for rule engine calculation
 */
export interface CalculationInput {
  amount: number;
  currency: string;
  mcc?: string;
  merchantName?: string;
  transactionType: TransactionType; // Updated to use enum
  usedBonusPoints?: number;
  monthlySpend?: number; // Total eligible spend this month for threshold calculation
  paymentMethod: PaymentMethod;
  date: Date;
  category?: string;
  statementDay?: number; // Day of month when statement cycle starts
  [key: string]: any; // For extensibility
}

/**
 * Result of rule engine calculation
 */
export interface CalculationResult {
  totalPoints: number;
  basePoints: number;
  bonusPoints: number;
  pointsCurrency: string;
  remainingMonthlyBonusPoints?: number;
  minSpendMet: boolean; // Whether minimum spend threshold was met
  appliedRule?: RewardRule; // The rule that was applied
  appliedTier?: BonusTier; // The bonus tier that was applied (if any)
  messages: string[];
}

/**
 * Card type definition
 */
export interface CardType {
  id: string;
  issuer: string;
  name: string;
  defaultRules: RewardRule[];
  pointsCurrency: string;
  hasCategories?: boolean;
  availableCategories?: string[];
  maxCategoriesSelectable?: number;
  statementDay?: number; // Default statement cycle start day (1-31)
}

================
File: services/storage/index.ts
================
// Re-export all storage utilities for backward compatibility
export * from '@/utils/storage/index';
export * from '@/utils/storage/transactions/add';
export * from '@/utils/storage/transactions/edit';
export * from '@/utils/storage/transactions/delete';
export * from '@/utils/storage/merchantTracking';

// Storage service for managing local storage mode
export const storageService = {
  _useLocalStorage: false,
  
  // Get current storage mode
  isLocalStorageMode(): boolean {
    return this._useLocalStorage;
  },
  
  // Set storage mode
  setLocalStorageMode(useLocalStorage: boolean): void {
    this._useLocalStorage = useLocalStorage;
    console.log(`Storage mode set to ${useLocalStorage ? 'local storage' : 'Supabase'}`);
  }
};

================
File: types/index.ts
================
export interface MerchantCategoryCode {
  code: string;
  description: string;
}

export interface Coordinates {
  latitude: number;
  longitude: number;
}

export interface Merchant {
  id: string;
  name: string;
  address?: string;
  coordinates?: Coordinates;
  mcc?: MerchantCategoryCode;
  isOnline?: boolean;
}

export interface PaymentMethod {
  id: string;
  name: string;
  type: 'cash' | 'credit_card';
  currency: Currency;
  rewardRules: RewardRule[];
  statementStartDay?: number;
  isMonthlyStatement?: boolean;
  active: boolean;
  lastFourDigits?: string;
  issuer?: string;
  icon?: string;
  color?: string;
  imageUrl?: string;
  conversionRate?: Record<Currency, number>;
  selectedCategories?: string[];
}

export type Currency = 'SGD' | 'USD' | 'EUR' | 'GBP' | string;

export interface Transaction {
  id: string;
  amount: number;
  currency: Currency;
  merchant: Merchant;
  paymentMethod: PaymentMethod;
  paymentAmount: number;
  paymentCurrency: Currency;
  date: string; // Using string format for dates
  category?: string;
  notes?: string;
  isContactless: boolean;
  rewardPoints?: number;
  basePoints?: number;
  bonusPoints?: number;
  reimbursementAmount?: number;
  is_deleted?: boolean;
}

export interface FilterOption {
  label: string;
  value: string;
  checked: boolean;
}

// Import and re-export RewardRule and related types
import type { 
  RewardRule,
  RuleCondition,
  CalculationMethod,
  RoundingStrategy,
  SpendingPeriodType,
  BonusTier,
  CalculationInput,
  CalculationResult,
  TransactionType
} from '@/services/rewards/types';

// Re-export the types
export type {
  RewardRule,
  RuleCondition,
  CalculationMethod,
  RoundingStrategy,
  SpendingPeriodType,
  BonusTier,
  CalculationInput,
  CalculationResult,
  TransactionType
};

================
File: utils/storage/transactions/add.ts
================
import { Transaction } from '@/types';
import { supabase } from '@/integrations/supabase/client';
import { v4 as uuidv4 } from 'uuid';

export async function addTransaction(transactionData: Omit<Transaction, 'id'>): Promise<Transaction> {
  // Implementation of adding transaction to Supabase/local storage
  const id = uuidv4();
  const newTransaction: Transaction = {
    id,
    ...transactionData
  };
  
  // For demonstration purposes - this would actually insert to Supabase
  return newTransaction;
}

================
File: utils/storage/transactions/bonus-points.ts
================
import { supabase } from '@/integrations/supabase/client';
import { v4 as uuidv4 } from 'uuid';

// Define the interface for bonus points movement parameters
interface BonusPointsMovementParams {
  transactionId: string;
  paymentMethodId: string;
  bonusPoints: number;
}

/**
 * Gets all bonus points movements for a transaction
 */
export async function getBonusPointsMovements(transactionId: string) {
  try {
    // Query from bonus_points_movements table
    const { data, error } = await supabase
      .from('bonus_points_movements')
      .select('*')
      .eq('transaction_id', transactionId);
      
    if (error) {
      console.error('Error fetching bonus points movements:', error);
      return [];
    }
    
    return data || [];
  } catch (error) {
    console.error('Error fetching bonus points movements:', error);
    return [];
  }
}

/**
 * Adds a bonus points movement for a transaction
 */
export async function addBonusPointsMovement(
  params: BonusPointsMovementParams | string, 
  paymentMethodId?: string, 
  bonusPoints?: number
): Promise<boolean> {
  try {
    let transactionId: string;
    let actualPaymentMethodId: string;
    let actualBonusPoints: number;

    // Handle both object parameter and individual parameters
    if (typeof params === 'object') {
      // Object parameter format
      transactionId = params.transactionId;
      actualPaymentMethodId = params.paymentMethodId;
      actualBonusPoints = params.bonusPoints;
    } else {
      // Individual parameters format (legacy)
      transactionId = params;
      actualPaymentMethodId = paymentMethodId || '';
      actualBonusPoints = bonusPoints || 0;
    }

    if (!transactionId || !actualBonusPoints) {
      console.error('Invalid parameters for addBonusPointsMovement');
      return false;
    }
    
    // Check if transaction exists
    const { data: transaction, error: txError } = await supabase
      .from('transactions')
      .select('id')
      .eq('id', transactionId)
      .single();
      
    if (txError || !transaction) {
      console.error('Transaction not found:', txError);
      return false;
    }
    
    // Create bonus points movement
    const { error } = await supabase
      .from('bonus_points_movements')
      .insert({
        id: uuidv4(),
        transaction_id: transactionId,
        payment_method_id: actualPaymentMethodId,
        bonus_points: actualBonusPoints,
        created_at: new Date().toISOString()
      });
      
    if (error) {
      console.error('Error adding bonus points movement:', error);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error('Error adding bonus points movement:', error);
    return false;
  }
}

/**
 * Deletes bonus points movements for a transaction
 */
export async function deleteBonusPointsMovements(transactionId: string) {
  try {
    const { error } = await supabase
      .from('bonus_points_movements')
      .delete()
      .eq('transaction_id', transactionId);
      
    if (error) {
      console.error('Error deleting bonus points movements:', error);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error('Error deleting bonus points movements:', error);
    return false;
  }
}

/**
 * Updates the storage/export utility to include the function
 */
export async function updateBonusPointsForTransaction(
  transactionId: string, 
  paymentMethodId: string,
  bonusPoints: number
) {
  // Delete existing bonus points movements for this transaction
  await deleteBonusPointsMovements(transactionId);
  
  // Add new bonus points movement
  if (bonusPoints > 0) {
    return await addBonusPointsMovement({
      transactionId,
      paymentMethodId,
      bonusPoints
    });
  }
  
  return true;
}

================
File: utils/storage/transactions/delete.ts
================
export async function deleteTransaction(id: string): Promise<boolean> {
  // Implementation of deleting transaction
  return true;
}

================
File: utils/storage/transactions/edit.ts
================
import { Transaction } from '@/types';

export async function editTransaction(id: string, transactionData: Partial<Transaction>): Promise<Transaction> {
  // Implementation of editing transaction
  return {
    id,
    ...transactionData,
  } as Transaction;
}

================
File: utils/storage/transactions/export.ts
================
import { Transaction } from '@/types';

/**
 * Exports transactions to CSV format
 * @param transactions Array of transactions to export
 * @returns Promise that resolves to a CSV string
 */
export async function exportTransactionsToCSV(transactions: Transaction[]): Promise<string> {
  // Implementation of exporting transactions to CSV
  // For a basic implementation, let's return a CSV string with headers and data
  
  // Create headers
  const headers = [
    'Date',
    'Merchant',
    'Amount',
    'Currency',
    'Payment Method',
    'Category',
    'Points'
  ].join(',');
  
  // Create rows
  const rows = transactions.map(transaction => {
    return [
      transaction.date,
      `"${transaction.merchant.name.replace(/"/g, '""')}"`, // Escape quotes in merchant name
      transaction.amount,
      transaction.currency,
      `"${transaction.paymentMethod.name.replace(/"/g, '""')}"`,
      transaction.category || 'Uncategorized',
      transaction.rewardPoints || 0
    ].join(',');
  });
  
  // Combine headers and rows
  return [headers, ...rows].join('\n');
}

================
File: utils/storage/transactions/get.ts
================
import { Transaction } from '@/types';
import { storageService } from '@/services/storage';
import { supabase } from '@/integrations/supabase/client';

export async function getTransactions(useLocalStorage?: boolean): Promise<Transaction[]> {
  // If useLocalStorage parameter is provided, use it. Otherwise use the global setting
  const shouldUseLocalStorage = useLocalStorage !== undefined 
    ? useLocalStorage 
    : storageService.isLocalStorageMode();
  
  console.log(`Getting transactions with localStorage mode: ${shouldUseLocalStorage}`);
  
  if (shouldUseLocalStorage) {
    // Get transactions from local storage
    const storedTransactions = localStorage.getItem('transactions');
    if (storedTransactions) {
      return JSON.parse(storedTransactions) as Transaction[];
    }
    return [];
  } else {
    try {
      // Get transactions from Supabase
      const { data, error } = await supabase
        .from('transactions')
        .select(`
          id,
          date,
          amount,
          currency,
          payment_amount,
          payment_currency,
          reward_points,
          base_points,
          bonus_points,
          is_contactless,
          is_deleted,
          notes,
          reimbursement_amount,
          category,
          merchant_id,
          payment_method_id
        `)
        .eq('is_deleted', false);

      if (error) {
        console.error('Error fetching transactions:', error);
        return [];
      }

      // Now fetch payment methods and merchants to enrich transaction data
      const { data: paymentMethods } = await supabase.from('payment_methods').select('*');
      const { data: merchants } = await supabase.from('merchants').select('*');

      // Map data to Transaction type
      const transactions = data.map(item => {
        // Find the associated payment method
        const paymentMethod = paymentMethods?.find(pm => pm.id === item.payment_method_id);
        
        // Create a default payment method if none is found
        const processedPaymentMethod = {
          id: paymentMethod?.id || item.payment_method_id,
          name: paymentMethod?.name || 'Unknown',
          type: (paymentMethod?.type as 'credit_card' | 'cash') || 'credit_card',
          currency: paymentMethod?.currency || item.payment_currency || 'SGD',
          active: paymentMethod?.active !== false,
          issuer: paymentMethod?.issuer,
          lastFourDigits: paymentMethod?.last_four_digits,
          rewardRules: (paymentMethod?.reward_rules || []) as any[]
        };

        // Find the associated merchant
        const merchant = merchants?.find(m => m.id === item.merchant_id);
        
        // Process merchant data safely with optional chaining and nullish coalescing
        const processedMerchant = {
          id: merchant?.id || item.merchant_id,
          name: merchant?.name || 'Unknown Merchant',
          // Use optional properties with safe fallbacks
          address: merchant?.address || undefined,
          isOnline: merchant?.is_online || false,
          // Safely handle coordinates
          coordinates: merchant?.coordinates ? 
            (typeof merchant.coordinates === 'object' ? 
              merchant.coordinates as any : 
              undefined) : 
            undefined,
          // Safely handle MCC
          mcc: merchant?.mcc ? 
            (typeof merchant.mcc === 'object' ? 
              merchant.mcc as any : 
              undefined) : 
            undefined
        };

        return {
          id: item.id,
          date: item.date,
          merchant: processedMerchant,
          amount: Number(item.amount),
          currency: item.currency,
          paymentMethod: processedPaymentMethod,
          paymentAmount: Number(item.payment_amount || item.amount),
          paymentCurrency: item.payment_currency || item.currency,
          rewardPoints: item.reward_points || 0,
          basePoints: item.base_points || 0,
          bonusPoints: item.bonus_points || 0,
          isContactless: item.is_contactless || false,
          notes: item.notes || '',
          reimbursementAmount: item.reimbursement_amount ? Number(item.reimbursement_amount) : 0,
          category: item.category
        } as Transaction;
      });

      console.log(`Retrieved ${transactions.length} transactions from Supabase`);
      return transactions;
    } catch (error) {
      console.error('Error getting transactions:', error);
      return [];
    }
  }
}

================
File: utils/storage/transactions/local-storage.ts
================
import { Transaction } from '@/types';

export function getTransactionsFromLocalStorage(): Transaction[] {
  // Implementation of getting transactions from localStorage
  return [];
}

export function saveTransactionsToLocalStorage(transactions: Transaction[]): void {
  // Implementation of saving transactions to localStorage
}

================
File: utils/storage/transactions/save.ts
================
import { Transaction } from '@/types';

export async function saveTransactions(transactions: Transaction[]): Promise<boolean> {
  // Implementation of saving transactions
  return true;
}

================
File: utils/storage/fileUtils.ts
================
/**
 * Utility function to safely handle string promises in file operations
 * @param callback Function to be executed with the resolved string
 * @param stringPromise Promise that resolves to a string
 */
export async function withResolvedStringPromise(
  callback: (resolvedString: string) => Promise<void>,
  stringPromise: Promise<string>
): Promise<void> {
  try {
    const resolvedString = await stringPromise;
    await callback(resolvedString);
  } catch (error) {
    console.error('Error resolving string promise:', error);
  }
}

================
File: utils/storage/index.ts
================
// Export merchants and payment methods functions
export * from './merchants';
export * from './paymentMethods';
export * from './merchantTracking';
export * from './transactions';

// Export transaction-specific utilities
export * from './transactions/add';
export * from './transactions/delete';
export * from './transactions/edit';
export * from './transactions/get';
export * from './transactions/save';
export * from './transactions/export';
export * from './transactions/local-storage';
export * from './transactions/bonus-points';
export * from './fileUtils';

// Add additional exports as needed

================
File: utils/storage/merchants.ts
================
import { supabase } from '@/integrations/supabase/client';
import { MerchantCategoryCode } from '@/types';
import { storageService } from '@/services/storage';

export const getMerchantByName = async (name: string) => {
  if (!name || name.trim().length < 3) return null;
  
  const normalizedName = name.trim().toLowerCase();
  
  try {
    const useLocalStorage = storageService.isLocalStorageMode();
    
    if (useLocalStorage) {
      // For local storage implementation
      const storedMerchants = localStorage.getItem('merchants');
      if (storedMerchants) {
        const merchants = JSON.parse(storedMerchants);
        return merchants.find((m: any) => 
          m.name.toLowerCase().includes(normalizedName) ||
          normalizedName.includes(m.name.toLowerCase())
        );
      }
      return null;
    } else {
      // For Supabase implementation
      const { data, error } = await supabase
        .from('merchants')
        .select('*')
        .ilike('name', `%${normalizedName}%`)
        .order('created_at', { ascending: false })
        .limit(1);
      
      if (error || !data || data.length === 0) {
        return null;
      }
      
      return data[0];
    }
  } catch (error) {
    console.error('Error getting merchant by name:', error);
    return null;
  }
};

export const hasMerchantCategorySuggestions = async (name: string) => {
  if (!name || name.trim().length < 3) return false;
  
  const normalizedName = name.trim().toLowerCase();
  
  try {
    const useLocalStorage = storageService.isLocalStorageMode();
    
    if (useLocalStorage) {
      // For local storage implementation
      const storedMappings = localStorage.getItem('merchantCategoryMappings');
      if (storedMappings) {
        const mappings = JSON.parse(storedMappings);
        return mappings.some((m: any) => 
          m.merchant_name.toLowerCase().includes(normalizedName) ||
          normalizedName.includes(m.merchant_name.toLowerCase())
        );
      }
      return false;
    } else {
      // For Supabase implementation
      const { data, error } = await supabase
        .from('merchant_category_mappings')
        .select('id')
        .ilike('merchant_name', `%${normalizedName}%`)
        .not('most_common_mcc', 'is', null) // Fixed syntax for not is null
        .limit(1);
      
      if (error) {
        console.error('Error checking merchant category suggestions:', error);
        return false;
      }
      
      return data && data.length > 0;
    }
  } catch (error) {
    console.error('Error checking merchant category suggestions:', error);
    return false;
  }
};

export const getSuggestedMerchantCategory = async (name: string): Promise<MerchantCategoryCode | null> => {
  if (!name || name.trim().length < 3) return null;
  
  const normalizedName = name.trim().toLowerCase();
  
  try {
    const useLocalStorage = storageService.isLocalStorageMode();
    
    if (useLocalStorage) {
      // For local storage implementation
      const storedMappings = localStorage.getItem('merchantCategoryMappings');
      if (storedMappings) {
        const mappings = JSON.parse(storedMappings);
        const match = mappings.find((m: any) => 
          m.merchant_name.toLowerCase().includes(normalizedName) ||
          normalizedName.includes(m.merchant_name.toLowerCase())
        );
        
        return match?.most_common_mcc || null;
      }
      return null;
    } else {
      // For Supabase implementation
      const { data, error } = await supabase
        .from('merchant_category_mappings')
        .select('most_common_mcc')
        .ilike('merchant_name', `%${normalizedName}%`)
        .order('occurrence_count', { ascending: false })
        .limit(1);
      
      if (error || !data || data.length === 0) {
        return null;
      }
      
      // Fix: Properly validate and convert the JSON data to the MerchantCategoryCode type
      const jsonMcc = data[0].most_common_mcc;
      
      // Validate JSON shape before casting
      if (jsonMcc && 
          typeof jsonMcc === 'object' && 
          'code' in jsonMcc && 
          'description' in jsonMcc &&
          typeof jsonMcc.code === 'string' && 
          typeof jsonMcc.description === 'string') {
        
        // Create a new properly typed object rather than casting directly
        return {
          code: jsonMcc.code as string,
          description: jsonMcc.description as string
        };
      }
      
      return null;
    }
  } catch (error) {
    console.error('Error getting suggested merchant category:', error);
    return null;
  }
};

================
File: utils/storage/merchantTracking.ts
================
import { supabase } from '@/integrations/supabase/client';
import { storageService } from '@/services/storage';
import { v4 as uuidv4 } from 'uuid';

export function incrementMerchantOccurrence(merchantName: string, mcc?: any): Promise<boolean> {
  if (!merchantName || merchantName.trim().length === 0) {
    return Promise.resolve(false);
  }
  
  const normalizedName = merchantName.trim();
  
  return new Promise(async (resolve) => {
    try {
      const useLocalStorage = storageService.isLocalStorageMode();
      
      if (useLocalStorage) {
        // For local storage
        const storedMappings = localStorage.getItem('merchantCategoryMappings') || '[]';
        const mappings = JSON.parse(storedMappings);
        
        // Find if we already have this merchant
        const existingIndex = mappings.findIndex((m: any) => 
          m.merchant_name.toLowerCase() === normalizedName.toLowerCase()
        );
        
        if (existingIndex >= 0) {
          // Update existing mapping
          mappings[existingIndex].occurrence_count += 1;
          
          // Update most common MCC if provided
          if (mcc) {
            mappings[existingIndex].most_common_mcc = mcc;
          }
        } else {
          // Create new mapping
          mappings.push({
            id: uuidv4(),
            merchant_name: normalizedName,
            occurrence_count: 1,
            most_common_mcc: mcc || null,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          });
        }
        
        localStorage.setItem('merchantCategoryMappings', JSON.stringify(mappings));
        resolve(true);
      } else {
        // For Supabase
        // First check if mapping exists
        const { data, error } = await supabase
          .from('merchant_category_mappings')
          .select('id, occurrence_count, most_common_mcc')
          .eq('merchant_name', normalizedName)
          .limit(1);
        
        if (error) {
          console.error('Error checking merchant mapping:', error);
          resolve(false);
          return;
        }
        
        if (data && data.length > 0) {
          // Update existing mapping
          const mapping = data[0];
          const updateData: any = {
            occurrence_count: (mapping.occurrence_count || 0) + 1,
            updated_at: new Date().toISOString()
          };
          
          // Update MCC if provided
          if (mcc) {
            updateData.most_common_mcc = mcc;
          }
          
          const { error: updateError } = await supabase
            .from('merchant_category_mappings')
            .update(updateData)
            .eq('id', mapping.id);
          
          if (updateError) {
            console.error('Error updating merchant mapping:', updateError);
          }
          
          resolve(!updateError);
        } else {
          // Create new mapping
          const { error: insertError } = await supabase
            .from('merchant_category_mappings')
            .insert({
              merchant_name: normalizedName,
              occurrence_count: 1,
              most_common_mcc: mcc || null
            });
          
          if (insertError) {
            console.error('Error creating merchant mapping:', insertError);
          }
          
          resolve(!insertError);
        }
      }
    } catch (error) {
      console.error('Error tracking merchant occurrence:', error);
      resolve(false);
    }
  });
}

export function recordBonusPointsMovement(transactionId: string, paymentMethodId: string, points: number): Promise<boolean> {
  if (!points || points <= 0) {
    return Promise.resolve(false);
  }
  
  return new Promise(async (resolve) => {
    try {
      const useLocalStorage = storageService.isLocalStorageMode();
      
      if (useLocalStorage) {
        // For local storage
        const storedMovements = localStorage.getItem('bonusPointsMovements') || '[]';
        const movements = JSON.parse(storedMovements);
        
        movements.push({
          id: uuidv4(),
          transaction_id: transactionId,
          payment_method_id: paymentMethodId,
          bonus_points: points,
          created_at: new Date().toISOString()
        });
        
        localStorage.setItem('bonusPointsMovements', JSON.stringify(movements));
        resolve(true);
      } else {
        // For Supabase
        const { error } = await supabase
          .from('bonus_points_movements')
          .insert({
            transaction_id: transactionId,
            payment_method_id: paymentMethodId,
            bonus_points: points
          });
        
        if (error) {
          console.error('Error recording bonus points movement:', error);
        }
        
        resolve(!error);
      }
    } catch (error) {
      console.error('Error recording bonus points movement:', error);
      resolve(false);
    }
  });
}

================
File: utils/storage/paymentMethods.ts
================
import { PaymentMethod } from '@/types';
import { supabase } from '@/integrations/supabase/client';
import { v4 as uuidv4 } from 'uuid';
import { storageService } from '@/services/storage';

export const getPaymentMethods = async (): Promise<PaymentMethod[]> => {
  try {
    const useLocalStorage = storageService.isLocalStorageMode();
    console.log(`Getting payment methods with localStorage mode: ${useLocalStorage}`);
    
    if (useLocalStorage) {
      // Try to get from local storage
      const storedPaymentMethods = localStorage.getItem('paymentMethods');
      if (storedPaymentMethods) {
        return JSON.parse(storedPaymentMethods) as PaymentMethod[];
      }
      
      // Return default methods if none found
      return getDefaultPaymentMethods();
    } else {
      // Get from Supabase
      const { data, error } = await supabase
        .from('payment_methods')
        .select('*')
        .order('name');
      
      if (error) {
        console.error('Error fetching payment methods:', error);
        // Fallback to local storage
        return getDefaultPaymentMethods();
      }
      
      if (!data || data.length === 0) {
        console.log('No payment methods found, returning defaults');
        return getDefaultPaymentMethods();
      }
      
      // Transform to our PaymentMethod type
      const paymentMethods = data.map(item => ({
        id: item.id,
        name: item.name,
        type: item.type as 'credit_card' | 'cash',
        currency: item.currency,
        active: item.active !== false,
        issuer: item.issuer,
        lastFourDigits: item.last_four_digits,
        imageUrl: item.image_url,
        color: item.color,
        isMonthlyStatement: item.is_monthly_statement,
        statementStartDay: item.statement_start_day,
        rewardRules: (item.reward_rules || []) as any[]
      })) as PaymentMethod[];
      
      console.log(`Retrieved ${paymentMethods.length} payment methods from Supabase`);
      return paymentMethods;
    }
  } catch (error) {
    console.error('Error getting payment methods:', error);
    return getDefaultPaymentMethods();
  }
};

function getDefaultPaymentMethods(): PaymentMethod[] {
  return [
    {
      id: uuidv4(),
      name: 'Cash (SGD)',
      type: 'cash',
      currency: 'SGD',
      active: true,
      rewardRules: []
    },
    {
      id: uuidv4(),
      name: 'Cash (USD)',
      type: 'cash',
      currency: 'USD',
      active: true,
      rewardRules: []
    },
    {
      id: uuidv4(),
      name: 'Visa Card',
      type: 'credit_card',
      currency: 'SGD',
      issuer: 'Visa',
      lastFourDigits: '1234',
      active: true,
      rewardRules: []
    }
  ];
}

export const addPaymentMethod = async (paymentMethod: Omit<PaymentMethod, 'id'>): Promise<PaymentMethod> => {
  const newMethod = { ...paymentMethod, id: uuidv4() };
  
  // Implementation of adding payment method
  try {
    const useLocalStorage = storageService.isLocalStorageMode();
    
    if (useLocalStorage) {
      const methods = await getPaymentMethods();
      const updatedMethods = [...methods, newMethod];
      localStorage.setItem('paymentMethods', JSON.stringify(updatedMethods));
    } else {
      // Transform to database format
      const { error } = await supabase.from('payment_methods').insert({
        id: newMethod.id,
        name: newMethod.name,
        type: newMethod.type,
        currency: newMethod.currency,
        active: newMethod.active,
        issuer: newMethod.issuer,
        last_four_digits: newMethod.lastFourDigits,
        image_url: newMethod.imageUrl,
        color: newMethod.color,
        is_monthly_statement: newMethod.isMonthlyStatement,
        statement_start_day: newMethod.statementStartDay,
        reward_rules: newMethod.rewardRules as any
      });
      
      if (error) throw new Error(`Failed to add payment method: ${error.message}`);
    }
    
    return newMethod;
  } catch (error) {
    console.error('Error adding payment method:', error);
    throw error;
  }
};

export const updatePaymentMethod = async (id: string, data: Partial<PaymentMethod>): Promise<PaymentMethod> => {
  try {
    const useLocalStorage = storageService.isLocalStorageMode();
    
    if (useLocalStorage) {
      const methods = await getPaymentMethods();
      const updatedMethods = methods.map(m => m.id === id ? { ...m, ...data } : m);
      localStorage.setItem('paymentMethods', JSON.stringify(updatedMethods));
      return updatedMethods.find(m => m.id === id) as PaymentMethod;
    } else {
      // Transform to database format
      const dbData: any = {
        name: data.name,
        type: data.type,
        currency: data.currency,
        active: data.active,
        issuer: data.issuer,
        last_four_digits: data.lastFourDigits,
        image_url: data.imageUrl,
        color: data.color,
        is_monthly_statement: data.isMonthlyStatement,
        statement_start_day: data.statementStartDay,
        reward_rules: data.rewardRules as any
      };
      
      // Remove undefined values
      Object.keys(dbData).forEach(key => dbData[key] === undefined && delete dbData[key]);
      
      const { error } = await supabase
        .from('payment_methods')
        .update(dbData)
        .eq('id', id);
      
      if (error) throw new Error(`Failed to update payment method: ${error.message}`);
      
      // Get updated method
      const { data: updated, error: fetchError } = await supabase
        .from('payment_methods')
        .select('*')
        .eq('id', id)
        .maybeSingle();
      
      if (fetchError || !updated) {
        throw new Error(`Failed to fetch updated payment method: ${fetchError?.message || 'Not found'}`);
      }
      
      return {
        id: updated.id,
        name: updated.name,
        type: updated.type as 'credit_card' | 'cash',
        currency: updated.currency,
        active: updated.active !== false,
        issuer: updated.issuer,
        lastFourDigits: updated.last_four_digits,
        imageUrl: updated.image_url,
        color: updated.color,
        isMonthlyStatement: updated.is_monthly_statement,
        statementStartDay: updated.statement_start_day,
        rewardRules: (updated.reward_rules || []) as any[]
      } as PaymentMethod;
    }
  } catch (error) {
    console.error('Error updating payment method:', error);
    throw error;
  }
};

export const deletePaymentMethod = async (id: string): Promise<boolean> => {
  try {
    const useLocalStorage = storageService.isLocalStorageMode();
    
    if (useLocalStorage) {
      const methods = await getPaymentMethods();
      const updatedMethods = methods.filter(m => m.id !== id);
      localStorage.setItem('paymentMethods', JSON.stringify(updatedMethods));
    } else {
      const { error } = await supabase
        .from('payment_methods')
        .delete()
        .eq('id', id);
      
      if (error) throw new Error(`Failed to delete payment method: ${error.message}`);
    }
    return true;
  } catch (error) {
    console.error('Error deleting payment method:', error);
    return false;
  }
};

export const savePaymentMethods = async (paymentMethods: PaymentMethod[]): Promise<boolean> => {
  try {
    const useLocalStorage = storageService.isLocalStorageMode();
    
    if (useLocalStorage) {
      localStorage.setItem('paymentMethods', JSON.stringify(paymentMethods));
    } else {
      // For Supabase, we need to handle each method individually
      for (const method of paymentMethods) {
        // Check if method exists
        const { data, error: checkError } = await supabase
          .from('payment_methods')
          .select('id')
          .eq('id', method.id)
          .maybeSingle();
        
        if (checkError) {
          console.error('Error checking payment method:', checkError);
          continue;
        }
        
        const dbData = {
          id: method.id,
          name: method.name,
          type: method.type,
          currency: method.currency,
          active: method.active,
          issuer: method.issuer,
          last_four_digits: method.lastFourDigits,
          image_url: method.imageUrl,
          color: method.color,
          is_monthly_statement: method.isMonthlyStatement,
          statement_start_day: method.statementStartDay,
          reward_rules: method.rewardRules as any
        };
        
        if (data) {
          // Update existing
          const { error } = await supabase
            .from('payment_methods')
            .update(dbData)
            .eq('id', method.id);
          
          if (error) console.error('Error updating payment method:', error);
        } else {
          // Insert new
          const { error } = await supabase
            .from('payment_methods')
            .insert(dbData);
          
          if (error) console.error('Error inserting payment method:', error);
        }
      }
    }
    return true;
  } catch (error) {
    console.error('Error saving payment methods:', error);
    return false;
  }
};

export const uploadCardImage = async (file: File, paymentMethodId: string): Promise<string | null> => {
  try {
    const useLocalStorage = storageService.isLocalStorageMode();
    
    if (useLocalStorage) {
      // For local storage, just create a data URL
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          resolve(reader.result as string);
        };
        reader.readAsDataURL(file);
      });
    } else {
      // For Supabase, upload to storage
      const fileName = `${paymentMethodId}-${new Date().getTime()}`;
      const fileExt = file.name.split('.').pop();
      const filePath = `card-images/${fileName}.${fileExt}`;
      
      // Create storage bucket if it doesn't exist
      // Note: This assumes you have the appropriate storage bucket set up
      const { error: uploadError } = await supabase.storage
        .from('card-images')
        .upload(filePath, file, {
          upsert: true,
          cacheControl: '3600'
        });
      
      if (uploadError) {
        console.error('Error uploading card image:', uploadError);
        return null;
      }
      
      // Get the public URL
      const { data } = supabase.storage
        .from('card-images')
        .getPublicUrl(filePath);
      
      const imageUrl = data.publicUrl;
      
      // Update the payment method with the image URL
      await updatePaymentMethod(paymentMethodId, { imageUrl });
      
      return imageUrl;
    }
  } catch (error) {
    console.error('Error uploading card image:', error);
    return null;
  }
};

================
File: utils/storage/transactions.ts
================
import { Transaction, Currency } from '@/types';
import { addTransaction } from './transactions/add';
import { editTransaction } from './transactions/edit';
import { deleteTransaction } from './transactions/delete';
import { getTransactions } from './transactions/get';
import { exportTransactionsToCSV } from './transactions/export';
import { saveTransactions } from './transactions/save';
import { 
  getTransactionsFromLocalStorage, 
  saveTransactionsToLocalStorage 
} from './transactions/local-storage';

// Export all transaction-related functions with aliases for backward compatibility
export {
  getTransactions,
  saveTransactions,
  addTransaction as createTransaction, // Alias addTransaction as createTransaction
  editTransaction as updateTransaction, // Alias editTransaction as updateTransaction
  deleteTransaction,
  exportTransactionsToCSV,
  getTransactionsFromLocalStorage,
  saveTransactionsToLocalStorage
};

// Re-export the original function names too
export {
  addTransaction,
  editTransaction
};

================
File: utils/currencyFormatter.ts
================
import { Currency } from '@/types';

const currencySymbols: Record<Currency, string> = {
  USD: '$',
  EUR: '',
  GBP: '',
  JPY: '',
  AUD: 'A$',
  CAD: 'C$',
  CNY: '',
  INR: '',
  TWD: 'NT$',
  SGD: 'S$',  // Explicitly set to 'S$' for consistency
  VND: '',
  IDR: 'Rp',
  THB: '',
  MYR: 'RM',
};

export const formatCurrency = (amount: number, currency: Currency): string => {
  // Added debug log to check currency formatting
  console.log(`Formatting currency: ${amount} ${currency}`);
  
  // Handle edge cases where currency might be undefined or invalid
  if (!currency || !Object.keys(currencySymbols).includes(currency)) {
    console.warn(`Invalid currency provided: ${currency}, using USD as fallback`);
    currency = 'USD' as Currency;
  }
  
  // Instead of using the built-in Intl.NumberFormat currency formatting,
  // we'll use our custom currency symbols and format the number separately
  const formatter = new Intl.NumberFormat('en-US', {
    style: 'decimal', // Use decimal instead of currency to avoid built-in currency symbols
    minimumFractionDigits: ['JPY', 'VND', 'IDR', 'TWD'].includes(currency) ? 0 : 2,
    maximumFractionDigits: ['JPY', 'VND', 'IDR', 'TWD'].includes(currency) ? 0 : 2,
  });
  
  // Get the symbol from our mapping and combine with the formatted number
  const symbol = currencySymbols[currency];
  return `${symbol}${formatter.format(amount)}`;
};

export const getCurrencySymbol = (currency: Currency): string => {
  return currencySymbols[currency] || currency;
};

export const currencyOptions: { value: Currency; label: string }[] = [
  { value: 'USD', label: 'USD - US Dollar ($)' },
  { value: 'EUR', label: 'EUR - Euro ()' },
  { value: 'GBP', label: 'GBP - British Pound ()' },
  { value: 'JPY', label: 'JPY - Japanese Yen ()' },
  { value: 'AUD', label: 'AUD - Australian Dollar (A$)' },
  { value: 'CAD', label: 'CAD - Canadian Dollar (C$)' },
  { value: 'CNY', label: 'CNY - Chinese Yuan ()' },
  { value: 'INR', label: 'INR - Indian Rupee ()' },
  { value: 'TWD', label: 'TWD - New Taiwan Dollar (NT$)' },
  { value: 'SGD', label: 'SGD - Singapore Dollar (S$)' },
  { value: 'VND', label: 'VND - Vietnamese Dong ()' },
  { value: 'IDR', label: 'IDR - Indonesian Rupiah (Rp)' },
  { value: 'THB', label: 'THB - Thai Baht ()' },
  { value: 'MYR', label: 'MYR - Malaysian Ringgit (RM)' },
];

================
File: utils/dateUtils.ts
================
import { format, parse, isWithinInterval, startOfMonth, endOfMonth, addMonths } from 'date-fns';
import { PaymentMethod } from '@/types';

export const formatDate = (dateString: string): string => {
  const date = new Date(dateString);
  return format(date, 'MMM d, yyyy');
};

export const formatDateShort = (dateString: string): string => {
  const date = new Date(dateString);
  return format(date, 'MM/dd/yy');
};

export const formatDateTime = (dateString: string): string => {
  const date = new Date(dateString);
  return format(date, 'MMM d, yyyy h:mm a');
};

export const getCurrentDateString = (): string => {
  return format(new Date(), 'yyyy-MM-dd');
};

export const getStatementPeriod = (
  paymentMethod: PaymentMethod,
  date: Date = new Date()
): { start: Date; end: Date } => {
  // If no statement configuration, default to calendar month
  if (!paymentMethod.statementStartDay || !paymentMethod.isMonthlyStatement) {
    return {
      start: startOfMonth(date),
      end: endOfMonth(date),
    };
  }

  // Get statement start day (1-31)
  const statementDay = paymentMethod.statementStartDay;
  
  // Find the start date of the current statement period
  let statementStart = new Date(date.getFullYear(), date.getMonth(), statementDay);
  
  // If the current date is before the statement start day, the statement started in the previous month
  if (date.getDate() < statementDay) {
    statementStart = new Date(date.getFullYear(), date.getMonth() - 1, statementDay);
  }
  
  // Statement end is one day before the next statement start
  const statementEnd = new Date(statementStart);
  statementEnd.setMonth(statementEnd.getMonth() + 1);
  statementEnd.setDate(statementEnd.getDate() - 1);
  
  return { start: statementStart, end: statementEnd };
};

export const isDateInStatementPeriod = (
  date: Date, 
  paymentMethod: PaymentMethod
): boolean => {
  const { start, end } = getStatementPeriod(paymentMethod, date);
  return isWithinInterval(date, { start, end });
};

================
File: utils/formatting.ts
================
// src/utils/formatting.ts

/**
 * Formats a number with thousands separators
 * @param value Number to format
 * @returns Formatted string with thousands separators
 */
export const formatNumber = (value: number): string => {
  return value.toLocaleString();
};

/**
 * Formats a percentage value with appropriate sign and decimal places
 * @param value Percentage value to format
 * @param showSign Whether to show + sign for positive values
 * @param decimalPlaces Number of decimal places to show
 * @returns Formatted percentage string
 */
export const formatPercentage = (
  value: number,
  showSign: boolean = false,
  decimalPlaces: number = 1
): string => {
  const formattedValue = value.toFixed(decimalPlaces);
  const prefix = showSign && value > 0 ? "+" : "";
  return `${prefix}${formattedValue}%`;
};

/**
 * Determines if an expense percentage change is positive (bad) or negative (good)
 * For expenses, an increase is bad (positive = true), a decrease is good (positive = false)
 * @param percentageChange Percentage change value
 * @returns Boolean indicating if change is positive (bad for expenses)
 */
export const isExpenseChangePositive = (percentageChange: number): boolean => {
  return percentageChange >= 0;
};

/**
 * Gets the appropriate color class for an expense trend
 * @param percentageChange Percentage change value
 * @returns CSS class for coloring the trend
 */
export const getExpenseTrendColor = (percentageChange: number): string => {
  const isPositive = isExpenseChangePositive(percentageChange);
  return isPositive
    ? "text-red-500 dark:text-red-400"
    : "text-green-500 dark:text-green-400";
};

/**
 * Formats a date string in a consistent way
 * @param dateString ISO date string
 * @returns Formatted date (e.g., "Jan 15, 2023")
 */
export const formatDate = (dateString: string): string => {
  const date = new Date(dateString);
  return date.toLocaleDateString(undefined, {
    month: "short",
    day: "numeric",
    year: "numeric",
  });
};

/**
 * Formats a date string in a short format
 * @param dateString ISO date string
 * @returns Formatted date (e.g., "01/15/23")
 */
export const formatDateShort = (dateString: string): string => {
  const date = new Date(dateString);
  return date.toLocaleDateString(undefined, {
    month: "2-digit",
    day: "2-digit",
    year: "2-digit",
  });
};

/**
 * Formats a date with time
 * @param dateString ISO date string
 * @returns Formatted date with time (e.g., "Jan 15, 2023 2:30 PM")
 */
export const formatDateTime = (dateString: string): string => {
  const date = new Date(dateString);
  return date.toLocaleString(undefined, {
    month: "short",
    day: "numeric",
    year: "numeric",
    hour: "numeric",
    minute: "2-digit",
  });
};

/**
 * Gets the current date as an ISO string (YYYY-MM-DD)
 * @returns Current date in YYYY-MM-DD format
 */
export const getCurrentDateString = (): string => {
  const date = new Date();
  return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}-${String(date.getDate()).padStart(2, "0")}`;
};

================
File: utils/storageUtils.ts
================
// Re-export all storage utilities
export * from '@/utils/storage/index';



================================================================
End of Codebase
================================================================
